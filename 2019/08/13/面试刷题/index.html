<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ahtang.com","root":"/","scheme":"Pisces","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治226. Invert Binary Tree (Easy)Invert a binary tree. 12345678910111213Example:Input:     4   &#x2F;   \  2     7 &#x2F; \   &#x2F; \1   3 6   9O">
<meta property="og:type" content="article">
<meta property="og:title" content="面试刷题">
<meta property="og:url" content="http://ahtang.com/2019/08/13/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="汤包个人页">
<meta property="og:description" content="Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治226. Invert Binary Tree (Easy)Invert a binary tree. 12345678910111213Example:Input:     4   &#x2F;   \  2     7 &#x2F; \   &#x2F; \1   3 6   9O">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg">
<meta property="og:image" content="http://ahtang.com/images/lintcode_127_topo_1.jpeg">
<meta property="og:image" content="http://ahtang.com/images/leetcode_17_lett_1.png">
<meta property="og:image" content="https://leetcode.com/static/images/problemset/maze_1_example_1.png">
<meta property="og:image" content="https://leetcode.com/static/images/problemset/maze_1_example_2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://i.imgur.com/e6P0mDW.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/histogram.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/03/06/1266.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/31/tree2.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/30/interval1.png">
<meta property="article:published_time" content="2019-08-13T13:17:00.000Z">
<meta property="article:modified_time" content="2021-09-13T00:02:18.000Z">
<meta property="article:tag" content="产品经理，软件工程师，区块链，互联网，流量变现">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png">


<link rel="canonical" href="http://ahtang.com/2019/08/13/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试刷题 | 汤包个人页</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2155923-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-2155923-2');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">汤包个人页</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">走过很多弯路的程序员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>文章</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Tree-based-Recursion-amp-Divide-Conquer-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB"><span class="nav-number">1.</span> <span class="nav-text">Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#226-Invert-Binary-Tree-Easy"><span class="nav-number">1.0.1.</span> <span class="nav-text">226. Invert Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100-Same-Tree-Easy"><span class="nav-number">1.0.2.</span> <span class="nav-text">100. Same Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-Symmetric-Tree-Easy"><span class="nav-number">1.0.3.</span> <span class="nav-text">101. Symmetric Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree-Easy"><span class="nav-number">1.0.4.</span> <span class="nav-text">104. Maximum Depth of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree-Easy"><span class="nav-number">1.0.5.</span> <span class="nav-text">111. Minimum Depth of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal-Medium"><span class="nav-number">1.0.6.</span> <span class="nav-text">144. Binary Tree Preorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal-Medium"><span class="nav-number">1.0.7.</span> <span class="nav-text">94. Binary Tree Inorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST-Medium"><span class="nav-number">1.0.8.</span> <span class="nav-text">230. Kth Smallest Element in a BST (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129-Sum-Root-to-Leaf-Numbers-Medium"><span class="nav-number">1.0.9.</span> <span class="nav-text">129. Sum Root to Leaf Numbers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node-Medium"><span class="nav-number">1.0.10.</span> <span class="nav-text">116. Populating Next Right Pointers in Each Node (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium"><span class="nav-number">1.0.11.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-Balanced-Binary-Tree-Easy"><span class="nav-number">1.0.12.</span> <span class="nav-text">110. Balanced Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy"><span class="nav-number">1.0.13.</span> <span class="nav-text">108. Convert Sorted Array to Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-Convert-Sorted-List-to-Binary-Search-Tree-Medium"><span class="nav-number">1.0.14.</span> <span class="nav-text">109. Convert Sorted List to Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-Path-Sum-Easy"><span class="nav-number">1.0.15.</span> <span class="nav-text">112. Path Sum (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#199-Binary-Tree-Right-Side-View-Medium"><span class="nav-number">1.0.16.</span> <span class="nav-text">199. Binary Tree Right Side View (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><span class="nav-number">1.0.17.</span> <span class="nav-text">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#543-Diameter-of-Binary-Tree-Easy"><span class="nav-number">1.0.18.</span> <span class="nav-text">543. Diameter of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#563-Binary-Tree-Tilt-Easy"><span class="nav-number">1.0.19.</span> <span class="nav-text">563. Binary Tree Tilt (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#669-Trim-a-Binary-Search-Tree-Easy"><span class="nav-number">1.0.20.</span> <span class="nav-text">669. Trim a Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#687-Longest-Univalue-Path-Medium"><span class="nav-number">1.0.21.</span> <span class="nav-text">687. Longest Univalue Path (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List-Medium"><span class="nav-number">1.0.22.</span> <span class="nav-text">114. Flatten Binary Tree to Linked List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><span class="nav-number">1.0.23.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#285-Inorder-Successor-in-BST-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">1.0.24.</span> <span class="nav-text">285. Inorder Successor in BST (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-Validate-Binary-Search-Tree-Medium"><span class="nav-number">1.0.25.</span> <span class="nav-text">98. Validate Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#572-Subtree-of-Another-Tree-Easy"><span class="nav-number">1.0.26.</span> <span class="nav-text">572. Subtree of Another Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#606-Construct-String-from-Binary-Tree-Easy"><span class="nav-number">1.0.27.</span> <span class="nav-text">606. Construct String from Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#297-Serialize-and-Deserialize-Binary-Tree-Hard"><span class="nav-number">1.0.28.</span> <span class="nav-text">297. Serialize and Deserialize Binary Tree (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#536-Construct-Binary-Tree-from-String-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">1.0.29.</span> <span class="nav-text">536. Construct Binary Tree from String (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium"><span class="nav-number">1.0.30.</span> <span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium"><span class="nav-number">1.0.31.</span> <span class="nav-text">106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-Medium"><span class="nav-number">1.0.32.</span> <span class="nav-text">889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes-Medium"><span class="nav-number">1.0.33.</span> <span class="nav-text">865. Smallest Subtree with all the Deepest Nodes (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">1.0.34.</span> <span class="nav-text">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#298-Binary-Tree-Longest-Consecutive-Sequence-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">1.0.35.</span> <span class="nav-text">298. Binary Tree Longest Consecutive Sequence (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#897-Increasing-Order-Search-Tree-Easy"><span class="nav-number">1.0.36.</span> <span class="nav-text">897. Increasing Order Search Tree (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree-based-BFS-%E5%9F%BA%E4%BA%8E%E6%A0%91%E7%9A%84-BFS"><span class="nav-number">1.1.</span> <span class="nav-text">Tree based BFS 基于树的 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal-Medium"><span class="nav-number">1.1.1.</span> <span class="nav-text">102. Binary Tree Level Order Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-Binary-Tree-Level-Order-Traversal-II-Easy"><span class="nav-number">1.1.2.</span> <span class="nav-text">107. Binary Tree Level Order Traversal II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><span class="nav-number">1.1.3.</span> <span class="nav-text">103. Binary Tree Zigzag Level Order Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#958-Check-Completeness-of-a-Binary-Tree-Medium"><span class="nav-number">1.1.4.</span> <span class="nav-text">958. Check Completeness of a Binary Tree (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Search-amp-LogN-Algorithm"><span class="nav-number">2.</span> <span class="nav-text">Binary Search &amp; LogN Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#704-Binary-Search-Easy"><span class="nav-number">2.0.1.</span> <span class="nav-text">704. Binary Search (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-14-First-Position-of-Target-Easy"><span class="nav-number">2.0.2.</span> <span class="nav-text">LinC 14. First Position of Target (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#278-First-Bad-Version-Easy"><span class="nav-number">2.0.3.</span> <span class="nav-text">278. First Bad Version (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><span class="nav-number">2.0.4.</span> <span class="nav-text">34. Find First and Last Position of Element in Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-61-Search-for-a-Range-Medium"><span class="nav-number">2.0.5.</span> <span class="nav-text">LinC 61. Search for a Range (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#852-Peak-Index-in-a-Mountain-Array"><span class="nav-number">2.0.6.</span> <span class="nav-text">852. Peak Index in a Mountain Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#162-Find-Peak-Element-Medium"><span class="nav-number">2.0.7.</span> <span class="nav-text">162. Find Peak Element (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-Search-a-2D-Matrix-Medium"><span class="nav-number">2.0.8.</span> <span class="nav-text">74. Search a 2D Matrix (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><span class="nav-number">2.0.9.</span> <span class="nav-text">153. Find Minimum in Rotated Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array-Medium"><span class="nav-number">2.0.10.</span> <span class="nav-text">33. Search in Rotated Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81-Search-in-Rotated-Sorted-Array-II-Medium"><span class="nav-number">2.0.11.</span> <span class="nav-text">81. Search in Rotated Sorted Array II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-Sqrt-x-Easy"><span class="nav-number">2.0.12.</span> <span class="nav-text">69. Sqrt(x) (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-Search-Insert-Position-Easy"><span class="nav-number">2.0.13.</span> <span class="nav-text">35. Search Insert Position (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#658-Find-K-Closest-Elements-Medium"><span class="nav-number">2.0.14.</span> <span class="nav-text">658. Find K Closest Elements (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#528-Random-Pick-with-Weight-Medium"><span class="nav-number">2.0.15.</span> <span class="nav-text">528. Random Pick with Weight (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#981-Time-Based-Key-Value-Store-Medium"><span class="nav-number">2.0.16.</span> <span class="nav-text">981. Time Based Key-Value Store (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Two-pointers"><span class="nav-number">3.</span> <span class="nav-text">Two pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy"><span class="nav-number">3.0.1.</span> <span class="nav-text">LinC 373. Partition Array by Odd and Even (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array-Easy"><span class="nav-number">3.0.2.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-Remove-Duplicates-from-Sorted-Array-II-Medium"><span class="nav-number">3.0.3.</span> <span class="nav-text">80. Remove Duplicates from Sorted Array II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-Implement-strStr-Easy"><span class="nav-number">3.0.4.</span> <span class="nav-text">28. Implement strStr() (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-Move-Zeroes-Easy"><span class="nav-number">3.0.5.</span> <span class="nav-text">283. Move Zeroes (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-Valid-Palindrome-Easy"><span class="nav-number">3.0.6.</span> <span class="nav-text">125. Valid Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#680-Valid-Palindrome-II-Easy"><span class="nav-number">3.0.7.</span> <span class="nav-text">680. Valid Palindrome II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Two-Sum-Easy"><span class="nav-number">3.0.8.</span> <span class="nav-text">1. Two Sum (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#167-Two-Sum-II-Input-array-is-sorted-Easy"><span class="nav-number">3.0.9.</span> <span class="nav-text">167. Two Sum II - Input array is sorted (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-607-Two-Sum-III-Data-structure-design-Easy"><span class="nav-number">3.0.10.</span> <span class="nav-text">LinC 607. Two Sum III - Data structure design (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3Sum-Medium"><span class="nav-number">3.0.11.</span> <span class="nav-text">15. 3Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-382-Triangle-Count-Medium"><span class="nav-number">3.0.12.</span> <span class="nav-text">LinC 382. Triangle Count (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3Sum-Closest-Medium"><span class="nav-number">3.0.13.</span> <span class="nav-text">16. 3Sum Closest (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-31-Partition-Array-Medium"><span class="nav-number">3.0.14.</span> <span class="nav-text">LinC 31. Partition Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array-Medium"><span class="nav-number">3.0.15.</span> <span class="nav-text">215. Kth Largest Element in an Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-Sort-Colors-Medium"><span class="nav-number">3.0.16.</span> <span class="nav-text">75. Sort Colors (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4Sum-Medium"><span class="nav-number">3.0.17.</span> <span class="nav-text">18. 4Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">3.0.18.</span> <span class="nav-text">27. Remove Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Container-With-Most-Water-Medium"><span class="nav-number">3.0.19.</span> <span class="nav-text">11. Container With Most Water (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#345-Reverse-Vowels-of-a-String-Easy"><span class="nav-number">3.0.20.</span> <span class="nav-text">345. Reverse Vowels of a String (Easy)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">4.</span> <span class="nav-text">BFS 广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#695-Max-Area-of-Island-Medium"><span class="nav-number">4.0.1.</span> <span class="nav-text">695. Max Area of Island (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-Clone-Graph-Medium"><span class="nav-number">4.0.2.</span> <span class="nav-text">133. Clone Graph (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-Word-Ladder-Medium"><span class="nav-number">4.0.3.</span> <span class="nav-text">127. Word Ladder (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-Number-of-Islands-Medium"><span class="nav-number">4.0.4.</span> <span class="nav-text">200. Number of Islands (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-611-Knight-Shortest-Path-Medium"><span class="nav-number">4.0.5.</span> <span class="nav-text">LinC 611. Knight Shortest Path (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#785-Is-Graph-Bipartite-Medium"><span class="nav-number">4.0.6.</span> <span class="nav-text">785. Is Graph Bipartite? (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-178-Graph-Valid-Tree-Medium"><span class="nav-number">4.0.7.</span> <span class="nav-text">LinC 178. Graph Valid Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#130-Surrounded-Regions-Medium"><span class="nav-number">4.0.8.</span> <span class="nav-text">130. Surrounded Regions (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#675-Cut-Off-Trees-for-Golf-Event-Hard"><span class="nav-number">4.0.9.</span> <span class="nav-text">675. Cut Off Trees for Golf Event (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#310-Minimum-Height-Trees-Medium"><span class="nav-number">4.0.10.</span> <span class="nav-text">310. Minimum Height Trees (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Topological-sorting-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">4.1.</span> <span class="nav-text">Topological sorting 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-127-Topological-Sorting-Medium"><span class="nav-number">4.1.1.</span> <span class="nav-text">LinC 127. Topological Sorting (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-Course-Schedule-Medium"><span class="nav-number">4.1.2.</span> <span class="nav-text">207. Course Schedule (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#210-Course-Schedule-II-Medium"><span class="nav-number">4.1.3.</span> <span class="nav-text">210. Course Schedule II (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.</span> <span class="nav-text">DFS 深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-DFS-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E6%A0%91%E4%B8%8A%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.1.</span> <span class="nav-text">Binary Tree DFS 二叉树与树上的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#257-Binary-Tree-Paths-Easy"><span class="nav-number">5.1.1.</span> <span class="nav-text">257. Binary Tree Paths (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-Path-Sum-II-Medium"><span class="nav-number">5.1.2.</span> <span class="nav-text">113. Path Sum II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-Path-Sum-III-Medium"><span class="nav-number">5.1.3.</span> <span class="nav-text">437. Path Sum III (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Combination-based-DFS-%E5%9F%BA%E4%BA%8E%E7%BB%84%E5%90%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.2.</span> <span class="nav-text">Combination based DFS - 基于组合的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#78-Subsets-Medium"><span class="nav-number">5.2.1.</span> <span class="nav-text">78. Subsets (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Combination-Sum-Medium"><span class="nav-number">5.2.2.</span> <span class="nav-text">39. Combination Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-Combination-Sum-II-Medium"><span class="nav-number">5.2.3.</span> <span class="nav-text">40. Combination Sum II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#216-combination-sum-iii-medium"><span class="nav-number">5.2.4.</span> <span class="nav-text">216. combination sum iii (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-combinations-medium"><span class="nav-number">5.2.5.</span> <span class="nav-text">77. combinations (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-palindrome-partitioning-medium"><span class="nav-number">5.2.6.</span> <span class="nav-text">131. palindrome partitioning (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-restore-ip-addresses-medium"><span class="nav-number">5.2.7.</span> <span class="nav-text">93. restore ip addresses (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linc-680-split-string-easy"><span class="nav-number">5.2.8.</span> <span class="nav-text">linc 680. split string (easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-subsets-ii-medium"><span class="nav-number">5.2.9.</span> <span class="nav-text">90. subsets ii (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#140-Word-Break-II-Hard"><span class="nav-number">5.2.10.</span> <span class="nav-text">140. Word Break II (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Permutation-based-DFS-%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.3.</span> <span class="nav-text">Permutation based DFS - 基于排列的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#46-Permutations-Medium"><span class="nav-number">5.3.1.</span> <span class="nav-text">46. Permutations (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-Permutations-II-Medium"><span class="nav-number">5.3.2.</span> <span class="nav-text">47. Permutations II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Generate-Parentheses-Medium"><span class="nav-number">5.3.3.</span> <span class="nav-text">22. Generate Parentheses (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N-Queens-Hard"><span class="nav-number">5.3.4.</span> <span class="nav-text">51. N-Queens (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-based-DFS-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.4.</span> <span class="nav-text">Graph based DFS 基于图的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-Letter-Combinations-of-a-Phone-Number-Medium"><span class="nav-number">5.4.1.</span> <span class="nav-text">17. Letter Combinations of a Phone Number (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-Word-Search-Medium"><span class="nav-number">5.4.2.</span> <span class="nav-text">79. Word Search (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#490-The-Maze-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">5.4.3.</span> <span class="nav-text">490. The Maze (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#417-Pacific-Atlantic-Water-Flow-Medium"><span class="nav-number">5.4.4.</span> <span class="nav-text">417. Pacific Atlantic Water Flow (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#399-Evaluate-Division-Medium"><span class="nav-number">5.4.5.</span> <span class="nav-text">399. Evaluate Division (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-Reconstruct-Itinerary-Medium"><span class="nav-number">5.4.6.</span> <span class="nav-text">332. Reconstruct Itinerary (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-%E6%95%B0%E7%BB%84"><span class="nav-number">6.1.</span> <span class="nav-text">Array 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-6-Merge-Two-Sorted-Arrays-Easy"><span class="nav-number">6.1.1.</span> <span class="nav-text">LinC 6. Merge Two Sorted Arrays (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-Merge-Sorted-Array-Easy"><span class="nav-number">6.1.2.</span> <span class="nav-text">88. Merge Sorted Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-Set-Matrix-Zeroes-Medium"><span class="nav-number">6.1.3.</span> <span class="nav-text">73. Set Matrix Zeroes (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-Merge-Intervals-Medium"><span class="nav-number">6.1.4.</span> <span class="nav-text">56. Merge Intervals (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><span class="nav-number">6.1.5.</span> <span class="nav-text">LinC 839. Merge Two Sorted Interval Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#228-Summary-Ranges-Medium"><span class="nav-number">6.1.6.</span> <span class="nav-text">228. Summary Ranges (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-Add-Binary-Easy"><span class="nav-number">6.1.7.</span> <span class="nav-text">67. Add Binary (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Integer-to-Roman-Medium"><span class="nav-number">6.1.8.</span> <span class="nav-text">12. Integer to Roman (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-Multiply-Strings-Medium"><span class="nav-number">6.1.9.</span> <span class="nav-text">43. Multiply Strings (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-Longest-Consecutive-Sequence-Medium"><span class="nav-number">6.1.10.</span> <span class="nav-text">128. Longest Consecutive Sequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-Plus-One-Easy"><span class="nav-number">6.1.11.</span> <span class="nav-text">66. Plus One (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Palindrome-Number-Easy"><span class="nav-number">6.1.12.</span> <span class="nav-text">9. Palindrome Number (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-Spiral-Matrix-II-Medium"><span class="nav-number">6.1.13.</span> <span class="nav-text">59. Spiral Matrix II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-Rotate-Image-Medium"><span class="nav-number">6.1.14.</span> <span class="nav-text">48. Rotate Image (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-Spiral-Matrix-Medium"><span class="nav-number">6.1.15.</span> <span class="nav-text">54. Spiral Matrix (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-Text-Justification-Hard"><span class="nav-number">6.1.16.</span> <span class="nav-text">68. Text Justification (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Valid-Sudoku-Medium"><span class="nav-number">6.1.17.</span> <span class="nav-text">36. Valid Sudoku (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-Count-and-Say-Easy"><span class="nav-number">6.1.18.</span> <span class="nav-text">38. Count and Say (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Longest-Common-Prefix-Easy"><span class="nav-number">6.1.19.</span> <span class="nav-text">14. Longest Common Prefix (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119-Pascal%E2%80%99s-Triangle-II-Easy"><span class="nav-number">6.1.20.</span> <span class="nav-text">119. Pascal’s Triangle II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ZigZag-Conversion-Medium"><span class="nav-number">6.1.21.</span> <span class="nav-text">6. ZigZag Conversion (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-String-to-Integer-atoi-Medium"><span class="nav-number">6.1.22.</span> <span class="nav-text">8. String to Integer (atoi) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-Insert-Interval-Hard"><span class="nav-number">6.1.23.</span> <span class="nav-text">57. Insert Interval (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#937-Reorder-Log-Files-Easy"><span class="nav-number">6.1.24.</span> <span class="nav-text">937. Reorder Log Files (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#189-Rotate-Array-Easy"><span class="nav-number">6.1.25.</span> <span class="nav-text">189. Rotate Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#296-Best-Meeting-Point-Hard-%E5%B8%A6%E9%94%81"><span class="nav-number">6.1.26.</span> <span class="nav-text">296. Best Meeting Point (Hard) 带锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sliding-Window-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">6.2.</span> <span class="nav-text">Sliding Window 滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#438-Find-All-Anagrams-in-a-String-Medium"><span class="nav-number">6.2.1.</span> <span class="nav-text">438. Find All Anagrams in a String (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Longest-Substring-Without-Repeating-Characters-Medium"><span class="nav-number">6.2.2.</span> <span class="nav-text">3. Longest Substring Without Repeating Characters (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-Minimum-Window-Substring-Hard"><span class="nav-number">6.2.3.</span> <span class="nav-text">76. Minimum Window Substring (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1151-Minimum-Swaps-to-Group-All-1%E2%80%99s-Together-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">6.2.4.</span> <span class="nav-text">1151    Minimum Swaps to Group All 1’s Together (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1004-Max-Consecutive-Ones-III-medium"><span class="nav-number">6.2.5.</span> <span class="nav-text">1004. Max Consecutive Ones III medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linked-List-%E9%93%BE%E8%A1%A8"><span class="nav-number">6.3.</span> <span class="nav-text">Linked List 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#83-Remove-Duplicates-from-Sorted-List-Easy-83-Remove-Duplicates-from-Sorted-List"><span class="nav-number">6.3.1.</span> <span class="nav-text">[83. Remove Duplicates from Sorted List (Easy)](83. Remove Duplicates from Sorted List)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-Remove-Duplicates-from-Sorted-List-II-Medium"><span class="nav-number">6.3.2.</span> <span class="nav-text">82. Remove Duplicates from Sorted List II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists-Easy"><span class="nav-number">6.3.3.</span> <span class="nav-text">21. Merge Two Sorted Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Remove-Nth-Node-From-End-of-List-Medium"><span class="nav-number">6.3.4.</span> <span class="nav-text">19. Remove Nth Node From End of List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Add-Two-Numbers-Medium"><span class="nav-number">6.3.5.</span> <span class="nav-text">2. Add Two Numbers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-Partition-List-Medium"><span class="nav-number">6.3.6.</span> <span class="nav-text">86. Partition List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-Linked-List-Cycle-Easy"><span class="nav-number">6.3.7.</span> <span class="nav-text">141. Linked List Cycle (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-Linked-List-Cycle-II-Medium"><span class="nav-number">6.3.8.</span> <span class="nav-text">142. Linked List Cycle II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-Reverse-Linked-List-Easy"><span class="nav-number">6.3.9.</span> <span class="nav-text">206. Reverse Linked List (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists-Easy"><span class="nav-number">6.3.10.</span> <span class="nav-text">160. Intersection of Two Linked Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-Swap-Nodes-in-Pairs-Medium"><span class="nav-number">6.3.11.</span> <span class="nav-text">24. Swap Nodes in Pairs (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-Rotate-List-Medium"><span class="nav-number">6.3.12.</span> <span class="nav-text">61. Rotate List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-LRU-Cache-Medium"><span class="nav-number">6.3.13.</span> <span class="nav-text">146. LRU Cache (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234-Palindrome-Linked-List-Easy"><span class="nav-number">6.3.14.</span> <span class="nav-text">234. Palindrome Linked List (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-%E6%A0%88"><span class="nav-number">6.4.</span> <span class="nav-text">Stack 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-Valid-Parentheses-Easy"><span class="nav-number">6.4.1.</span> <span class="nav-text">20. Valid Parentheses (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-Simplify-Path-Medium"><span class="nav-number">6.4.2.</span> <span class="nav-text">71. Simplify Path (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#150-Evaluate-Reverse-Polish-Notation-Medium"><span class="nav-number">6.4.3.</span> <span class="nav-text">150. Evaluate Reverse Polish Notation (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#155-Min-Stack-Easy"><span class="nav-number">6.4.4.</span> <span class="nav-text">155. Min Stack (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#224-Basic-Calculator-Hard"><span class="nav-number">6.4.5.</span> <span class="nav-text">224. Basic Calculator (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#227-Basic-Calculator-II-Medium"><span class="nav-number">6.4.6.</span> <span class="nav-text">227. Basic Calculator II (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-%E9%98%9F%E5%88%97"><span class="nav-number">6.5.</span> <span class="nav-text">Queue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-642-Moving-Average-from-Data-Stream-Easy"><span class="nav-number">6.5.1.</span> <span class="nav-text">LinC 642. Moving Average from Data Stream (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">6.6.</span> <span class="nav-text">Hash 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#290-Word-Pattern-Easy"><span class="nav-number">6.6.1.</span> <span class="nav-text">290. Word Pattern (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#387-First-Unique-Character-in-a-String-Easy"><span class="nav-number">6.6.2.</span> <span class="nav-text">387. First Unique Character in a String (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#409-Longest-Palindrome-Easy"><span class="nav-number">6.6.3.</span> <span class="nav-text">409. Longest Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1-Medium"><span class="nav-number">6.6.4.</span> <span class="nav-text">380. Insert Delete GetRandom O(1) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium-960-First-Unique-Number-in-a-Stream-II"><span class="nav-number">6.6.5.</span> <span class="nav-text">[LinC 960. First Unique Number in a Stream II (Medium)](960. First Unique Number in a Stream II)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-Group-Anagrams-Medium"><span class="nav-number">6.6.6.</span> <span class="nav-text">49. Group Anagrams (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#953-Verifying-an-Alien-Dictionary-Easy"><span class="nav-number">6.6.7.</span> <span class="nav-text">953. Verifying an Alien Dictionary (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Priority-Queue"><span class="nav-number">6.7.</span> <span class="nav-text">Heap (Priority Queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#264-Ugly-Number-II-Medium"><span class="nav-number">6.7.1.</span> <span class="nav-text">264. Ugly Number II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#973-K-Closest-Points-to-Origin-Medium"><span class="nav-number">6.7.2.</span> <span class="nav-text">973. K Closest Points to Origin (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-545-Top-k-Largest-Numbers-II-Medium"><span class="nav-number">6.7.3.</span> <span class="nav-text">LinC 545. Top k Largest Numbers II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-486-Merge-K-Sorted-Arrays-Medium"><span class="nav-number">6.7.4.</span> <span class="nav-text">LinC 486. Merge K Sorted Arrays (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-Merge-k-Sorted-Lists-Hard"><span class="nav-number">6.7.5.</span> <span class="nav-text">23. Merge k Sorted Lists (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#295-Find-Median-from-Data-Stream-Hard"><span class="nav-number">6.7.6.</span> <span class="nav-text">295. Find Median from Data Stream (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#743-Network-Delay-Time-Medium"><span class="nav-number">6.7.7.</span> <span class="nav-text">743. Network Delay Time (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#787-Cheapest-Flights-Within-K-Stops-Medium"><span class="nav-number">6.7.8.</span> <span class="nav-text">787. Cheapest Flights Within K Stops (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#855-Exam-Room-Medium"><span class="nav-number">6.7.9.</span> <span class="nav-text">855. Exam Room (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie"><span class="nav-number">6.8.</span> <span class="nav-text">Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree-Medium"><span class="nav-number">6.8.1.</span> <span class="nav-text">208. Implement Trie (Prefix Tree) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#211-Add-and-Search-Word-Data-structure-design-Medium"><span class="nav-number">6.8.2.</span> <span class="nav-text">211. Add and Search Word - Data structure design (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Union-Find-MST"><span class="nav-number">6.9.</span> <span class="nav-text">Union Find &#x2F; MST</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-629-Minimum-Spanning-Tree-Hard"><span class="nav-number">6.9.1.</span> <span class="nav-text">LinC 629. Minimum Spanning Tree (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP-Dynamic-Programming-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">7.</span> <span class="nav-text">DP Dynamic Programming 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#70-Climbing-Stairs-Easy"><span class="nav-number">7.0.1.</span> <span class="nav-text">70. Climbing Stairs (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-Triangle-Medium"><span class="nav-number">7.0.2.</span> <span class="nav-text">120. Triangle (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy"><span class="nav-number">7.0.3.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><span class="nav-number">7.0.4.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91-Decode-Ways-Medium"><span class="nav-number">7.0.5.</span> <span class="nav-text">91. Decode Ways (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-Unique-Paths-Medium"><span class="nav-number">7.0.6.</span> <span class="nav-text">62. Unique Paths (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-Maximum-Subarray-Easy"><span class="nav-number">7.0.7.</span> <span class="nav-text">53. Maximum Subarray (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-Unique-Paths-II-Medium"><span class="nav-number">7.0.8.</span> <span class="nav-text">63. Unique Paths II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-Minimum-Path-Sum-Medium"><span class="nav-number">7.0.9.</span> <span class="nav-text">64. Minimum Path Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-Edit-Distance-Hard"><span class="nav-number">7.0.10.</span> <span class="nav-text">72. Edit Distance (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#132-Palindrome-Partitioning-II-Hard"><span class="nav-number">7.0.11.</span> <span class="nav-text">132. Palindrome Partitioning II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Longest-Palindromic-Substring-Medium"><span class="nav-number">7.0.12.</span> <span class="nav-text">5. Longest Palindromic Substring (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-Jump-Game-Medium"><span class="nav-number">7.0.13.</span> <span class="nav-text">55. Jump Game (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-Unique-Binary-Search-Trees-Medium"><span class="nav-number">7.0.14.</span> <span class="nav-text">96. Unique Binary Search Trees (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#95-Unique-Binary-Search-Trees-II-Medium"><span class="nav-number">7.0.15.</span> <span class="nav-text">95. Unique Binary Search Trees II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-House-Robber-Easy"><span class="nav-number">7.0.16.</span> <span class="nav-text">198. House Robber (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-House-Robber-II-Medium"><span class="nav-number">7.0.17.</span> <span class="nav-text">213. House Robber II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Regular-Expression-Matching-Hard"><span class="nav-number">7.0.18.</span> <span class="nav-text">10. Regular Expression Matching (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-Wildcard-Matching-Hard"><span class="nav-number">7.0.19.</span> <span class="nav-text">44. Wildcard Matching (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-Word-Break-Medium"><span class="nav-number">7.0.20.</span> <span class="nav-text">139. Word Break (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#377-Combination-Sum-IV-Medium"><span class="nav-number">7.0.21.</span> <span class="nav-text">377. Combination Sum IV (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-Maximum-Product-Subarray-Medium"><span class="nav-number">7.0.22.</span> <span class="nav-text">152. Maximum Product Subarray (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#516-Longest-Palindromic-Subsequence-Medium"><span class="nav-number">7.0.23.</span> <span class="nav-text">516. Longest Palindromic Subsequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-Longest-Increasing-Subsequence-Medium"><span class="nav-number">7.0.24.</span> <span class="nav-text">300. Longest Increasing Subsequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-Longest-Common-Subsequence-Medium"><span class="nav-number">7.0.25.</span> <span class="nav-text">1143. Longest Common Subsequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1027-Longest-Arithmetic-Sequence-Medium"><span class="nav-number">7.0.26.</span> <span class="nav-text">1027. Longest Arithmetic Sequence (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">7.1.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#322-Coin-Change-Medium"><span class="nav-number">7.1.1.</span> <span class="nav-text">322. Coin Change (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#474-Ones-and-Zeroes-Medium"><span class="nav-number">7.1.2.</span> <span class="nav-text">474. Ones and Zeroes (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum-Medium"><span class="nav-number">7.1.3.</span> <span class="nav-text">416. Partition Equal Subset Sum (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Recursion-%E9%80%92%E5%BD%92-Backtracking"><span class="nav-number">8.</span> <span class="nav-text">Recursion 递归 &#x2F; Backtracking</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Roman-to-Integer-Easy"><span class="nav-number">8.0.1.</span> <span class="nav-text">13. Roman to Integer (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-Pow-x-n-Medium"><span class="nav-number">8.0.2.</span> <span class="nav-text">50. Pow(x, n) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Median-of-Two-Sorted-Arrays-Hard"><span class="nav-number">8.0.3.</span> <span class="nav-text">4. Median of Two Sorted Arrays (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-Manipulation"><span class="nav-number">9.</span> <span class="nav-text">Bit Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#231-Power-of-Two-Easy"><span class="nav-number">9.0.1.</span> <span class="nav-text">231. Power of Two (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-Divide-Two-Integers-Medium"><span class="nav-number">9.0.2.</span> <span class="nav-text">29. Divide Two Integers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89-Gray-Code-Medium"><span class="nav-number">9.0.3.</span> <span class="nav-text">89. Gray Code (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Regular-Expression"><span class="nav-number">10.</span> <span class="nav-text">Regular Expression</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#65-Valid-Number-Hard"><span class="nav-number">10.0.1.</span> <span class="nav-text">65. Valid Number (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multi-threading-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">Multi-threading 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1114-Print-in-Order-Easy"><span class="nav-number">11.0.1.</span> <span class="nav-text">1114. Print in Order (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1115-Print-FooBar-Alternately-Medium"><span class="nav-number">11.0.2.</span> <span class="nav-text">1115. Print FooBar Alternately (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1116-Print-Zero-Even-Odd-Medium"><span class="nav-number">11.0.3.</span> <span class="nav-text">1116. Print Zero Even Odd (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1117-Building-H2O-Medium"><span class="nav-number">11.0.4.</span> <span class="nav-text">1117. Building H2O (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Misc-%E6%9D%82%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%81%8F%E9%97%A8-%E7%89%B9%E6%AE%8A%E7%AE%97%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">Misc 杂类型，偏门&#x2F;特殊算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Reverse-Integer-Easy"><span class="nav-number">12.0.1.</span> <span class="nav-text">7. Reverse Integer (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-Next-Permutation-Medium"><span class="nav-number">12.0.2.</span> <span class="nav-text">31. Next Permutation (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-Permutation-Sequence-Medium"><span class="nav-number">12.0.3.</span> <span class="nav-text">60. Permutation Sequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-Product-of-Array-Except-Self-Medium"><span class="nav-number">12.0.4.</span> <span class="nav-text">238. Product of Array Except Self (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-Reverse-Linked-List-II-Medium"><span class="nav-number">12.0.5.</span> <span class="nav-text">92. Reverse Linked List II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-Largest-Rectangle-in-Histogram-Hard"><span class="nav-number">12.0.6.</span> <span class="nav-text">84. Largest Rectangle in Histogram (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-Trapping-Rain-Water-Hard"><span class="nav-number">12.0.7.</span> <span class="nav-text">42. Trapping Rain Water (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#732-My-Calendar-III-Hard"><span class="nav-number">12.0.8.</span> <span class="nav-text">732. My Calendar III (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skipped"><span class="nav-number">13.</span> <span class="nav-text">skipped</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-Union-Find"><span class="nav-number">13.1.</span> <span class="nav-text">DFS &#x2F; Union Find</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#721-Accounts-Merge-Medium"><span class="nav-number">13.1.1.</span> <span class="nav-text">721. Accounts Merge (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-Dynamic-Programming-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">13.2.</span> <span class="nav-text">DP Dynamic Programming 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III-Hard"><span class="nav-number">13.2.1.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E6%A0%B8%E5%BF%83%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">非核心题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">14.1.</span> <span class="nav-text">深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-862-Next-Closest-Time-Medium"><span class="nav-number">14.1.1.</span> <span class="nav-text">LinC 862. Next Closest Time (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">14.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#637-Average-of-Levels-in-Binary-Tree-Easy"><span class="nav-number">14.2.1.</span> <span class="nav-text">637. Average of Levels in Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#270-Closest-Binary-Search-Tree-Value-Easy-%E5%B8%A6%E9%94%81"><span class="nav-number">14.2.2.</span> <span class="nav-text">270. Closest Binary Search Tree Value (Easy) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#272-Closest-Binary-Search-Tree-Value-II-Hard-%E5%B8%A6%E9%94%81"><span class="nav-number">14.2.3.</span> <span class="nav-text">272. Closest Binary Search Tree Value II (Hard) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-Sum-of-Left-Leaves-Easy"><span class="nav-number">14.2.4.</span> <span class="nav-text">404. Sum of Left Leaves (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#653-Two-Sum-IV-Input-is-a-BST-Easy"><span class="nav-number">14.2.5.</span> <span class="nav-text">653. Two Sum IV - Input is a BST (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#655-Print-Binary-Tree-Medium"><span class="nav-number">14.2.6.</span> <span class="nav-text">655. Print Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#701-Insert-into-a-Binary-Search-Tree-Medium"><span class="nav-number">14.2.7.</span> <span class="nav-text">701. Insert into a Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#173-Binary-Search-Tree-Iterator-Medium"><span class="nav-number">14.2.8.</span> <span class="nav-text">173. Binary Search Tree Iterator (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1120-Maximum-Average-Subtree-Medium-%E5%B8%A6%E9%94%81"><span class="nav-number">14.2.9.</span> <span class="nav-text">1120. Maximum Average Subtree (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#671-Second-Minimum-Node-In-a-Binary-Tree-Easy"><span class="nav-number">14.2.10.</span> <span class="nav-text">671. Second Minimum Node In a Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#530-Minimum-Absolute-Difference-in-BST-Easy"><span class="nav-number">14.2.11.</span> <span class="nav-text">530. Minimum Absolute Difference in BST (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal-Medium"><span class="nav-number">14.2.12.</span> <span class="nav-text">1008. Construct Binary Search Tree from Preorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#987-Vertical-Order-Traversal-of-a-Binary-Tree-Medium"><span class="nav-number">14.2.13.</span> <span class="nav-text">987. Vertical Order Traversal of a Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#872-Leaf-Similar-Trees-Easy"><span class="nav-number">14.2.14.</span> <span class="nav-text">872. Leaf-Similar Trees (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#863-All-Nodes-Distance-K-in-Binary-Tree-Medium"><span class="nav-number">14.2.15.</span> <span class="nav-text">863. All Nodes Distance K in Binary Tree (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">14.3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#442-Find-All-Duplicates-in-an-Array-Medium"><span class="nav-number">14.3.1.</span> <span class="nav-text">442. Find All Duplicates in an Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#240-Search-a-2D-Matrix-II-Medium"><span class="nav-number">14.3.2.</span> <span class="nav-text">240. Search a 2D Matrix II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#986-Interval-List-Intersections-Medium"><span class="nav-number">14.3.3.</span> <span class="nav-text">986. Interval List Intersections (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap"><span class="nav-number">14.4.</span> <span class="nav-text">Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#347-Top-K-Frequent-Elements-Medium"><span class="nav-number">14.4.1.</span> <span class="nav-text">347. Top K Frequent Elements (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash"><span class="nav-number">14.5.</span> <span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#349-Intersection-of-Two-Arrays-Easy"><span class="nav-number">14.5.1.</span> <span class="nav-text">349. Intersection of Two Arrays (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#350-Intersection-of-Two-Arrays-II-Easy"><span class="nav-number">14.5.2.</span> <span class="nav-text">350. Intersection of Two Arrays II (Easy)</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-name">文章数量</span>
          <span class="site-state-item-count">4</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/alantang" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;alantang" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/alant" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;alant" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com/2019/08/13/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试刷题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-13 21:17:00" itemprop="dateCreated datePublished" datetime="2019-08-13T21:17:00+08:00">2019-08-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Binary-Tree-based-Recursion-amp-Divide-Conquer-二叉树递归与分治"><a href="#Binary-Tree-based-Recursion-amp-Divide-Conquer-二叉树递归与分治" class="headerlink" title="Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治"></a>Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治</h1><h3 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/description/">226. Invert Binary Tree (Easy)</a></h3><p>Invert a binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line">Output:</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:<br>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
<p>递归1:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>递归2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l = self.invertTree(root.left)</span><br><span class="line">        r = self.invertTree(root.right)</span><br><span class="line">        root.left, root.right = r, l</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop(-<span class="number">1</span>)</span><br><span class="line">            cur.left, cur.right = cur.right, cur.left</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>九刷：高频</p>
<h3 id="100-Same-Tree-Easy"><a href="#100-Same-Tree-Easy" class="headerlink" title="100. Same Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">100. Same Tree (Easy)</a></h3><p>Given two binary trees, write a function to check if they are the same or not.<br>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:     1         1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input:     1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> (p <span class="keyword">and</span> <span class="keyword">not</span> q) <span class="keyword">or</span> (q <span class="keyword">and</span> <span class="keyword">not</span> p) <span class="keyword">or</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = [(p, q)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            p, q = stack.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">and</span> <span class="keyword">not</span> q) <span class="keyword">or</span> (q <span class="keyword">and</span> <span class="keyword">not</span> p) <span class="keyword">or</span> p.val != q.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((p.left, q.left))</span><br><span class="line">            stack.append((p.right, q.right))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>五刷：高频</p>
<h3 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree (Easy)</a></h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">But the following [1,2,2,null,3,null,3] is not:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>
<p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<p>递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> (l <span class="keyword">and</span> <span class="keyword">not</span> r) <span class="keyword">or</span> (<span class="keyword">not</span> l <span class="keyword">and</span> r):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> l.val == r.val <span class="keyword">and</span> helper(l.left, r.right) <span class="keyword">and</span> helper(l.right, r.left)</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right)</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        q = [(root.left, root.right)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            l, r = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (l <span class="keyword">and</span> <span class="keyword">not</span> r) <span class="keyword">or</span> (r <span class="keyword">and</span> <span class="keyword">not</span> l):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (l <span class="keyword">and</span> r) <span class="keyword">and</span> (l.val != r.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.append((l.left, r.right))</span><br><span class="line">                q.append((l.right, r.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>六刷：高频</p>
<a id="more"></a>
<h3 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">104. Maximum Depth of Binary Tree (Easy)</a></h3><p>again!<br>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br>Note: A leaf is a node with no children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its depth &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p>递归1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">            helper(root.left, cur + <span class="number">1</span>)</span><br><span class="line">            helper(root.right, cur + <span class="number">1</span>)</span><br><span class="line">        helper(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        stack = [(root, <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root, cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> cur &gt; ans:</span><br><span class="line">                ans = cur</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append((root.left, cur + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append((root.right, cur + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>七刷：高频</p>
<h3 id="111-Minimum-Depth-of-Binary-Tree-Easy"><a href="#111-Minimum-Depth-of-Binary-Tree-Easy" class="headerlink" title="111. Minimum Depth of Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree (Easy)</a></h3><p>again!<br>Given a binary tree, find its minimum depth.<br>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<br>Note: A leaf is a node with no children.<br>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its minimum depth &#x3D; 2.</span><br></pre></td></tr></table></figure>
<p>递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = sys.maxsize</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, cur)</span><br><span class="line">            helper(root.left, cur + <span class="number">1</span>)</span><br><span class="line">            helper(root.right, cur + <span class="number">1</span>)</span><br><span class="line">        helper(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [(root, <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n, depth = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                q.append((n.left, depth + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                q.append((n.right, depth + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>六刷：高频</p>
<h3 id="144-Binary-Tree-Preorder-Traversal-Medium"><a href="#144-Binary-Tree-Preorder-Traversal-Medium" class="headerlink" title="144. Binary Tree Preorder Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">144. Binary Tree Preorder Traversal (Medium)</a></h3><p>again!<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<p>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<p>递归 Divide and Conquer 分治 / backtracking:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        l = self.preorderTraversal(root.left)</span><br><span class="line">        r = self.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> [root.val] + l + r</span><br></pre></td></tr></table></figure>
<p>遍历:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                ans.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    stack.append(root.right)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>递归 Traverse:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>七刷</p>
<h3 id="94-Binary-Tree-Inorder-Traversal-Medium"><a href="#94-Binary-Tree-Inorder-Traversal-Medium" class="headerlink" title="94. Binary Tree Inorder Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">94. Binary Tree Inorder Traversal (Medium)</a></h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.<br>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>
<p>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<p>递归 Traverse:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop(-<span class="number">1</span>)</span><br><span class="line">                ans.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>递归 Divide and Conquer/backtracking 分治:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        l = self.inorderTraversal(root.left)</span><br><span class="line">        r = self.inorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> l + [root.val] + r</span><br></pre></td></tr></table></figure>
<p>八刷：高频, 遍历，stack初始为空，while root or stack: if root: 向左入栈到底 else: root出栈，root.val入ans，向右走…root = <strong>root.right</strong></p>
<h3 id="230-Kth-Smallest-Element-in-a-BST-Medium"><a href="#230-Kth-Smallest-Element-in-a-BST-Medium" class="headerlink" title="230. Kth Smallest Element in a BST (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/">230. Kth Smallest Element in a BST (Medium)</a></h3><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> k, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                ans = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> root.val</span><br><span class="line">                root = root.right</span><br></pre></td></tr></table></figure>
<p>10刷：面经，Triplebyte, 维萨<br>Follow up: 二叉树经常被修改 如何优化 kthSmallest 这个操作? <a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution">leetcode官方答案</a>提出做一个类似LRU双链表的数据结构实现O(h + k)插删和查询</p>
<h3 id="129-Sum-Root-to-Leaf-Numbers-Medium"><a href="#129-Sum-Root-to-Leaf-Numbers-Medium" class="headerlink" title="129. Sum Root to Leaf Numbers (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">129. Sum Root to Leaf Numbers (Medium)</a></h3><p>again!<br>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.<br>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.<br>Find the total sum of all root-to-leaf numbers.<br>Note: A leaf is a node with no children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9   0</span><br><span class="line"> &#x2F; \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure>

<p>递归:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur += root.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                ans += cur</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left, cur * <span class="number">10</span>)</span><br><span class="line">            helper(root.right, cur * <span class="number">10</span>)</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        s = [(root, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            root, cur = s.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                cur += root.val</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    ans += cur</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                s.append((root.left, cur * <span class="number">10</span>))</span><br><span class="line">                s.append((root.right, cur * <span class="number">10</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>七刷：高频</p>
<h3 id="116-Populating-Next-Right-Pointers-in-Each-Node-Medium"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node-Medium" class="headerlink" title="116. Populating Next Right Pointers in Each Node (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node">116. Populating Next Right Pointers in Each Node (Medium)</a></h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br>Example:<br><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="Populating Next Right Pointers example"></p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.<span class="built_in">next</span> = root.right</span><br><span class="line">            <span class="keyword">if</span> root.<span class="built_in">next</span>:</span><br><span class="line">                root.right.<span class="built_in">next</span> = root.<span class="built_in">next</span>.left</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>六刷：高频，遍历允许用额外空间的话比较简单，就不写了，用O(1)额外空间的遍历写法与117题差不多</p>
<h3 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium" class="headerlink" title="117. Populating Next Right Pointers in Each Node II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii">117. Populating Next Right Pointers in Each Node II (Medium)</a></h3><p>again!<br>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br>Example:<br><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="Populating Next Right Pointers example II"><br>Note:<br>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">return</span> helper(root.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                root.left.<span class="built_in">next</span> = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.left.<span class="built_in">next</span> = helper(root.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            root.right.<span class="built_in">next</span> = helper(root.<span class="built_in">next</span>)</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = root</span><br><span class="line">        nextLevelHead = Node(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            p = nextLevelHead</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    p.<span class="built_in">next</span> = cur.left</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    p.<span class="built_in">next</span> = cur.right</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur = nextLevelHead.<span class="built_in">next</span></span><br><span class="line">            nextLevelHead.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>六刷：高频</p>
<h3 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/description/">110. Balanced Binary Tree (Easy)</a></h3><p>again!<br>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as:<br>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Given the following tree [3,9,20,null,null,15,7]:</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">Return true.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Given the following tree [1,2,2,3,3,null,null,4,4]:</span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        ans = <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = helper(root.left)</span><br><span class="line">            r = helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span>:</span><br><span class="line">                ans = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>九刷：高频。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/discuss/35708/VERY-SIMPLE-Python-solutions-(iterative-and-recursive)-both-beat-90">遍历需要用postorder</a>， 比较难，以后写，TODO</p>
<h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree">108. Convert Sorted Array to Binary Search Tree (Easy)</a></h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br>Given the sorted array: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    &#x2F; \</span><br><span class="line">  -3   9</span><br><span class="line">  &#x2F;   &#x2F;</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rIdx = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[rIdx])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:rIdx])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[rIdx + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>六刷：高频, 面经, Amazon。无他手熟尔 todo：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution">遍历方法</a></p>
<h3 id="109-Convert-Sorted-List-to-Binary-Search-Tree-Medium"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree-Medium" class="headerlink" title="109. Convert Sorted List to Binary Search Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">109. Convert Sorted List to Binary Search Tree (Medium)</a></h3><p>again!<br>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br>Given the sorted linked list: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    &#x2F; \</span><br><span class="line">  -3   9</span><br><span class="line">  &#x2F;   &#x2F;</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<p>解法1：space: O(n):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            rIdx = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[rIdx])</span><br><span class="line">            root.left = helper(nums[:rIdx])</span><br><span class="line">            root.right = helper(nums[rIdx + <span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(arr)</span><br></pre></td></tr></table></figure>
<p>解法2：space: O(1):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head: ListNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> h == t:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            s, f = h, h</span><br><span class="line">            <span class="keyword">while</span> f != t <span class="keyword">and</span> f.<span class="built_in">next</span> != t:</span><br><span class="line">                s = s.<span class="built_in">next</span></span><br><span class="line">                f = f.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            root = TreeNode(s.val)</span><br><span class="line">            root.left = helper(h, s)</span><br><span class="line">            root.right = helper(s.<span class="built_in">next</span>, t)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>五刷：高频，time complexity: O(n), O(nlogn)</p>
<h3 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/">112. Path Sum (Easy)</a></h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>Note: A leaf is a node with no children.</p>
<p>Example:<br>Given the below binary tree and sum = 22,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        ans = <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur -= root.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">if</span> cur == <span class="number">0</span>:</span><br><span class="line">                    ans =  <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left, cur)</span><br><span class="line">            helper(root.right, cur)</span><br><span class="line">        helper(root, <span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>七刷：高频，面经，Quora</p>
<h3 id="199-Binary-Tree-Right-Side-View-Medium"><a href="#199-Binary-Tree-Right-Side-View-Medium" class="headerlink" title="199. Binary Tree Right Side View (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View (Medium)</a></h3><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, depth</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> depth &gt; <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.append(root.val)</span><br><span class="line">            helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line">            helper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">        helper(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            ans.append(q[-<span class="number">1</span>].val)</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    nq.append(root.left)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    nq.append(root.right)</span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>五刷：面经, 维萨</p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="LCA of BST example"><br>Example 1:<br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p>
<p>Example 2:<br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>Output: 2<br>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<p>Note:<br>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the BST.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span> </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span> </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>10刷：注意要return f()，否则会return最顶上的root</p>
<h3 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree (Easy)</a></h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given a binary tree</span><br><span class="line">          1</span><br><span class="line">         &#x2F; \</span><br><span class="line">        2   3</span><br><span class="line">       &#x2F; \</span><br><span class="line">      4   5</span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure>
<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = helper(root.left)</span><br><span class="line">            r = helper(root.right)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l + r)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>五刷： 重点是理解题的本质是求左右子树的maxDepth，O(n) 每一步都算一下当前l+r是否大于ans</p>
<h3 id="563-Binary-Tree-Tilt-Easy"><a href="#563-Binary-Tree-Tilt-Easy" class="headerlink" title="563. Binary Tree Tilt (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-tilt">563. Binary Tree Tilt (Easy)</a></h3><p>Given a binary tree, return the tilt of the whole tree.<br>The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.<br>The tilt of the whole tree is defined as the sum of all nodes’ tilt.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">         1</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     3</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>Tilt of node 2 : 0<br>Tilt of node 3 : 0<br>Tilt of node 1 : |2-3| = 1<br>Tilt of binary tree : 0 + 0 + 1 = 1<br>Note:<br>The sum of node values in any subtree won’t exceed the range of 32-bit integer.<br>All the tilt values won’t exceed the range of 32-bit integer.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTilt</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = helper(root.left)</span><br><span class="line">            r = helper(root.right)</span><br><span class="line">            ans += <span class="built_in">abs</span>(l - r)</span><br><span class="line">            <span class="keyword">return</span> l + r + root.val</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>六刷：O(n)</p>
<h3 id="669-Trim-a-Binary-Search-Tree-Easy"><a href="#669-Trim-a-Binary-Search-Tree-Easy" class="headerlink" title="669. Trim a Binary Search Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree (Easy)</a></h3><p>Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   2</span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 2</span><br><span class="line">Output:</span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   &#x2F;</span><br><span class="line">  1</span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 3</span><br><span class="line">Output:</span><br><span class="line">      3</span><br><span class="line">     &#x2F;</span><br><span class="line">   2</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root: TreeNode, L: <span class="built_in">int</span>, R: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l = self.trimBST(root.left, L, R)</span><br><span class="line">        r = self.trimBST(root.right, L, R)</span><br><span class="line">        root.left, root.right = l, r</span><br><span class="line">        <span class="keyword">if</span> L &lt;= root.val &lt;= R:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; L:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; R:</span><br><span class="line">            <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<p>10刷：每层三种情况：1：小于最小，则返回右子树传上来的root；2：大于最大，则返回左子树传上来的root；3.大小之间，将root返回上层</p>
<h3 id="687-Longest-Univalue-Path-Medium"><a href="#687-Longest-Univalue-Path-Medium" class="headerlink" title="687. Longest Univalue Path (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-univalue-path/">687. Longest Univalue Path (Medium)</a></h3><p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.<br>The length of path between two nodes is represented by the number of edges between them.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">              5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   5</span><br><span class="line">           &#x2F; \   \</span><br><span class="line">          1   1   5</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">              1</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   5</span><br><span class="line">           &#x2F; \   \</span><br><span class="line">          4   4   5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = dfs(root.left)</span><br><span class="line">            r = dfs(root.right)</span><br><span class="line">            ll, rl = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.val == root.left.val:</span><br><span class="line">                ll = l + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">and</span> root.val == root.right.val:</span><br><span class="line">                rl = r + <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, ll + rl)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(ll, rl)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, pre</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = dfs(root.left, root)</span><br><span class="line">            r = dfs(root.right, root)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l + r)</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val == root.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dfs(root, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>15刷：写法1的关键是l, r 各自递归后ans = max(ans, l + r)。理解的重点是在当前层无法判断是否左右子节点都相等，但是因为如果有一边子节点不相等会将l或r返回为0，那么ans = max(ans, l + r)即可获得想要的答案。写法2的关键是f(root), 左右各自递归后lL = rL = 0; if …: lL = l + 1…return max(lL, rL)。</p>
<h3 id="114-Flatten-Binary-Tree-to-Linked-List-Medium"><a href="#114-Flatten-Binary-Tree-to-Linked-List-Medium" class="headerlink" title="114. Flatten Binary Tree to Linked List (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description">114. Flatten Binary Tree to Linked List (Medium)</a></h3><p>Given a binary tree, flatten it to a linked list in-place.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">For example, given the following tree:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line">The flattened tree should look like:</span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<p>解法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l = self.flatten(root.left)</span><br><span class="line">        r = self.flatten(root.right)</span><br><span class="line">        <span class="keyword">if</span> l:</span><br><span class="line">            root.right = l</span><br><span class="line">            root.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> l.right:</span><br><span class="line">                l = l.right</span><br><span class="line">            l.right = r</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>九刷：高频</p>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description">236. Lowest Common Ancestor of a Binary Tree (Medium)</a></h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    &#x2F;              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">&#x2F;      \        &#x2F;      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      &#x2F;  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure>
<p>Example 1:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of of nodes 5 and 1 is 3.</p>
<p>Example 2:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself<br>             according to the LCA definition.</p>
<p>Note:<br>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the binary tree.</p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        l = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        r = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> r:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> l:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">elif</span> r:</span><br><span class="line">            <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        parent = &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (p <span class="keyword">in</span> parent <span class="keyword">and</span> q <span class="keyword">in</span> parent):</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                parent[root.left] = root</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                parent[root.right] = root</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">        ancestors = []</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            ancestors.append(p)</span><br><span class="line">            p = parent[p]</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">            q = parent[q]</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
<p>13刷：递归：注意最后返回root需要if l and r这个条件。遍历：遍历，建立parent关系，p存入ancestors，遍历p的parent入ancestors，遍历q和q的parent，在ancestors中即返回。TODO 不需要parent关系的算法</p>
<h3 id="285-Inorder-Successor-in-BST-Medium-带锁"><a href="#285-Inorder-Successor-in-BST-Medium-带锁" class="headerlink" title="285. Inorder Successor in BST (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/inorder-successor-in-bst">285. Inorder Successor in BST (Medium) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/448/">LinC 448. Inorder Successor in BST (Medium)</a><br>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.<br>If the given node has no in-order successor in the tree, return null.<br>It’s guaranteed p is one node in the given tree. (You can directly compare the memory address to find p)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Given tree &#x3D; [2,1] and node &#x3D; 1:</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br><span class="line">return node 2.</span><br><span class="line"></span><br><span class="line">Given tree &#x3D; [2,1,3] and node &#x3D; 2:</span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br><span class="line">return node 3.</span><br></pre></td></tr></table></figure>
<p>Challenge<br>O(h), where h is the height of the BST.</p>
<p>O(h)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span>(<span class="params">self, root, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        suc = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root != p:</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; p.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                suc = root</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> suc</span><br><span class="line">        root = root.right</span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>O(n):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span>(<span class="params">self, root, p</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> pre, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> pre == p:</span><br><span class="line">                pre = <span class="literal">None</span></span><br><span class="line">                ans = root</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pre = root</span><br><span class="line">            helper(root.right)</span><br><span class="line">        pre = ans = <span class="literal">None</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>O(n)遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span>(<span class="params">self, root, p</span>):</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> pre == p:</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                pre = root</span><br><span class="line">                root = root.right</span><br></pre></td></tr></table></figure>
<p>O(n)递归2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span>(<span class="params">self, root, p</span>):</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> found, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                ans = root</span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span>  root == p:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>12刷：递归O(n)解法：注意：处理p == pre需要在递归调用左子树之后，否则pre为空；找到ans以后如果想return需要将pre = None，否则会锁定pre，导致上层的 pre == p，而将上层的root赋值到ans中。<br>O(h)解法：找p的successor，那么如果root比p小p在右子树，反之p在左子树，去左子树之前要记一下suc节点，以防找到的root.val == p.val节点无右节点（即需要返回上层的suc）。如有右节点，则返回右节点中最小的（往右走一个然后返回最左节点）</p>
<h3 id="98-Validate-Binary-Search-Tree-Medium"><a href="#98-Validate-Binary-Search-Tree-Medium" class="headerlink" title="98. Validate Binary Search Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/description/">98. Validate Binary Search Tree (Medium)</a></h3><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&#39;s value</span><br><span class="line">             is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure>
<p>高频<br>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, minV, maxV</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> root.val &lt;= minV <span class="keyword">or</span> root.val &gt;= maxV:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> helper(root.left, minV, root.val) <span class="keyword">and</span> helper(root.right, root.val, maxV)</span><br><span class="line">        <span class="keyword">return</span> helper(root, -sys.maxsize, sys.maxsize)</span><br></pre></td></tr></table></figure>
<p>inorder 中序遍历遍历无额外数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val &gt;= root.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                pre = root</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>inorder 中序遍历递归无额外数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        ans = <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> pre, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val &gt;= root.val:</span><br><span class="line">                ans = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pre = root</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>inorder 中序遍历递归额外数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        self.inOrder(root, res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(res)):</span><br><span class="line">            <span class="keyword">if</span> res[i] &lt;= res[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span>(<span class="params">self, root, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(root.left, res)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        self.inOrder(root.right, res)</span><br></pre></td></tr></table></figure>
<p>高频，七刷：五种解法：1.利用BST性质的递归，2，3.中序遍历递归（有/无额外数组），4，5.中序遍历遍历（有/无额外数组）<br>          中序遍历遍历无额外数组：…if pre and n.val &lt;= pre.val: return False; pre = n…<br>          BST性质递归：…if root.val &lt;**=** minV or root.val &gt;<strong>=</strong> maxV…</p>
<h3 id="572-Subtree-of-Another-Tree-Easy"><a href="#572-Subtree-of-Another-Tree-Easy" class="headerlink" title="572. Subtree of Another Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree (Easy)</a></h3><p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Given tree s:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">Given tree t:</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">Return true, because t has the same structure and node values with a subtree of s.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Given tree s:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line">Given tree t:</span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>
<p>again!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, s: TreeNode, t: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, t</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> (s <span class="keyword">and</span> <span class="keyword">not</span> t) <span class="keyword">or</span> (<span class="keyword">not</span> s <span class="keyword">and</span> t) <span class="keyword">or</span> (s.val != t.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> helper(s.left, t.left) <span class="keyword">and</span> helper(s.right, t.right)</span><br><span class="line">        <span class="keyword">return</span> helper(s, t) <span class="keyword">or</span> self.isSubtree(s.left, t) <span class="keyword">or</span> self.isSubtree(s.right, t)</span><br></pre></td></tr></table></figure>
<p>七刷：注意：要判断s是否为空，否则递归入口会因为s为空出错；既有内层helper的递归，又有外层isSubtree递归遍历s树</p>
<h3 id="606-Construct-String-from-Binary-Tree-Easy"><a href="#606-Construct-String-from-Binary-Tree-Easy" class="headerlink" title="606. Construct String from Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-string-from-binary-tree/">606. Construct String from Binary Tree (Easy)</a></h3><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.<br>The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: Binary tree: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">   &#x2F;</span><br><span class="line">  4</span><br><span class="line">Output: &quot;1(2(4))(3)&quot;</span><br><span class="line">Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;,</span><br><span class="line">but you need to omit all the unnecessary empty parenthesis pairs.</span><br><span class="line">And it will be &quot;1(2(4))(3)&quot;.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: Binary tree: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    2     3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line"></span><br><span class="line">Output: &quot;1(2()(4))(3)&quot;</span><br><span class="line">Explanation: Almost the same as the first example,</span><br><span class="line">except we can&#39;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.</span><br></pre></td></tr></table></figure>

<p>写法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tree2str</span>(<span class="params">self, t: TreeNode</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        l = self.tree2str(t.left)</span><br><span class="line">        r = self.tree2str(t.right)</span><br><span class="line">        <span class="keyword">if</span> r:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;t.val&#125;</span>(<span class="subst">&#123;l&#125;</span>)(<span class="subst">&#123;r&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> l:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;t.val&#125;</span>(<span class="subst">&#123;l&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;t.val&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tree2str</span>(<span class="params">self, t: TreeNode</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans += <span class="built_in">str</span>(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                ans += <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                helper(root.left)</span><br><span class="line">                ans += <span class="string">&#x27;)(&#x27;</span></span><br><span class="line">                helper(root.right)</span><br><span class="line">                ans += <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> root.left:</span><br><span class="line">                ans += <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                helper(root.left)</span><br><span class="line">                ans += <span class="string">&#x27;)&#x27;</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        helper(t)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>11刷</p>
<h3 id="297-Serialize-and-Deserialize-Binary-Tree-Hard"><a href="#297-Serialize-and-Deserialize-Binary-Tree-Hard" class="headerlink" title="297. Serialize and Deserialize Binary Tree (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree">297. Serialize and Deserialize Binary Tree (Hard)</a></h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">You may serialize the following tree:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<p>Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.<br>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<p>dfs递归 1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        l = self.serialize(root.left)</span><br><span class="line">        r = self.serialize(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(root.val) + <span class="string">&#x27;,&#x27;</span> + l + <span class="string">&#x27;,&#x27;</span> + r</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            rootV = arr.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> rootV == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(rootV))</span><br><span class="line">            root.left = dfs()</span><br><span class="line">            root.right = dfs()</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        arr = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs()</span><br></pre></td></tr></table></figure>

<p>dfs递归 2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            rootV = arr.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> rootV == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(rootV))</span><br><span class="line">            root.left = dfs()</span><br><span class="line">            root.right = dfs()</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arr = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs()</span><br></pre></td></tr></table></figure>

<p>bfs：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        q = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            root = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">                q.append(root.left)</span><br><span class="line">                q.append(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arr = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        root = TreeNode(<span class="built_in">int</span>(arr.pop(<span class="number">0</span>)))</span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> arr:</span><br><span class="line">            lV, rV = arr.pop(<span class="number">0</span>), arr.pop(<span class="number">0</span>)</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> lV != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(lV))</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> rV != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(rV))</span><br><span class="line">                q.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>dfs遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                root = stack.pop()</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data: <span class="built_in">str</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arr = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        p = root = TreeNode(arr[<span class="number">0</span>])</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                <span class="keyword">if</span> arr[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    p.left = TreeNode(<span class="built_in">int</span>(arr[i]))</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> arr[i] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    p.right = TreeNode(<span class="built_in">int</span>(arr[i]))</span><br><span class="line">                p = p.right</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>14刷</p>
<h3 id="536-Construct-Binary-Tree-from-String-Medium-带锁"><a href="#536-Construct-Binary-Tree-from-String-Medium-带锁" class="headerlink" title="536. Construct Binary Tree from String (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-string">536. Construct Binary Tree from String (Medium) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/construct-binary-tree-from-string/description">LinC 880. Construct Binary Tree from String (Medium)</a><br>You need to construct a binary tree from a string consisting of parenthesis and integers.<br>The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root’s value and a pair of parenthesis contains a child binary tree with the same structure.<br>You always start to construct the left child node of the parent first if it exists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;-4(2(3)(1))(6(5))&quot;</span><br><span class="line">Output: &#123;-4,2,6,3,1,5&#125;</span><br><span class="line">Explanation:</span><br><span class="line">The output is look like this:</span><br><span class="line">      -4</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    2    6</span><br><span class="line">   &#x2F; \   &#x2F;</span><br><span class="line">  3   1 5</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;1(-1)&quot;</span><br><span class="line">Output: &#123;1,-1&#125;</span><br><span class="line">Explanation:</span><br><span class="line">The output is look like this:</span><br><span class="line">     1</span><br><span class="line">    &#x2F;</span><br><span class="line">  -1</span><br></pre></td></tr></table></figure>
<p>Notice<br>There will only be ‘(‘, ‘)’, ‘-‘ and ‘0’ ~ ‘9’ in the input string.<br>An empty tree is represented by “” instead of “()”.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2tree</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        stack = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            cur = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">and</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;()&#x27;</span>:</span><br><span class="line">                cur += s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                root = TreeNode(<span class="built_in">int</span>(cur))</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> stack[-<span class="number">1</span>].left:</span><br><span class="line">                        stack[-<span class="number">1</span>].right = root</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack[-<span class="number">1</span>].left = root</span><br><span class="line">                stack.append(root)</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>七刷：Facebook tag，递归的方法不适合面试时写，将此较好想的方法写熟。注意：string没有pop()</p>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</a></h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        lLen = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:lLen + <span class="number">1</span>], inorder[:lLen])</span><br><span class="line">        root.right = self.buildTree(preorder[lLen + <span class="number">1</span>:], inorder[lLen + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>O(n)时间和空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        iMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            iMap[v] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">preS, preE, inS, inE</span>):</span></span><br><span class="line">            <span class="keyword">if</span> preS &gt; preE:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root = TreeNode(preorder[preS])</span><br><span class="line">            <span class="keyword">if</span> preS &lt; preE:</span><br><span class="line">                lEIIn = iMap[preorder[preS]] - <span class="number">1</span></span><br><span class="line">                lEIPre = preS + <span class="number">1</span> + lEIIn - inS</span><br><span class="line">                root.left = helper(preS + <span class="number">1</span>, lEIPre, inS, lEIIn)</span><br><span class="line">                root.right = helper(lEIPre + <span class="number">1</span>, preE, lEIIn + <span class="number">2</span>, inE)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>六刷：高频</p>
<h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]<br>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>O(n^2) time and space:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(postorder[-<span class="number">1</span>])</span><br><span class="line">        lLen = inorder.index(postorder[-<span class="number">1</span>])</span><br><span class="line">        root.left = self.buildTree(inorder[:lLen], postorder[:lLen])</span><br><span class="line">        root.right = self.buildTree(inorder[lLen + <span class="number">1</span>:], postorder[lLen:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>O(n) time and space:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        iMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            iMap[v] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">inS, inE, postS, postE</span>):</span></span><br><span class="line">            <span class="keyword">if</span> inS &gt; inE:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root = TreeNode(postorder[postE])</span><br><span class="line">            ilE = iMap[root.val] - <span class="number">1</span></span><br><span class="line">            plE = postS + ilE - inS                </span><br><span class="line">            root.left = helper(inS, ilE, postS, plE)</span><br><span class="line">            root.right = helper(ilE + <span class="number">2</span>, inE, plE + <span class="number">1</span>, postE - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>七刷: 高频</p>
<h3 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-Medium"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-Medium" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal">889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</a></h3><p>Return any binary tree that matches the given preorder and postorder traversals.<br>Values in the traversals pre and post are distinct positive integers.</p>
<p>Example 1:<br>Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]<br>Output: [1,2,3,4,5,6,7]</p>
<p>Note:<br>1 &lt;= pre.length == post.length &lt;= 30<br>pre[] and post[] are both permutations of 1, 2, …, pre.length.<br>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</p>
<p>O(n)时间和空间解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span>(<span class="params">self, pre: List[<span class="built_in">int</span>], post: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        iMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(post):</span><br><span class="line">            iMap[v] = i</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">preS, preE, postS, postE</span>):</span></span><br><span class="line">            <span class="keyword">if</span> preS &gt; preE:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root = TreeNode(pre[preS])</span><br><span class="line">            <span class="keyword">if</span> preS &lt; preE:</span><br><span class="line">                lEIPost = iMap[pre[preS + <span class="number">1</span>]]</span><br><span class="line">                lEIPre = preS + <span class="number">1</span> + lEIPost - postS</span><br><span class="line">                root.left = helper(preS + <span class="number">1</span>, lEIPre, postS, lEIPost)</span><br><span class="line">                root.right = helper(lEIPre + <span class="number">1</span>, preE, lEIPost + <span class="number">1</span>, postE - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="built_in">len</span>(pre) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(post) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>六刷：Facebook tag。需要一个insight：root in left subtree of pre show up last in left subtree of post</p>
<h3 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes-Medium"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes-Medium" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes">865. Smallest Subtree with all the Deepest Nodes (Medium)</a></h3><p>Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.<br>A node is deepest if it has the largest depth possible among any node in the entire tree.<br>The subtree of a node is that node, plus the set of all descendants of that node.<br>Return the node with the largest depth such that it contains all the deepest nodes in its subtree.</p>
<p>Example 1:<br>Input: [3,5,1,6,2,0,8,null,null,7,4]<br>Output: [2,7,4]<br>Explanation:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" alt="Smallest Subtree with all the Deepest Nodes example"><br>We return the node with value 2, colored in yellow in the diagram.<br>The nodes colored in blue are the deepest nodes of the tree.<br>The input “[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]” is a serialization of the given tree.<br>The output “[2, 7, 4]” is a serialization of the subtree rooted at the node with value 2.<br>Both the input and output have TreeNode type.</p>
<p>Note:<br>The number of nodes in the tree will be between 1 and 500.<br>The values of each node are unique.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, pre, depth</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> maxDepth, deepest</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> depth == maxDepth:</span><br><span class="line">                deepest.append(root)</span><br><span class="line">            <span class="keyword">elif</span> depth &gt; maxDepth:</span><br><span class="line">                maxDepth = depth</span><br><span class="line">                deepest = [root]</span><br><span class="line">            parent[root] = pre</span><br><span class="line">            helper(root.left, root, depth + <span class="number">1</span>)</span><br><span class="line">            helper(root.right, root, depth + <span class="number">1</span>)</span><br><span class="line">        parent = &#123;&#125;</span><br><span class="line">        deepest = []</span><br><span class="line">        maxDepth = <span class="number">0</span></span><br><span class="line">        helper(root, <span class="literal">None</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(deepest) &gt; <span class="number">1</span>:</span><br><span class="line">            deepest = <span class="built_in">set</span>([parent[n] <span class="keyword">for</span> n <span class="keyword">in</span> deepest])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(deepest)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>10刷：Facebook tag</p>
<h3 id="426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-Medium-带锁"><a href="#426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-Medium-带锁" class="headerlink" title="426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/convert-binary-search-tree-to-sorted-doubly-linked-list/description">Linc 1534. Convert Binary Search Tree to Sorted Doubly Linked List</a></p>
<p>Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.<br>Let’s take the following BST as an example, it may help you understand the problem better:<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="bstdll original bst example"><br>We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br>The figure below shows the circular doubly linked list for the BST above. The “head” symbol means the node it points to is the smallest element of the linked list.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="bstdll return dll example"><br>Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.<br>The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png" alt="bstdll return bst example"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &#123;4,2,5,1,3&#125;</span><br><span class="line">        4</span><br><span class="line">       &#x2F;  \</span><br><span class="line">      2   5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line">Output: &quot;left:1-&gt;5-&gt;4-&gt;3-&gt;2  right:1-&gt;2-&gt;3-&gt;4-&gt;5&quot;</span><br><span class="line">Explanation:</span><br><span class="line">Left: reverse output</span><br><span class="line">Right: positive sequence output</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &#123;2,1,3&#125;</span><br><span class="line">        2</span><br><span class="line">       &#x2F;  \</span><br><span class="line">      1   3</span><br><span class="line">Output: &quot;left:1-&gt;3-&gt;2  right:1-&gt;2-&gt;3&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> head, pre</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                head = root</span><br><span class="line">            <span class="keyword">if</span> pre:</span><br><span class="line">                root.left = pre</span><br><span class="line">                pre.right = root</span><br><span class="line">            pre = root</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        head.left = pre</span><br><span class="line">        pre.right = head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>四刷：Facebook tag。中序遍历可以升序遍历。连接相邻结点，需要用变量 pre 记录上一个遍历到的结点。需要变量head来指向最小（最左）的节点。在递归函数中，先判空，之后对左子结点递归调用，一直递归到最左结点。此时如果 head 为空的话，那么当前就是最左结点，赋值给 head 然后给 pre，对于之后遍历到的结点，就可以和 pre 接上</p>
<h3 id="298-Binary-Tree-Longest-Consecutive-Sequence-Medium-带锁"><a href="#298-Binary-Tree-Longest-Consecutive-Sequence-Medium-带锁" class="headerlink" title="298. Binary Tree Longest Consecutive Sequence (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence">298. Binary Tree Longest Consecutive Sequence (Medium) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/binary-tree-longest-consecutive-sequence/description">LinC 595. Binary Tree Longest Consecutive Sequence</a><br>Given a binary tree, find the length of the longest consecutive sequence path.<br>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">Output:3</span><br><span class="line">Explanation:</span><br><span class="line">Longest consecutive sequence path is 3-4-5, so return 3.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output:2</span><br><span class="line">Explanation:</span><br><span class="line">Longest consecutive sequence path is 2-3,not 3-2-1, so return 2.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, pre, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.val == pre.val + <span class="number">1</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">            helper(root.left, root, cur)</span><br><span class="line">            helper(root.right, root, cur)</span><br><span class="line">        helper(root, root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = [(root, root, <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            root, pre, cur = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> root.val == pre.val + <span class="number">1</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">            q.append((root.left, root, cur))</span><br><span class="line">            q.append((root.right, root, cur))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>五刷：Facebook tag</p>
<h3 id="897-Increasing-Order-Search-Tree-Easy"><a href="#897-Increasing-Order-Search-Tree-Easy" class="headerlink" title="897. Increasing Order Search Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/increasing-order-search-tree/">897. Increasing Order Search Tree (Easy)</a></h3><p>Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">    3    6</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> &#x2F;        &#x2F; \</span><br><span class="line">1        7   9</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9</span><br></pre></td></tr></table></figure>
<p>Note:<br>The number of nodes in the given tree will be between 1 and 100.<br>Each node will have a unique integer value from 0 to 1000.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> p</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            p.right = root</span><br><span class="line">            root.left = <span class="literal">None</span></span><br><span class="line">            p = p.right</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dummy = p = TreeNode(<span class="number">0</span>)    </span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> dummy.rightt</span><br></pre></td></tr></table></figure>
<p>7刷：Facebook tag，关键要建立p，因为在任意root，左边都被递归处理过并被p保存，第一步就可以将left切断</p>
<h2 id="Tree-based-BFS-基于树的-BFS"><a href="#Tree-based-BFS-基于树的-BFS" class="headerlink" title="Tree based BFS 基于树的 BFS"></a>Tree based BFS 基于树的 BFS</h2><h3 id="102-Binary-Tree-Level-Order-Traversal-Medium"><a href="#102-Binary-Tree-Level-Order-Traversal-Medium" class="headerlink" title="102. Binary Tree Level Order Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">102. Binary Tree Level Order Traversal (Medium)</a></h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, depth</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> depth == <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.append([root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[depth].append(root.val)</span><br><span class="line">            helper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                n = q.pop(<span class="number">0</span>)</span><br><span class="line">                cur.append(n.val)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    q.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    q.append(n.right)</span><br><span class="line">            ans.append(cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>四刷：高频</p>
<h3 id="107-Binary-Tree-Level-Order-Traversal-II-Easy"><a href="#107-Binary-Tree-Level-Order-Traversal-II-Easy" class="headerlink" title="107. Binary Tree Level Order Traversal II (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/">107. Binary Tree Level Order Traversal II (Easy)</a></h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its bottom-up level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root, depth</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> depth == <span class="built_in">len</span>(ans) :</span><br><span class="line">                ans.insert(<span class="number">0</span>, [])</span><br><span class="line">            ans[<span class="built_in">len</span>(ans) - <span class="number">1</span> - depth].append(root.val)</span><br><span class="line">            helper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">            helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = []</span><br><span class="line">            cur = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> q:</span><br><span class="line">                cur.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    nq.append(root.left)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    nq.append(root.right)</span><br><span class="line">            ans.insert(<span class="number">0</span>, cur)</span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>五刷：高频。list.insert(0, x), 也可用deque的appendleft</p>
<h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/">103. Binary Tree Zigzag Level Order Traversal (Medium)</a></h3><p><a target="_blank" rel="noopener" href="http://www.lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/">LinC 71. Binary Tree Zigzag Order Traversal</a><br>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">return its zigzag level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        zig = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> q:        </span><br><span class="line">            ans.append([root.val <span class="keyword">for</span> root <span class="keyword">in</span> q])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> zig:</span><br><span class="line">                ans[-<span class="number">1</span>].reverse()</span><br><span class="line">            zig = <span class="keyword">not</span> zig</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    nq.append(root.left)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    nq.append(root.right)</span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> ans       </span><br></pre></td></tr></table></figure>
<p>二刷：高频，递归的话可以用list.insert(0, val)来处理偶数层的reverse</p>
<h3 id="958-Check-Completeness-of-a-Binary-Tree-Medium"><a href="#958-Check-Completeness-of-a-Binary-Tree-Medium" class="headerlink" title="958. Check Completeness of a Binary Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/">958. Check Completeness of a Binary Tree (Medium)</a></h3><p>Given a binary tree, determine if it is a complete binary tree.<br>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png" alt="Check Completeness of a Binary Tree example1"><br>Input: [1,2,3,4,5,6]<br>Output: true<br>Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.</p>
<p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png" alt="Check Completeness of a Binary Tree example1"><br>Input: [1,2,3,4,5,null,7]<br>Output: false<br>Explanation: The node with value 7 isn’t as far left as possible.</p>
<p>Note:<br>The tree will have between 1 and 100 nodes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        q = [root]</span><br><span class="line">        noMore = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            root = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">and</span> noMore:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                noMore = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.append(root.left)</span><br><span class="line">                q.append(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>五刷</p>
<h1 id="Binary-Search-amp-LogN-Algorithm"><a href="#Binary-Search-amp-LogN-Algorithm" class="headerlink" title="Binary Search &amp; LogN Algorithm"></a>Binary Search &amp; LogN Algorithm</h1><p>二分法模板: start + 1 &lt; end; start + (end - start) / 2; A[mid] ==, &lt;, &gt;; A[start] A[end] ? target</p>
<h3 id="704-Binary-Search-Easy"><a href="#704-Binary-Search-Easy" class="headerlink" title="704. Binary Search (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search/description/">704. Binary Search (Easy)</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/classical-binary-search/description">lintcode’s version</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Find any position of a target number in a sorted array. Return -1 if target does not exist.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [1, 2, 2, 4, 5, 5].</span><br><span class="line"></span><br><span class="line">For target = 2, return 1 or 2.</span><br><span class="line"></span><br><span class="line">For target = 5, return 4 or 5.</span><br><span class="line"></span><br><span class="line">For target = 6, return -1.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(logn) time</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: nums: An integer array sorted in ascending order</span></span><br><span class="line"><span class="string">    @param: target: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPosition</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(nums) == <span class="number">0</span>):</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == target):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (nums[end] == target):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：背好模板，lintcode 的 test case 包含空输入数组，需要 python3 的 // 整除运算符才能过</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> <span class="keyword">or</span> (<span class="built_in">len</span>(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] != target):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, target, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, target, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (start + <span class="number">1</span> == end):</span><br><span class="line">            <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">                <span class="keyword">return</span> end</span><br><span class="line">            <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, target, start, end)</span><br></pre></td></tr></table></figure>
<p>总结：不背模板也能写。 但是写出来不如模板的优雅。如果递归调用前面不加 return 的话，还会发生不 return 的情况</p>
<h3 id="LinC-14-First-Position-of-Target-Easy"><a href="#LinC-14-First-Position-of-Target-Easy" class="headerlink" title="LinC 14. First Position of Target (Easy)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/first-position-of-target/description">LinC 14. First Position of Target (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.</span><br><span class="line"></span><br><span class="line">If the target number does not exist in the array, return -1.</span><br><span class="line"></span><br><span class="line">Have you met this question in a real interview?</span><br><span class="line">Example</span><br><span class="line">If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">If the count of numbers is bigger than 2^32, can your code work properly?</span><br></pre></td></tr></table></figure>
<p>思路：找到了不要 return，扔掉大的一半，继续找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: The integer array.</span></span><br><span class="line"><span class="string">    @param target: Target to find.</span></span><br><span class="line"><span class="string">    @return: The first position of target. Position starts from 0.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(nums) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == target):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (nums[end] == target):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：背好模板，模板 v5</p>
<h3 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-bad-version/description/">278. First Bad Version (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</span><br><span class="line"></span><br><span class="line">Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</span><br><span class="line"></span><br><span class="line">You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>
<p>思路：前面 first position of target 的变体，可以不做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        start, end = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(start)):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(end)):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：可不做</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> isBadVersion(<span class="number">1</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>, n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start + <span class="number">1</span> == end:</span><br><span class="line">            <span class="keyword">return</span> start <span class="keyword">if</span> isBadVersion(start) <span class="keyword">else</span> end</span><br><span class="line">        mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">return</span> self.helper(start, end)</span><br></pre></td></tr></table></figure>
<p>总结：递归思维更自然。二刷之前没有看模板。模板大法更普适</p>
<h3 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. Find First and Last Position of Element in Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">Your algorithm&#x27;s runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<p>思路：二分法找 Target, 两次二分法，一次找左边界，一次找右边界</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 找左边界</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l ) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[l] == target:</span><br><span class="line">            ans[<span class="number">0</span>] = l</span><br><span class="line">        <span class="keyword">elif</span> nums[r] == target:</span><br><span class="line">            ans[<span class="number">0</span>] = r</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找右边界</span></span><br><span class="line">        r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> nums[r] == target:</span><br><span class="line">            ans[<span class="number">1</span>] = r</span><br><span class="line">        <span class="keyword">elif</span> nums[l] == target:</span><br><span class="line">            ans[<span class="number">1</span>] = l</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：按今天的水平，写的时候注意 while 的终止条件是 while l + 1 &lt; r (l, r 不要重合就终止循环)。 两年多前写了稍微更简洁些的版本。可以回头再看看能不能写得出。</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">        res1 = end <span class="keyword">if</span> nums[end] == target <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        res1 = start <span class="keyword">if</span> nums[start] == target <span class="keyword">else</span> res1</span><br><span class="line">        <span class="keyword">if</span> res1 == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        start, end = res1, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">        res2 = start <span class="keyword">if</span> nums[start] == target <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        res2 = end <span class="keyword">if</span> nums[end] == target <span class="keyword">else</span> res2</span><br><span class="line">        <span class="keyword">if</span> res2 == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [res1, res1]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [res1, res2]</span><br></pre></td></tr></table></figure>
<p>总结： 凭借模板大法战胜 100% 的 python 选手。<br>高频：…if <strong>nums[mid] == target</strong>: r = <strong>mid</strong>…res1 = r … res1 = l …else res1; if res1 == -1: return [-1, -1]…res2 = l … res2 = r …else res2; if …: return [res1, res1]…</p>
<h3 id="LinC-61-Search-for-a-Range-Medium"><a href="#LinC-61-Search-for-a-Range-Medium" class="headerlink" title="LinC 61. Search for a Range (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/search-for-a-range/description">LinC 61. Search for a Range (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array of n integers, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [5, 7, 7, 8, 8, 10] and target value 8,</span><br><span class="line">return [3, 4].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(log n) time.</span><br></pre></td></tr></table></figure>
<p>思路：找一个数的第一次和最后一次出现的 index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: an integer sorted array</span></span><br><span class="line"><span class="string">    @param target: an integer to be inserted</span></span><br><span class="line"><span class="string">    @return: a list of length 2, [index1, index2]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, A, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        firstO, lastO = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [firstO, lastO]</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (A[end] == target):</span><br><span class="line">            firstO = end</span><br><span class="line">        <span class="keyword">if</span> (A[start] == target):</span><br><span class="line">            firstO = start</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt;= target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (A[start] == target):</span><br><span class="line">            lastO = start</span><br><span class="line">        <span class="keyword">if</span> (A[end] == target):</span><br><span class="line">            lastO = end</span><br><span class="line">        <span class="keyword">return</span> [firstO, lastO]</span><br></pre></td></tr></table></figure>
<p>总结：注意检查空输入！</p>
<h3 id="852-Peak-Index-in-a-Mountain-Array"><a href="#852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="852. Peak Index in a Mountain Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/">852. Peak Index in a Mountain Array</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/maximum-number-in-mountain-sequence/description">LinC 585. Maximum Number in Mountain Sequence (Medium)</a><br>Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.<br>Example<br>Given nums = [1, 2, 4, 8, 6, 3] return 8<br>Given nums = [10, 9, 8, 7], return 10</p>
<p>思路：切一刀，判断递增就扔左边，递减就扔右边， 不然就找到了中点<br>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid - <span class="number">1</span>] &lt; A[mid] &lt; A[mid + <span class="number">1</span>]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid - <span class="number">1</span>] &gt; A[mid] &gt; A[mid + <span class="number">1</span>]:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> A[start] &gt; A[end] <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>
<p>总结：二刷写法跟一刷一样，哪怕是简单的题，题要看清楚， mid min 不要拼错</p>
<h3 id="162-Find-Peak-Element-Medium"><a href="#162-Find-Peak-Element-Medium" class="headerlink" title="162. Find Peak Element (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-peak-element/description/">162. Find Peak Element (Medium)</a></h3><p>A peak element is an element that is greater than its neighbors.<br>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:<br>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.</p>
<p>Example 2:<br>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.<br>Note:<br>Your solution should be in logarithmic complexity.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid - <span class="number">1</span>] &lt; nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid - <span class="number">1</span>] &lt; nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> nums[l] &lt; nums[r] <span class="keyword">else</span> l</span><br></pre></td></tr></table></figure>
<p>面经：Quora。关键要知道切中点，如果是///向上，则顶点在右，如果/^\则找到顶点，否则顶点在左</p>
<h3 id="74-Search-a-2D-Matrix-Medium"><a href="#74-Search-a-2D-Matrix-Medium" class="headerlink" title="74. Search a 2D Matrix (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix/description/">74. Search a 2D Matrix (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</span><br><span class="line"></span><br><span class="line">Integers in each row are sorted from left to right.</span><br><span class="line">The first integer of each row is greater than the last integer of the previous row.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        startR, endR = <span class="number">0</span>, rows</span><br><span class="line">        <span class="keyword">while</span> startR + <span class="number">1</span> &lt; endR:</span><br><span class="line">            midR = startR + (endR - startR) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[midR][<span class="number">0</span>] &lt; target:</span><br><span class="line">                startR = midR</span><br><span class="line">            <span class="keyword">elif</span> matrix[midR][<span class="number">0</span>] &gt; target:</span><br><span class="line">                endR = midR</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> startR &lt; endR:</span><br><span class="line">            <span class="keyword">if</span> matrix[startR][cols] &lt; target:</span><br><span class="line">                startR = endR</span><br><span class="line">        startC, endC = <span class="number">0</span>, cols</span><br><span class="line">        <span class="keyword">while</span> startC + <span class="number">1</span> &lt; endC:</span><br><span class="line">            midC = startC + (endC - startC) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[startR][midC] &lt; target:</span><br><span class="line">                startC = midC</span><br><span class="line">            <span class="keyword">elif</span> matrix[startR][midC] &gt; target:</span><br><span class="line">                endC = midC</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> matrix[startR][startC] != target <span class="keyword">and</span> matrix[startR][endC] != target <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>高频：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rs, re = <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> rs + <span class="number">1</span> &lt; re:</span><br><span class="line">            rm = rs + (re - rs) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[rm][<span class="number">0</span>] &lt; target:</span><br><span class="line">                rs = rm</span><br><span class="line">            <span class="keyword">elif</span> matrix[rm][<span class="number">0</span>] &gt; target:</span><br><span class="line">                re = rm - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> matrix[rs][n - <span class="number">1</span>] &lt; target:</span><br><span class="line">            rs = re</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> target <span class="keyword">in</span> matrix[rs] <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>1总结：注意检查空输入<br>2总结：有两种空情况需要判断 [] 和 [[]]，击败 100% python3 选手。。。<br>高频：记住二分查找的模板：…s + 1 &lt; e…。注意判断…if <strong>matrix[rs][n - 1] &lt;</strong> target:…</p>
<h3 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/">153. Find Minimum in Rotated Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">Find the minimum element.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [3,4,5,1,2]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>思路：找 pivot，pivot &gt; 0 时返回 nums[pivot + 1]。找 pivot 时,如果 mid &lt; start, 扔 end， 如果 mid &gt; start 扔 start</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[start]):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure>
<p>总结：应改为 Easy 难度的题。<br>Follow up: 如果有重复的数? 无法保证在 Log(N) 的时间复杂度内解决 例子:[1,1,1,1,1….,1] 里藏着一个 0.最坏情况下需要把每个位置上的1都看一遍，才能找到最后一个有0 的位置. 考点:能想到这个最坏情况的例子</p>
<h3 id="33-Search-in-Rotated-Sorted-Array-Medium"><a href="#33-Search-in-Rotated-Sorted-Array-Medium" class="headerlink" title="33. Search in Rotated Sorted Array (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/">33. Search in Rotated Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return its index, otherwise return -1.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Your algorithm&#x27;s runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p>思路：第一感觉是得知道 pivot 在哪，有 pivot 一侧不能随便扔，但是更优的方法是查单调的侧是否可以扔</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[start] &lt;= target &lt;= nums[mid]:</span><br><span class="line">                    end = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target &lt;= nums[end]:</span><br><span class="line">                    start = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结： 注意 [1, 3, 5] target 为 1 这种边界条件， 判断 target 在单调这边需要加等号</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="string">&#x27;List[int]&#x27;</span>, target: <span class="string">&#x27;int&#x27;</span></span>) -&gt; &#x27;int&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="comment"># pivot 在左</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[start]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[end] :</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">                <span class="comment"># piviot 在右</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target &gt;= nums[start]:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：判断是否保留单调一边不能只看 nums[mid], 扔一侧的时候可以多扔一个 mid + 1 或 mid - 1<br>高频：…while <strong>l + 1</strong> &lt; r…if nums[mid] <strong>&lt;</strong> nums[l]: if <strong>nums[mid] &lt; target &lt;= nums[r]</strong>: …</p>
<h3 id="81-Search-in-Rotated-Sorted-Array-II-Medium"><a href="#81-Search-in-Rotated-Sorted-Array-II-Medium" class="headerlink" title="81. Search in Rotated Sorted Array II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">81. Search in Rotated Sorted Array II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return true, otherwise return false.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">Output: false</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</span><br><span class="line">Would this affect the run-time complexity? How and why?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[l] &gt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[r]:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[l] == target <span class="keyword">or</span> nums[r] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>高频：注意r = len(nums) - 1，判断nums[mid] == nums[l] 的情况下l += 1</p>
<h3 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x) (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Implement int sqrt(int x).</span><br><span class="line"></span><br><span class="line">Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</span><br><span class="line"></span><br><span class="line">Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since</span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x &lt; (mid + <span class="number">1</span>) * (mid + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> mid * mid &lt; x:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> l * l &lt;= x &lt; (l + <span class="number">1</span>) * (l + <span class="number">1</span>) <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure>
<p>高频：统一模板…l + 1 &lt; r…if mid * mid <strong>&lt;=</strong> x <strong>&lt;</strong>(mid + 1) * (mid + 1)…return l if l * l &lt;= x &lt;…</p>
<h3 id="35-Search-Insert-Position-Easy"><a href="#35-Search-Insert-Position-Easy" class="headerlink" title="35. Search Insert Position (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span><br><span class="line"></span><br><span class="line">You may assume no duplicates in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> target &lt;= nums[l]:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">if</span> target &lt;= nums[r]:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
<p>高频：…l = mid…if target &lt;= nums[l]: return l…return len(nums)</p>
<h3 id="658-Find-K-Closest-Elements-Medium"><a href="#658-Find-K-Closest-Elements-Medium" class="headerlink" title="658. Find K Closest Elements (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-k-closest-elements/description/">658. Find K Closest Elements (Medium)</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/find-k-closest-elements/description">LinC 460. Find K Closest Elements (Medium)</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,4,5], k=4, x=3</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,2,3,4,5], k=4, x=-1</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Note:</span><br><span class="line">The value k is positive and will always be smaller than the length of the sorted array.</span><br><span class="line">Length of the given array is positive and will not exceed 104</span><br><span class="line">Absolute value of elements in the array and x will not exceed 104</span><br><span class="line">UPDATE (2017/9/19):</span><br><span class="line">The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.</span><br></pre></td></tr></table></figure>
<p>三刷</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; x:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= n - <span class="number">1</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(arr[l] - x) &lt;= <span class="built_in">abs</span>(arr[r] - x):</span><br><span class="line">                res.append(arr[l])</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(arr[r])</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            res.append(arr[l])</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt;= n - <span class="number">1</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            res.append(arr[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(res)</span><br></pre></td></tr></table></figure>
<p>三刷：整理一，二刷代码。算法：1.二分法查找 target，将 l, r 指针放到正确的位置；2.左右按 diff 走 k；3.往左走到底，往右走到底…if nums[mid] **&lt;** x: l = **mid** else: r = **mid**…<br>网上还有一种很妖的O(logN)算法，破坏了模板，核心原理是l, r = 0, len(arr) - k…if abs(arr[mid] - x) &gt; abs(arr[mid + k] - x): l = mid + 1 else: r = mid; return arr[l: l + k]</p>
<h3 id="528-Random-Pick-with-Weight-Medium"><a href="#528-Random-Pick-with-Weight-Medium" class="headerlink" title="528. Random Pick with Weight (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/random-pick-with-weight/">528. Random Pick with Weight (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">You are given an array of positive integers w where w[i] describes the weight of ith index (0-indexed).</span><br><span class="line"></span><br><span class="line">We need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking the index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking the index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).</span><br><span class="line"></span><br><span class="line">More formally, the probability of picking index i is w[i] / sum(w).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1]],[]]</span><br><span class="line">Output</span><br><span class="line">[null,0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution = new Solution([1]);</span><br><span class="line">solution.pickIndex(); // return 0. Since there is only one single element on the array the only option is to return the first element.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1,3]],[],[],[],[],[]]</span><br><span class="line">Output</span><br><span class="line">[null,1,1,1,1,0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution = new Solution([1, 3]);</span><br><span class="line">solution.pickIndex(); // return 1. It&#x27;s returning the second element (index = 1) that has probability of 3/4.</span><br><span class="line">solution.pickIndex(); // return 1</span><br><span class="line">solution.pickIndex(); // return 1</span><br><span class="line">solution.pickIndex(); // return 1</span><br><span class="line">solution.pickIndex(); // return 0. It&#x27;s returning the first element (index = 0) that has probability of 1/4.</span><br><span class="line"></span><br><span class="line">Since this is a randomization problem, multiple answers are allowed so the following outputs can be considered correct :</span><br><span class="line">[null,1,1,1,1,0]</span><br><span class="line">[null,1,1,1,1,1]</span><br><span class="line">[null,1,1,1,0,0]</span><br><span class="line">[null,1,1,1,0,1]</span><br><span class="line">[null,1,0,1,0,0]</span><br><span class="line">......</span><br><span class="line">and so on.</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= w.length &lt;= 10000</span><br><span class="line">1 &lt;= w[i] &lt;= 10^5</span><br><span class="line">pickIndex will be called at most 10000 times.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w: List[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(w)):</span><br><span class="line">            w[i] += w[i - <span class="number">1</span>]</span><br><span class="line">        self.w = w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        t = random.randint(<span class="number">1</span>, self.w[-<span class="number">1</span>])</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(self.w) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.w[mid] &lt; t:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<p>1刷：高频</p>
<h3 id="981-Time-Based-Key-Value-Store-Medium"><a href="#981-Time-Based-Key-Value-Store-Medium" class="headerlink" title="981. Time Based Key-Value Store (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/time-based-key-value-store/">981. Time Based Key-Value Store (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&#x27;s value at a certain timestamp.</span><br><span class="line"></span><br><span class="line">Implement the TimeMap class:</span><br><span class="line"></span><br><span class="line">TimeMap() Initializes the object of the data structure.</span><br><span class="line">void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.</span><br><span class="line">String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &lt;= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns &quot;&quot;.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">[&quot;TimeMap&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[], [&quot;foo&quot;, &quot;bar&quot;, 1], [&quot;foo&quot;, 1], [&quot;foo&quot;, 3], [&quot;foo&quot;, &quot;bar2&quot;, 4], [&quot;foo&quot;, 4], [&quot;foo&quot;, 5]]</span><br><span class="line">Output</span><br><span class="line">[null, null, &quot;bar&quot;, &quot;bar&quot;, null, &quot;bar2&quot;, &quot;bar2&quot;]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">TimeMap timeMap = new TimeMap();</span><br><span class="line">timeMap.set(&quot;foo&quot;, &quot;bar&quot;, 1);  // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1.</span><br><span class="line">timeMap.get(&quot;foo&quot;, 1);         // return &quot;bar&quot;</span><br><span class="line">timeMap.get(&quot;foo&quot;, 3);         // return &quot;bar&quot;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &quot;bar&quot;.</span><br><span class="line">timeMap.set(&quot;foo&quot;, &quot;bar2&quot;, 4); // store the key &quot;foo&quot; and value &quot;ba2r&quot; along with timestamp = 4.</span><br><span class="line">timeMap.get(&quot;foo&quot;, 4);         // return &quot;bar2&quot;</span><br><span class="line">timeMap.get(&quot;foo&quot;, 5);         // return &quot;bar2&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= key.length, value.length &lt;= 100</span><br><span class="line">key and value consist of lowercase English letters and digits.</span><br><span class="line">1 &lt;= timestamp &lt;= 107</span><br><span class="line">All the timestamps timestamp of set are strictly increasing.</span><br><span class="line">At most 2 * 105 calls will be made to set and get.</span><br></pre></td></tr></table></figure>
<p>without bisect:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.d = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.d[key].append((timestamp, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(self.d[key]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.d[key][mid][<span class="number">0</span>] &lt;= timestamp:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> self.d[key][r][<span class="number">0</span>] &lt;= timestamp:</span><br><span class="line">            <span class="keyword">return</span> self.d[key][r][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> self.d[key][l][<span class="number">0</span>] &lt;= timestamp:</span><br><span class="line">            <span class="keyword">return</span> self.d[key][l][<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>use bisect:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.d = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.dt = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.d[key].append(value)</span><br><span class="line">        self.dt[key].append(timestamp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        i = bisect.bisect(self.dt[key], timestamp)</span><br><span class="line">        <span class="keyword">return</span> self.d[key][i - <span class="number">1</span>] <span class="keyword">if</span> i <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>1刷：高频</p>
<h1 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h1><h3 id="LinC-373-Partition-Array-by-Odd-and-Even-Easy"><a href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy" class="headerlink" title="LinC 373. Partition Array by Odd and Even (Easy)"></a><a target="_blank" rel="noopener" href="http://www.lintcode.com/problem/partition-array-by-odd-and-even/">LinC 373. Partition Array by Odd and Even (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Partition an integers array into odd number first and even number second.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [1, 2, 3, 4], return [1, 3, 2, 4]</span><br></pre></td></tr></table></figure>
<p>思路：双指针一头一尾，碰到不符合的就换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: nums: an array of integers</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nums[r] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        <span class="keyword">if</span> nums[l] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nums[r] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br></pre></td></tr></table></figure>
<p>总结：送两个测试数据进去就能写对。 最后两个 if 可以简化。</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/">26. Remove Duplicates from Sorted Array (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#x27;t matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#x27;t matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路：简单题， 慢指针只有在快指针碰到不同的值才走。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：纯热身，秒解</p>
<p>二刷</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[slow] == nums[fast]:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：虽然是容易热身题，却要思考两个问题，第一，数组需要 in place sort, 需要利用已经排好序这个条件来在 slow 往前一个以后交换 slow 和 fast 的数； 第二，返回 slow + 1 可以省一个 ans 变量<br>高频: …else: slow += 1; nums[slow], nums[fast] = nums[fast], nums[slow]; fast += 1…</p>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II-Medium"><a href="#80-Remove-Duplicates-from-Sorted-Array-II-Medium" class="headerlink" title="80. Remove Duplicates from Sorted Array II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">80. Remove Duplicates from Sorted Array II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#x27;t matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#x27;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        w = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">or</span> n != nums[w - <span class="number">2</span>]:</span><br><span class="line">                nums[w] = n</span><br><span class="line">                w += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>
<p>高频：反正两周前的代码也看不懂了，抄个简单一点的…if i &lt; 2 or n != nums[w <strong>- 2</strong>]</p>
<h3 id="28-Implement-strStr-Easy"><a href="#28-Implement-strStr-Easy" class="headerlink" title="28. Implement strStr() (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-strstr/description/">28. Implement strStr() (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Implement strStr().</span><br><span class="line"></span><br><span class="line">Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">What should we return when needle is an empty string? This is a great question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&#x27;s strstr() and Java&#x27;s indexOf().</span><br></pre></td></tr></table></figure>
<p>思路：快慢指针</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack, needle</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="built_in">len</span>(needle) - <span class="number">1</span> &lt; <span class="built_in">len</span>(haystack):</span><br><span class="line">                    <span class="keyword">if</span> needle == haystack[i: i + <span class="built_in">len</span>(needle)]:</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结: 思路是双指针没问题，实际用 python 的时候可以用 python 的性质直接取子串</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        end = <span class="built_in">len</span>(haystack) - <span class="built_in">len</span>(needle) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, end):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i + <span class="built_in">len</span>(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：注意空串的时候要返回 int 而不是 bool, needle 为空时，直接返回 0, 优化 end = len(haystack) - len(needle) + 1; if end &lt; 0: return -1; for i in range(0, end)<br>高频：考点 end = lh - ln + 1; … if haystack[i:i + ln] == needle: return i。代码能优化一点点，但是大同小异。</p>
<h3 id="283-Move-Zeroes-Easy"><a href="#283-Move-Zeroes-Easy" class="headerlink" title="283. Move Zeroes (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/description/">283. Move Zeroes (Easy)</a></h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:<br>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">while</span> nums[r] == <span class="number">0</span> <span class="keyword">and</span> r &lt; n - <span class="number">1</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：三刷出了更简洁的写法，跑测试用例的时候仍然要考虑 0 在左中右三种情况<br>高频：两个月没刷这题，导致思路僵化在一刷的l, r均从0，0开始需要考虑很多种情况的算法。三刷或者l, r从0，1开始代码就简洁很多（本质是一样的）。删掉一刷代码的复杂情况判断。 非要l，r从0，0开始，就不考虑各种情况，l，r永远前进<br>五刷：写出了也能过的代码，但是不如高频代码简洁</p>
<h3 id="125-Valid-Palindrome-Easy"><a href="#125-Valid-Palindrome-Easy" class="headerlink" title="125. Valid Palindrome (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/description/">125. Valid Palindrome (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</span><br><span class="line"></span><br><span class="line">Note: For the purpose of this problem, we define empty string as valid palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：头尾双指针， 碰头了返回 True，相同继续走，不同返回 False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[head].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[tail].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[head].lower() != s[tail].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>总结：思路简单， 但是要想到的 case 很多。考虑带标点符号，连续两个位置都是标点符号，整个字符串都是标点符合这三个情况才能写对</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        head, tail = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[head].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[tail].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[head].lower() == s[tail].lower():</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>总结：关键是知道 .isalnum() 这个 function<br>高频</p>
<h3 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome-ii/description/">680. Valid Palindrome II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: &quot;aba&quot;</span><br><span class="line">Output: True</span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;abca&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character &#x27;c&#x27;.</span><br><span class="line">Note:</span><br><span class="line">The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</span><br></pre></td></tr></table></figure>
<p>思路：目前网上看到大部分答案都以贪心算法为主，等看贪心了再刷这题。再看一眼感觉就是统计有没有 &gt; 2 单数的题，撸之</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 要么删左边，要么删右边</span></span><br><span class="line">        <span class="keyword">return</span> self.isPalindrome(s[:l] + s[l + <span class="number">1</span>:]) <span class="keyword">or</span> self.isPalindrome(s[:r] + s[r + <span class="number">1</span>:])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>总结：没那么简单，还要考虑这些情况 1.如果有 2 个 single 均不在 mid 位置；2. 去掉 single 点后的 string 仍然不是 palindrome; 3. 1 个 single，多个位置可以删除； 然后就抓狂了。 看了答案， 真他妈的妖。双指针算法。从两头走到中间，发现第一对不一样的字符之后，要么删左边的，要么删右边的。</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l &lt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isPalindrome(s[:l] + s[l + <span class="number">1</span>:]) <span class="keyword">or</span> self.isPalindrome(s[:r] + s[r + <span class="number">1</span>:])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>总结：如一刷所说，是一道比较妖的题，背熟吧</p>
<h3 id="1-Two-Sum-Easy"><a href="#1-Two-Sum-Easy" class="headerlink" title="1. Two Sum (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/description/">1. Two Sum (Easy)</a></h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        remain = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> remain:</span><br><span class="line">                <span class="keyword">return</span> [remain[n], i]</span><br><span class="line">            remain[target - n] = i</span><br></pre></td></tr></table></figure>
<p>一刷，高频，面经：维萨。简化代码， 双指针， hashmap</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted-Easy"><a href="#167-Two-Sum-II-Input-array-is-sorted-Easy" class="headerlink" title="167. Two Sum II - Input array is sorted (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">167. Two Sum II - Input array is sorted (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</span><br><span class="line"></span><br><span class="line">The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Your returned answers (both index1 and index2) are not zero-based.</span><br><span class="line">You may assume that each input would have exactly one solution and you may not use the same element twice.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure>
<p>思路：增加了 sorted 这个条件， 第一感觉是可以折半查找了。固定 index1，index2 用折半查找获得</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            start, end = index1 + <span class="number">1</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">                mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> numbers[index1] + numbers[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> [index1 + <span class="number">1</span>, mid + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> numbers[index1] + numbers[mid] &lt; target:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> numbers[index1] + numbers[start] == target:</span><br><span class="line">                <span class="keyword">return</span> [index1 + <span class="number">1</span>, start + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[index1] + numbers[end] == target:</span><br><span class="line">                <span class="keyword">return</span> [index1 + <span class="number">1</span>, end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>总结：要细心。1.题中 answers are not zero-based 2.要测两个情况 [2, 7, 19], 9 和 [5, 25, 75] 可以测出代码的问题</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            tsum = numbers[l] + numbers[r]</span><br><span class="line">            <span class="keyword">if</span> tsum == target:</span><br><span class="line">                <span class="keyword">return</span> [l + <span class="number">1</span>, r + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> tsum &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：二分法跑分不如直接双指针，可能是测试数据导致。双指针代码也简单很多</p>
<h3 id="LinC-607-Two-Sum-III-Data-structure-design-Easy"><a href="#LinC-607-Two-Sum-III-Data-structure-design-Easy" class="headerlink" title="LinC 607. Two Sum III - Data structure design (Easy)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/two-sum-iii-data-structure-design/description">LinC 607. Two Sum III - Data structure design (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Design and implement a TwoSum class. It should support the following operations: add and find.</span><br><span class="line"></span><br><span class="line">add - Add the number to an internal data structure.</span><br><span class="line">find - Find if there exists any pair of numbers which sum is equal to the value.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">add(1); add(3); add(5);</span><br><span class="line">find(4) // return true</span><br><span class="line">find(7) // return false</span><br></pre></td></tr></table></figure>
<p>思路：add 的时候把 sum 都存 dict 里面， 查的时候直接返回 dict 里面有没有 sum. 会超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span>:</span></span><br><span class="line">    keys = &#123;&#125;</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: number: An integer</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> self.keys:</span><br><span class="line">            self.keys[number] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.keys[number] = <span class="number">2</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: value: An integer</span></span><br><span class="line"><span class="string">    @return: Find if there exists any pair of numbers which sum is equal to the value.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="keyword">if</span> value - key <span class="keyword">in</span> self.keys:</span><br><span class="line">                <span class="keyword">if</span> value - key == key:</span><br><span class="line">                    <span class="keyword">if</span> self.keys[key] == <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>总结：虽然是一道容易题， 第一反应的思路会超时。 需要在 find 的时候判断能凑出答案的另一个 key 是不是已经在 keys 里了。而不是先存好 sum。 还要判断两个数相同的时候有没有存过两个数。</p>
<h3 id="15-3Sum-Medium"><a href="#15-3Sum-Medium" class="headerlink" title="15. 3Sum (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/description/">15. 3Sum (Medium)</a></h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note:<br>The solution set must not contain duplicate triplets.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>O(n^2)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] :</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                tSum = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> tSum &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> tSum &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l + <span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r - <span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>5刷：面经：维萨</p>
<h3 id="LinC-382-Triangle-Count-Medium"><a href="#LinC-382-Triangle-Count-Medium" class="headerlink" title="LinC 382. Triangle Count (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/triangle-count/description">LinC 382. Triangle Count (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given array S = [3,4,6,7], return 3. They are:</span><br><span class="line"></span><br><span class="line">[3,4,6]</span><br><span class="line">[3,6,7]</span><br><span class="line">[4,6,7]</span><br><span class="line">Given array S = [4,4,4,4], return 4. They are:</span><br><span class="line"></span><br><span class="line">[4(1),4(2),4(3)]</span><br><span class="line">[4(1),4(2),4(4)]</span><br><span class="line">[4(1),4(3),4(4)]</span><br><span class="line">[4(2),4(3),4(4)]</span><br></pre></td></tr></table></figure>
<p>思路： 判断能不能做三角形以后全排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param S: A list of integers</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleCount</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        S.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index1, longest <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">            head, tail = index1 + <span class="number">1</span>, index1 + <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> tail &lt; <span class="built_in">len</span>(S) <span class="keyword">and</span> S[head] + S[tail] &gt; longest:</span><br><span class="line">                tail += <span class="number">1</span></span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">                <span class="built_in">sum</span> += tail - head</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> S[head] + S[tail] &lt;= longest:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p>总结：看清题目，问的是有多少个这样的三角形， 返回数就行。 全排列效率比较低。 更优解是每次定下最长边， 寻找符合条件的另外两个边的数量。 双指针的解法是将 tail 推到最小不能组成三角形的位置， 退一步， 然后从 tail 到 head 的位置的都可以组， 因为他们相加只会比最长边更长。 然后将 head 进一步（缩短），tail 边加长到大于最长边的位置，新 tail 到 head 的位置又都可以组。</p>
<h3 id="16-3Sum-Closest-Medium"><a href="#16-3Sum-Closest-Medium" class="headerlink" title="16. 3Sum Closest (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/description/">16. 3Sum Closest (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            l, r = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                t = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> t == target:</span><br><span class="line">                    <span class="keyword">return</span> t</span><br><span class="line">                <span class="keyword">elif</span> t &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> ans == <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">abs</span>(t - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = t</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：将1，2刷的代码思路总结都删了，都差不多。注意这里没有mid，不是二分查找。</p>
<h3 id="LinC-31-Partition-Array-Medium"><a href="#LinC-31-Partition-Array-Medium" class="headerlink" title="LinC 31. Partition Array (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/partition-array/description">LinC 31. Partition Array (Medium)</a></h3><p>Description<br>Given an array nums of integers and an int k, partition the array (i.e move the elements in “nums”) such that:<br>All elements &lt; k are moved to the left<br>All elements &gt;= k are moved to the right<br>Return the partitioning index, i.e the first index i nums[i] &gt;= k.<br>You should do really partition in array nums instead of just counting the numbers of integers smaller than k.<br>If all elements in nums are smaller than k, then return nums.length</p>
<p>Example<br>If nums = [3,2,2,1] and k=2, a valid answer is 1.</p>
<p>Challenge<br>Can you partition the array in-place and in O(n)?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionArray</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[l] &lt; k:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[r] &gt;= k:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<p>总结：注意：1。while 的条件是 l &lt;= r 2.l &gt; r 的时候需要 break</p>
<h3 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">215. Kth Largest Element in an Array (Medium)</a></h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.<br>Example 1:<br>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p>
<p>Example 2:<br>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">qs</span>(<span class="params">l, r</span>):</span>   </span><br><span class="line">                p = random.randint(l, r)</span><br><span class="line">                nums[p], nums[r] = nums[r], nums[p]</span><br><span class="line">                i = l</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] &gt; nums[r]:</span><br><span class="line">                        nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                nums[r], nums[i] = nums[i], nums[r]</span><br><span class="line">                <span class="keyword">if</span> i == k - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                <span class="keyword">elif</span> i &lt; k - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> qs(i + <span class="number">1</span>, r)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> qs(l, i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> qs(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>3刷，由于完全抛弃另一侧，时间复杂度平均由 quick sort 的 O(nlogn) 降为 O(n) 因为输入变小了， quicksort 的输入一直是 n, 最差情况 O(n^2)<br>面经：维萨</p>
<h3 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/description/">75. Sort Colors (Medium)</a></h3><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.<br>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:<br>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l, r, i = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span> <span class="keyword">and</span> i &gt; l:</span><br><span class="line">                nums[l], nums[i] = nums[i], nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span> <span class="keyword">and</span> i &lt; r:</span><br><span class="line">                nums[i], nums[r] = nums[r], nums[i]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：in place 不数元素的话得用 l, r 和 i, 要过的话需要熟记交换的第二条件分别为 i &gt; l 和 i &lt; r, 其他情况 i 均前进<br>高频：去掉了一刷繁琐的方法。counting sort只需要count 0和1。1 pass：…while i &lt;= r:…and i &gt; l:…and i &lt; r:…<br>面经：Celo。3个数要保持两个边界l和r，和一个worker i，交换条件要加…i &gt; l…和…i &lt; r，否则会过度交换导致结果有bug</p>
<h3 id="18-4Sum-Medium"><a href="#18-4Sum-Medium" class="headerlink" title="18. 4Sum (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum/description/">18. 4Sum (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate quadruplets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下三年前的答案，不是特别直观。看了九章的答案，貌似好理解一点：去重，枚举一个数，然后用 3Sum 的做法，O(N^3)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j != i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l, r = j + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    <span class="built_in">sum</span> = nums[i] + nums[j] + nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> == target:</span><br><span class="line">                        ans.append([nums[i], nums[j], nums[l], nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：有一个自己肯定想不出的条件就是第二层循环怎么跳过：<strong>if j != i + 1 and nums[j] == nums[j - 1]: continue</strong>; 非常勉强能过 AC. 看了网上和三年前的，都是用 dict 先存 2sum，然后再 loop 两遍，用 if pair[0] &gt; j 来去重（第三个元素的 index 要大于前面两个）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nsum</span>(<span class="params">l, r, N, target, path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> &lt; N <span class="keyword">or</span> N &lt; <span class="number">2</span> <span class="keyword">or</span> N &gt; <span class="built_in">len</span>(nums) <span class="keyword">or</span> N * nums[l] &gt; target <span class="keyword">or</span> N * nums[r] &lt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    t = nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> t == target:</span><br><span class="line">                        ans.append(path + [nums[l], nums[r]])</span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l + <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r - <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> t &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == l <span class="keyword">or</span> (i &gt; l <span class="keyword">and</span> nums[i] != nums[i - <span class="number">1</span>]):</span><br><span class="line">                        nsum(i + <span class="number">1</span>, r, N - <span class="number">1</span>, target - nums[i], path + [nums[i]])</span><br><span class="line">        nums.sort()</span><br><span class="line">        nsum(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">4</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>二刷：看 leetcode ac 的流行答案， 返回递归 nsum， 递归内终结条件为解决 2sum，，注意两处去重，1.找到 target 以后，在 l &lt; r 条件下跳过所有后面与 l 相同的；2.进入 nsum 前，if i == 0 or (i &gt; 0 and nums[i - 1] != nums[i])<br>总结：很多坑，N == 2 时要注意 while l &lt; r 做二分法；N &gt; 2 时 for i in range(l, r + 1); nsum(i + 1, …); 如是高频题需要练熟<br>高频：…def nsum(l, r, N, target, path): if r - l + 1 &lt; N or N &lt; 2 or…if N == 2: while l &lt; r:…  while l &lt; r and nums[l] == nums[l + 1]:…while…l += 1; r -= 1…  for i in range(l, r + 1): if (i == l) or…: nsum(i + 1, r…)…</p>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums and a value val, remove all instances of that value in-place and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">The order of elements can be changed. It doesn&#x27;t matter what you leave beyond the new length.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#x27;t matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&#x27;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="built_in">len</span>(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = ans - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[i] != val:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[j] == val:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                ans -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：背while i <strong>&lt;=</strong> j: while i &lt;= j and … while i &lt;= j and …if i &lt; j: …</p>
<h3 id="11-Container-With-Most-Water-Medium"><a href="#11-Container-With-Most-Water-Medium" class="headerlink" title="11. Container With Most Water (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water (Medium)</a></h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="Container With Most Water example"><br>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p>Example:<br>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans, l, r = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (r - l) * <span class="built_in">min</span>(height[l], height[r]))</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频, 二刷：1.短的不能贡献更大的面积，可以移除2.其他的都需要更高的才有可能变成更大面积</p>
<h3 id="345-Reverse-Vowels-of-a-String-Easy"><a href="#345-Reverse-Vowels-of-a-String-Easy" class="headerlink" title="345. Reverse Vowels of a String (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-vowels-of-a-string/">345. Reverse Vowels of a String (Easy)</a></h3><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p>Example 1:<br>Input: “hello”<br>Output: “holle”</p>
<p>Example 2:<br>Input: “leetcode”<br>Output: “leotcede”<br>Note:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span>:</span><br><span class="line">                s = s[:i] + stack.pop() + s[i + <span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>inplace:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        arr = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> arr[l] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span> <span class="keyword">and</span> l &lt; <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> arr[r] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span> <span class="keyword">and</span> r &gt; <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; r:</span><br><span class="line">                arr[l], arr[r] = arr[r], arr[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(arr)</span><br></pre></td></tr></table></figure>
<p>面经：DJI。</p>
<h1 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h1><h3 id="695-Max-Area-of-Island-Medium"><a href="#695-Max-Area-of-Island-Medium" class="headerlink" title="695. Max Area of Island (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-area-of-island/description/">695. Max Area of Island (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty 2D array grid of 0&#x27;s and 1&#x27;s, an island is a group of 1&#x27;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</span><br><span class="line"></span><br><span class="line">Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</span><br><span class="line">Example 2:</span><br><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">Given the above grid, return 0.</span><br><span class="line">Note: The length of each dimension in the given grid does not exceed 50.</span><br></pre></td></tr></table></figure>
<p>思路：没啥太多好说的，BFS 暴力</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(self.bfs(grid, row, col), ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, grid, row, col</span>):</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append((row, col))</span><br><span class="line">        grid[row][col] = <span class="number">0</span></span><br><span class="line">        size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            row, col = q.popleft()</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row - <span class="number">1</span>, col) <span class="keyword">and</span> grid[row - <span class="number">1</span>][col] == <span class="number">1</span>:</span><br><span class="line">                q.append((row - <span class="number">1</span>, col))</span><br><span class="line">                grid[row - <span class="number">1</span>][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row + <span class="number">1</span>, col) <span class="keyword">and</span> grid[row + <span class="number">1</span>][col] == <span class="number">1</span>:</span><br><span class="line">                q.append((row + <span class="number">1</span>, col))</span><br><span class="line">                grid[row + <span class="number">1</span>][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row, col - <span class="number">1</span>) <span class="keyword">and</span> grid[row][col - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                q.append((row, col - <span class="number">1</span>))</span><br><span class="line">                grid[row][col - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row, col + <span class="number">1</span>) <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                q.append((row, col + <span class="number">1</span>))</span><br><span class="line">                grid[row][col + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, grid, row, col</span>):</span></span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; <span class="built_in">len</span>(grid) <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>总结：在上下左右走的时候注意入 q 以后立刻将该点标为 0， 以防同一个点入两次。<br>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="number">1</span>:</span><br><span class="line">                    s = <span class="number">0</span></span><br><span class="line">                    q = collections.deque()</span><br><span class="line">                    q.append((r, c))</span><br><span class="line">                    grid[r][c] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>:</span><br><span class="line">                        (rq, cq) = q.popleft()</span><br><span class="line">                        s += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> rq &gt; <span class="number">0</span> <span class="keyword">and</span> grid[rq - <span class="number">1</span>][cq] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq - <span class="number">1</span>, cq))</span><br><span class="line">                            grid[rq - <span class="number">1</span>][cq] = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">if</span> rq &lt; <span class="built_in">len</span>(grid) - <span class="number">1</span> <span class="keyword">and</span> grid[rq + <span class="number">1</span>][cq] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq + <span class="number">1</span>, cq))</span><br><span class="line">                            grid[rq + <span class="number">1</span>][cq] = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">if</span> cq &gt; <span class="number">0</span> <span class="keyword">and</span> grid[rq][cq - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq, cq - <span class="number">1</span>))</span><br><span class="line">                            grid[rq][cq - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">if</span> cq &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> grid[rq][cq + <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq, cq + <span class="number">1</span>))</span><br><span class="line">                            grid[rq][cq + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> s &gt; ans:</span><br><span class="line">                        ans = s</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：一次写完， 没有像一刷那样拆成三个函数。 各有优劣吧。注意清零的位置要在放 queue 之后立刻清零，以防同一个点如两次， lol 二刷踩同样的坑 :’(</p>
<h3 id="133-Clone-Graph-Medium"><a href="#133-Clone-Graph-Medium" class="headerlink" title="133. Clone Graph (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/clone-graph/description/">133. Clone Graph (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://assets.leetcode.com/uploads/2019/02/19/113_sample.png&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">&quot;graph example&quot;</span>/&gt;</span></span><br><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&#x27;s value is 1, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 2&#x27;s value is 2, and it has two neighbors: Node 1 and 3.</span><br><span class="line">Node 3&#x27;s value is 3, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 4&#x27;s value is 4, and it has two neighbors: Node 1 and 3.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">The number of nodes will be between 1 and 100.</span><br><span class="line">The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.</span><br><span class="line">Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.</span><br><span class="line">You must return the copy of the given node as a reference to the cloned graph.</span><br></pre></td></tr></table></figure>
<p>思路：BFS, 用一个 dict 存当前节点的邻居，如果没见过就加 dict 存 queue，queue 出来建 node，放 neighbor；概念上比较好懂，写码可能有坑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a undirected graph node</span></span><br><span class="line"><span class="comment"># class UndirectedGraphNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.neighbors = []</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param node, a undirected graph node</span></span><br><span class="line">    <span class="comment"># @return a undirected graph node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        _cloneNode = UndirectedGraphNode(node.label)</span><br><span class="line">        <span class="built_in">dict</span>[node] = _cloneNode</span><br><span class="line">        q = [node]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            new_q = []</span><br><span class="line">            <span class="keyword">for</span> _node <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> _node.neighbors:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                        _cloneNode = UndirectedGraphNode(neighbor.label)</span><br><span class="line">                        <span class="built_in">dict</span>[neighbor] = _cloneNode</span><br><span class="line">                        new_q.append(neighbor)</span><br><span class="line">                    <span class="built_in">dict</span>[_node].neighbors.append(<span class="built_in">dict</span>[neighbor])</span><br><span class="line">            q = new_q</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>[node]</span><br></pre></td></tr></table></figure>
<p>总结：思路用 dict 来存当前节点的邻居是错的，需要用 dict 存当前节点和克隆节点的映射关系。因为反正映射关系在，加邻居可以后加. 邻居是不能直接 copy 或者 = 的， 因为邻居的类型也是节点， 需要创造以后加进去。测一下，然后 debug 细一点， 要测出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>[_node].neighbors.append(<span class="built_in">dict</span>[neighbor])</span><br></pre></td></tr></table></figure>

<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, neighbors):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span>(<span class="params">self, node: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        n = Node(node.val, [])</span><br><span class="line">        <span class="keyword">if</span> node.neighbors == <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(node.neighbors) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        d[node] = n</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append(node)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> nq <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                n = Node(nq.val, [])</span><br><span class="line">                d[nq] = n</span><br><span class="line">            <span class="keyword">for</span> nn <span class="keyword">in</span> nq.neighbors:</span><br><span class="line">                <span class="keyword">if</span> nn <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    q.append(nn)</span><br><span class="line">                    n = Node(nn.val, [])</span><br><span class="line">                    d[nn] = n</span><br><span class="line">                d[nq].neighbors.append(d[nn])</span><br><span class="line">        <span class="keyword">return</span> d[node]</span><br></pre></td></tr></table></figure>
<p>总结：二刷第一遍没有想到 nn 在不在 d 里面，都要加入到克隆出来的节点的 neighbors 中去。此次击败了 100% 的内存使用，如需提高速度，可以增加一个 visited = set() 如果已经访问过就 return，可以用空间换时间</p>
<h3 id="127-Word-Ladder-Medium"><a href="#127-Word-Ladder-Medium" class="headerlink" title="127. Word Ladder (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-ladder/description/">127. Word Ladder (Medium)</a></h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:<br>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.</p>
<p>Example 1:<br>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>Output: 5<br>Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Example 2:<br>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>Output: 0<br>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p>
<p>可以输出此path：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="built_in">len</span>(beginWord) != <span class="built_in">len</span>(endWord):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [[beginWord]]</span><br><span class="line">        wordList = <span class="built_in">set</span>(wordList)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            curPath = q.pop(<span class="number">0</span>)</span><br><span class="line">            curWord = curPath[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> curWord == endWord:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(curPath)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(curWord)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> [<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>), <span class="built_in">ord</span>(<span class="string">&quot;z&quot;</span>) + <span class="number">1</span>)]:</span><br><span class="line">                    newW = curWord[:i] + c + curWord[i + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newW <span class="keyword">in</span> wordList <span class="keyword">and</span> newW <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(newW)</span><br><span class="line">                        q.append(curPath + [newW])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>精简无需输出path：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="built_in">len</span>(beginWord) != <span class="built_in">len</span>(endWord):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [(beginWord, <span class="number">1</span>)]</span><br><span class="line">        wordList = <span class="built_in">set</span>(wordList)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            word, length = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> length</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> [<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>), <span class="built_in">ord</span>(<span class="string">&quot;z&quot;</span>))]:</span><br><span class="line">                    newW = word[:i] + c + word[i + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newW <span class="keyword">in</span> wordList <span class="keyword">and</span> newW <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(newW)</span><br><span class="line">                        q.append((newW, length + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>面试：DJI<br>三刷：注意简版需要visited</p>
<h3 id="200-Number-of-Islands-Medium"><a href="#200-Number-of-Islands-Medium" class="headerlink" title="200. Number of Islands (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/description/">200. Number of Islands (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given a 2d grid map of &#x27;1&#x27;s (land) and &#x27;0&#x27;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>思路：遍历矩阵，碰到 1 就上下左右 BFS，碰到 0 跳过。BFS 访问过的标 0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    grid[r][c] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                    self.bfs(grid, r, c)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, matrix, r, c</span>):</span></span><br><span class="line">        q = [(r, c)]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r, c = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]:</span><br><span class="line">                newR = r + dr</span><br><span class="line">                newC = c + dc</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= newR &lt;= <span class="built_in">len</span>(matrix) - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= newC &lt;= <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> matrix[newR][newC] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    matrix[newR][newC] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                    q.append((newR, newC))</span><br></pre></td></tr></table></figure>
<p>面经，三刷：Amazon。对于 leetcode ac 比较重要的细节是，gird[][] = ‘0’ 这句话要在 if 里面，否则逻辑 OK 但是会 TLE</p>
<h3 id="LinC-611-Knight-Shortest-Path-Medium"><a href="#LinC-611-Knight-Shortest-Path-Medium" class="headerlink" title="LinC 611. Knight Shortest Path (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/knight-shortest-path/description">LinC 611. Knight Shortest Path (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.</span><br><span class="line">Return -1 if knight can not reached.</span><br><span class="line"></span><br><span class="line">source and destination must be empty.</span><br><span class="line">Knight can not enter the barrier.</span><br><span class="line"></span><br><span class="line">Clarification</span><br><span class="line">If the knight is at (x, y), he can get to the following positions in one step:</span><br><span class="line"></span><br><span class="line">(x + 1, y + 2)</span><br><span class="line">(x + 1, y - 2)</span><br><span class="line">(x - 1, y + 2)</span><br><span class="line">(x - 1, y - 2)</span><br><span class="line">(x + 2, y + 1)</span><br><span class="line">(x + 2, y - 1)</span><br><span class="line">(x - 2, y + 1)</span><br><span class="line">(x - 2, y - 1)</span><br><span class="line">Example</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return 2</span><br><span class="line"></span><br><span class="line">[[0,1,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return 6</span><br><span class="line"></span><br><span class="line">[[0,1,0],</span><br><span class="line"> [0,0,1],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return -1</span><br></pre></td></tr></table></figure>
<p>思路：没什么思路， 看了下答案，就是 BFS 硬来，需要检查走了某个方向以后是不是还是在棋盘内</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition for a point.</span></span><br><span class="line"><span class="string">class Point:</span></span><br><span class="line"><span class="string">    def __init__(self, a=0, b=0):</span></span><br><span class="line"><span class="string">        self.x = a</span></span><br><span class="line"><span class="string">        self.y = b</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param grid: a chessboard included 0 (false) and 1 (true)</span></span><br><span class="line"><span class="string">    @param source: a point</span></span><br><span class="line"><span class="string">    @param destination: a point</span></span><br><span class="line"><span class="string">    @return: the shortest path</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span>(<span class="params">self, grid, source, destination</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> <span class="keyword">or</span> (<span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dx = [<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>]</span><br><span class="line">        dy = [<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        q = collections.deque([source])</span><br><span class="line">        grid[source.x][source.y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            qlen = <span class="built_in">len</span>(q)</span><br><span class="line">            next_q = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(qlen):</span><br><span class="line">                pt = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> pt.x == destination.x <span class="keyword">and</span> pt.y == destination.y:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">for</span> move <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dx)):</span><br><span class="line">                    nextPt = Point(pt.x + dx[move], pt.y + dy[move])</span><br><span class="line">                    <span class="keyword">if</span> (self.isInbound(grid, nextPt) <span class="keyword">and</span> grid[nextPt.x][nextPt.y] == <span class="number">0</span>):</span><br><span class="line">                        next_q.append(nextPt)</span><br><span class="line">                        grid[nextPt.x][nextPt.y] = <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            q = next_q</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInbound</span>(<span class="params">self, grid, pt</span>):</span></span><br><span class="line">        <span class="keyword">return</span> pt.x &gt;= <span class="number">0</span> <span class="keyword">and</span> pt.x &lt; <span class="built_in">len</span>(grid) <span class="keyword">and</span> pt.y &gt;= <span class="number">0</span> <span class="keyword">and</span> pt.y &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>总结：注意 isInbound 要查的是 &gt;=0 和 &lt; len()， 其他的问题可以通过跑一个测试数据发现</p>
<h3 id="785-Is-Graph-Bipartite-Medium"><a href="#785-Is-Graph-Bipartite-Medium" class="headerlink" title="785. Is Graph Bipartite? (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-graph-bipartite/description/">785. Is Graph Bipartite? (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Given an undirected graph, return true if and only if it is bipartite.</span><br><span class="line"></span><br><span class="line">Recall that a graph is bipartite if we can split it&#x27;s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</span><br><span class="line"></span><br><span class="line">The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn&#x27;t contain any element twice.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">graph will have length in range [1, 100].</span><br><span class="line">graph[i] will contain integers in range [0, graph.length - 1].</span><br><span class="line">graph[i] will not contain i or duplicate values.</span><br><span class="line">The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</span><br></pre></td></tr></table></figure>
<p>思路：用染色的方法，可以用 DFS, BFS 给所有 node 染上两种色中的一种。1.未上色，既上色，给相邻节点上相反色 2.已上色，查是否和目前要上的色相同<br>DFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">n, color</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> color == seen[n]</span><br><span class="line">            seen[n] = color</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph[n]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(v, -color):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> dfs(i, <span class="number">1</span>) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>BFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph</span>):</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                s = [(i, <span class="number">1</span>)]</span><br><span class="line">                seen[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> s:</span><br><span class="line">                    n, color = s.pop()</span><br><span class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> graph[n]:</span><br><span class="line">                        <span class="keyword">if</span> v <span class="keyword">in</span> seen:</span><br><span class="line">                            <span class="keyword">if</span> color == seen[v]:</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            seen[v] = -color</span><br><span class="line">                            s.append((v, -color))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>二刷：DFS: …return color == seen[n]…if not dfs(v, -color): return False…return True… BFS: …seen[i] = 1; while…</p>
<h3 id="LinC-178-Graph-Valid-Tree-Medium"><a href="#LinC-178-Graph-Valid-Tree-Medium" class="headerlink" title="LinC 178. Graph Valid Tree (Medium)"></a><a target="_blank" rel="noopener" href="http://www.lintcode.com/problem/graph-valid-tree/">LinC 178. Graph Valid Tree (Medium)</a></h3><p>Leetcode 261. Graph Valid Tree 带锁</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</span><br><span class="line"></span><br><span class="line">You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</span><br><span class="line"></span><br><span class="line">Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</span><br></pre></td></tr></table></figure>
<p>思路：树的两个条件是不能有环，不能有孤儿节点。怎么实现想不太出来。看了答案，用 defaultdict(list) 放节点之间的关系， 有没有环其实不用管，因为只要确保边的数量 == n - 1, 并且 <strong>BFS</strong> 走过一遍之后访问过了所有的点，就确定没有环了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span>(<span class="params">self, n, edges</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(edges) == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(edges) != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        mapping = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            mapping[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            mapping[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.pop()</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> mapping[node]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">                    visited.add(neighbor)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(visited) == n</span><br></pre></td></tr></table></figure>
<p>总结：相当值得做的一道 BFS 题。注意 已经访问过的节点不要入 q，不然无向图的边会导致死循环</p>
<h3 id="130-Surrounded-Regions-Medium"><a href="#130-Surrounded-Regions-Medium" class="headerlink" title="130. Surrounded Regions (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given a 2D board containing &#x27;X&#x27; and &#x27;O&#x27; (the letter O), capture all regions surrounded by &#x27;X&#x27;.</span><br><span class="line"></span><br><span class="line">A region is captured by flipping all &#x27;O&#x27;s into &#x27;X&#x27;s in that surrounded region.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">After running your function, the board should be:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Surrounded regions shouldn’t be on the border, which means that any &#x27;O&#x27; on the border of the board are not flipped to &#x27;X&#x27;. Any &#x27;O&#x27; that is not on the border and it is not connected to an &#x27;O&#x27; on the border will be flipped to &#x27;X&#x27;. Two cells are connected if they are adjacent cells connected horizontally or vertically.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        rule = <span class="keyword">lambda</span> ij: <span class="number">0</span> &lt;= ij[<span class="number">0</span>] &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= ij[<span class="number">1</span>] &lt; n <span class="keyword">and</span> board[ij[<span class="number">0</span>]][ij[<span class="number">1</span>]] == <span class="string">&#x27;O&#x27;</span></span><br><span class="line">        q = <span class="built_in">list</span>(<span class="built_in">filter</span>(rule, [ij <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(m, n)) <span class="keyword">for</span> ij <span class="keyword">in</span> [(<span class="number">0</span>, k), (k, <span class="number">0</span>), (m - <span class="number">1</span>, k), (k, n - <span class="number">1</span>)]]))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            (i, j) = q.pop()</span><br><span class="line">            board[i][j] = <span class="string">&#x27;S&#x27;</span></span><br><span class="line">            q += <span class="built_in">list</span>(<span class="built_in">filter</span>(rule, [(i, j - <span class="number">1</span>), (i, j + <span class="number">1</span>), (i - <span class="number">1</span>, j), (i + <span class="number">1</span>, j)]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure>
<p>高频：需要改为q.pop(0)才是BFS，否则是DFS，但是代码风格放在BFS比较合适</p>
<h3 id="675-Cut-Off-Trees-for-Golf-Event-Hard"><a href="#675-Cut-Off-Trees-for-Golf-Event-Hard" class="headerlink" title="675. Cut Off Trees for Golf Event (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cut-off-trees-for-golf-event/">675. Cut Off Trees for Golf Event (Hard)</a></h3><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:<br>0 represents the obstacle can’t be reached.<br>1 represents the ground can be walked through.<br>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.</p>
<p>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).<br>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.<br>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,4],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [2,3,4],</span><br><span class="line"> [0,0,5],</span><br><span class="line"> [8,7,6]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutOffTree</span>(<span class="params">self, forest</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(forest), <span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">        trees = [[forest[r][c], r, c] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> forest[r][c] &gt; <span class="number">1</span>]</span><br><span class="line">        trees.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        nextR, nextC = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> h, r, c <span class="keyword">in</span> trees:</span><br><span class="line">            step = self.bfs(forest, nextR, nextC, r, c, m, n)</span><br><span class="line">            <span class="keyword">if</span> step == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                forest[r][c] = <span class="number">1</span></span><br><span class="line">                nextR, nextC = r, c</span><br><span class="line">                ans += step</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, forest, startR, startC, endR, endC, m, n</span>):</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        q = [(startR, startC)]</span><br><span class="line">        dirs = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                r, c = q.pop()</span><br><span class="line">                <span class="keyword">if</span> r == endR <span class="keyword">and</span> c == endC:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                visited.add((r, c))</span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> dirs:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= r + dr &lt;= m - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= c + dc &lt;= n - <span class="number">1</span> <span class="keyword">and</span> forest[r + dr][c + dc] != <span class="number">0</span> <span class="keyword">and</span> (r + dr, c + dc) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        nq.append((r + dr, c + dc))</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>面经：Amazon。比较不偏门的算法，可惜会TLE</p>
<h3 id="310-Minimum-Height-Trees-Medium"><a href="#310-Minimum-Height-Trees-Medium" class="headerlink" title="310. Minimum Height Trees (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-height-trees/">310. Minimum Height Trees (Medium)</a></h3><p>For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.<br>Format<br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).<br>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1 :</span><br><span class="line">Input: n &#x3D; 4, edges &#x3D; [[1, 0], [1, 2], [1, 3]]</span><br><span class="line">        0</span><br><span class="line">        |</span><br><span class="line">        1</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   3</span><br><span class="line"></span><br><span class="line">Output: [1]</span><br><span class="line"></span><br><span class="line">Example 2 :</span><br><span class="line">Input: n &#x3D; 6, edges &#x3D; [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line">     0  1  2</span><br><span class="line">      \ | &#x2F;</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5</span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure>
<p>Note:<br>According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”<br>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> edges:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        adj = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            adj[u].append(v)</span><br><span class="line">            adj[v].append(u)</span><br><span class="line">        leaves = [k <span class="keyword">for</span> k, v <span class="keyword">in</span> adj.items() <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">2</span>:</span><br><span class="line">            n -= <span class="built_in">len</span>(leaves)</span><br><span class="line">            newLeaves = []</span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> leaves:</span><br><span class="line">                v = adj[u].pop()</span><br><span class="line">                adj[v].remove(u)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(adj[v]) == <span class="number">1</span>:</span><br><span class="line">                    newLeaves.append(v)</span><br><span class="line">            leaves = newLeaves</span><br><span class="line">        <span class="keyword">return</span> leaves</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag，<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-height-trees/discuss/76055/Share-some-thoughts">leetcode 讨论区解法</a></p>
<h2 id="Topological-sorting-拓扑排序"><a href="#Topological-sorting-拓扑排序" class="headerlink" title="Topological sorting 拓扑排序"></a>Topological sorting 拓扑排序</h2><h3 id="LinC-127-Topological-Sorting-Medium"><a href="#LinC-127-Topological-Sorting-Medium" class="headerlink" title="LinC 127. Topological Sorting (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/topological-sorting/description">LinC 127. Topological Sorting (Medium)</a></h3><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p>
<p>For each directed edge A -&gt; B in graph, A must before B in the order list.<br>The first node in the order can be any node in the graph with no nodes direct to it.<br>Find any topological order for the given graph.<br>You can assume that there is at least one topological order in the graph.<br>Clarification<br><a target="_blank" rel="noopener" href="http://www.lintcode.com/help/graph">Learn more about representation of graphs</a></p>
<p>Example:<br>For graph as follow:<br><img src="/images/lintcode_127_topo_1.jpeg" alt="graph example"><br>The topological order can be:<br>[0, 1, 2, 3, 4, 5]<br>[0, 2, 3, 1, 5, 4]<br>思路：拓扑排序，算法貌似是：1.统计每个点的入度；2.将入度为 0 的点入 queue；3.从队列中 pop 点，去掉所有指向别的点的边: 相应点入度 -1；4.新入度为 0 的点入 queue</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition for a Directed graph node</span></span><br><span class="line"><span class="string">class DirectedGraphNode:</span></span><br><span class="line"><span class="string">    def __init__(self, x):</span></span><br><span class="line"><span class="string">        self.label = x</span></span><br><span class="line"><span class="string">        self.neighbors = []</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: graph: A list of Directed graph node</span></span><br><span class="line"><span class="string">    @return: Any topological order for the given graph.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topSort</span>(<span class="params">self, graph</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(graph) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        inBound = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                inBound[node] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                    inBound[neighbor] = <span class="number">0</span></span><br><span class="line">                inBound[neighbor] += <span class="number">1</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[node] == <span class="number">0</span>:</span><br><span class="line">                q.append(node)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            zNode = q.popleft()</span><br><span class="line">            ans.append(zNode)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> zNode.neighbors:</span><br><span class="line">                inBound[node] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inBound[node] == <span class="number">0</span>:</span><br><span class="line">                    q.append(node)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：顺利。但是题目没有说清楚 return 的是一个拓扑排序好的 node 的 list</p>
<h3 id="207-Course-Schedule-Medium"><a href="#207-Course-Schedule-Medium" class="headerlink" title="207. Course Schedule (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule/description/">207. Course Schedule (Medium)</a></h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.</p>
<p>Example 2:<br>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<p>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        inDegree = [<span class="number">0</span>] * numCourses</span><br><span class="line">        graph = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">            inDegree[e[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(inDegree):</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">                q.append(i)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            v1 = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                inDegree[v2] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDegree[v2] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v2)</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> inDegree:</span><br><span class="line">            <span class="keyword">if</span> d != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>总结：较值得二刷的题，发现了for i, v in enumerate(list)和for k, v in dict.items()这两种用法混淆的薄弱环节。 还有对入度和建的graph概念没有完全理解<br>面经：Cruise。…collecitons.default <strong>dict</strong>()…统计入度需要…inDegree[<strong>e[0]</strong>] += 1…被指向的vertex入度加一</p>
<h3 id="210-Course-Schedule-II-Medium"><a href="#210-Course-Schedule-II-Medium" class="headerlink" title="210. Course Schedule II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/description/">210. Course Schedule II (Medium)</a></h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.<br>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: [0,1]<br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished<br>             course 0. So the correct course order is [0,1] .</p>
<p>Example 2:<br>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3] or [0,2,1,3]<br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both<br>             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .<br>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        graph = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        indegree = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">            indegree[e[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        q = []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(indegree):</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                q.append(i)</span><br><span class="line">                ans.append(i)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            v1 = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                indegree[v2] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indegree[v2] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v2)</span><br><span class="line">                    ans.append(v2)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> <span class="built_in">len</span>(ans) == numCourses <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<p>面经：Cruise。</p>
<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS 深度优先搜索"></a>DFS 深度优先搜索</h1><h2 id="Binary-Tree-DFS-二叉树与树上的深度优先搜索"><a href="#Binary-Tree-DFS-二叉树与树上的深度优先搜索" class="headerlink" title="Binary Tree DFS 二叉树与树上的深度优先搜索"></a>Binary Tree DFS 二叉树与树上的深度优先搜索</h2><h3 id="257-Binary-Tree-Paths-Easy"><a href="#257-Binary-Tree-Paths-Easy" class="headerlink" title="257. Binary Tree Paths (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-paths/description/">257. Binary Tree Paths (Easy)</a></h3><p>Given a binary tree, return all root-to-leaf paths.<br>Note: A leaf is a node with no children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
<p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                ans.append(<span class="string">&quot;-&gt;&quot;</span>.join(cur))</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans = []</span><br><span class="line">        cur = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>8刷：注意：1.剪枝，因为cur是一个reference，递归过程中cur会变长，当前层完成返回上一级函数调用时需要将当前层加上的多余的枝减去 2.ans.append()后不要return，不然无法剪枝</p>
<h3 id="113-Path-Sum-II-Medium"><a href="#113-Path-Sum-II-Medium" class="headerlink" title="113. Path Sum II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II (Medium)</a></h3><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<br>Note: A leaf is a node with no children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given the below binary tree and sum &#x3D; 22,</span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">global</span> <span class="built_in">sum</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="built_in">sum</span>(cur) == target:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        target = <span class="built_in">sum</span></span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>9刷：高频，面经：Quora, 大疆。注意：ans.append()后面不要return，否则会丢失剪枝。TODO 用遍历再刷</p>
<h3 id="437-Path-Sum-III-Medium"><a href="#437-Path-Sum-III-Medium" class="headerlink" title="437. Path Sum III (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/">437. Path Sum III (Medium)</a></h3><p>You are given a binary tree in which each node contains an integer value.<br>Find the number of paths that sum to a given value.<br>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).<br>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<p>O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, cur</span>):</span>  </span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur += root.val</span><br><span class="line">            <span class="keyword">if</span> cur == targetSum:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            dfs(root.left, cur)</span><br><span class="line">            dfs(root.right, cur)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root, <span class="number">0</span>)</span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>DFS + Memo：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cur += root.val</span><br><span class="line">            ans += memo.get(cur - targetSum, <span class="number">0</span>)</span><br><span class="line">            memo[cur] = memo.get(cur, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            dfs(root.left, cur)</span><br><span class="line">            dfs(root.right, cur)</span><br><span class="line">            memo[cur] -= <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        memo = &#123;<span class="number">0</span> : <span class="number">1</span>&#125;</span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>6刷：面经：Quora。初始化memo为{0 : 1}的目的是当cur == sum的时候memo需要返回1因为这是一个符合条件的路径。 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-:-)/205032">leetcode讨论区有详细的讨论</a></p>
<h2 id="Combination-based-DFS-基于组合的深度优先搜索"><a href="#Combination-based-DFS-基于组合的深度优先搜索" class="headerlink" title="Combination based DFS - 基于组合的深度优先搜索"></a>Combination based DFS - 基于组合的深度优先搜索</h2><h3 id="78-Subsets-Medium"><a href="#78-Subsets-Medium" class="headerlink" title="78. Subsets (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/description/">78. Subsets (Medium)</a></h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:<br>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>7刷：高频。O(2^n)</p>
<h3 id="39-Combination-Sum-Medium"><a href="#39-Combination-Sum-Medium" class="headerlink" title="39. Combination Sum (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/description/">39. Combination Sum (Medium)</a></h3><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>The same repeated number may be chosen from candidates unlimited number of times.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(candidates)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(cur) == target:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + <span class="built_in">sum</span>(cur) &lt;= target:</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">                    dfs(i)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans = []</span><br><span class="line">        cur = []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>7刷：高频, 面经, Quora, Amazon。需要排序的原因是为了避免结果里[2,3,2], [3,2,2]这类情况的发生，结果里只能取当前或比当前大的数。时间复杂度为O(n^k)，n是candidates的数量，k是target / min(candidates)或者用target来近似（假设min是1的话），这个上限比网上一些O(n!)的说法更低</p>
<h3 id="40-Combination-Sum-II-Medium"><a href="#40-Combination-Sum-II-Medium" class="headerlink" title="40. Combination Sum II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-ii/description/">40. Combination Sum II (Medium)</a></h3><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>Each number in candidates may only be used once in the combination.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> target</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(cur) == target:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(cur) + nums[i] &lt;= target:</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">                    dfs(i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(candidates)</span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> target</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(cur) == target:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; idx <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(cur) + nums[i] &lt;= target:</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">                    dfs(i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        nums = <span class="built_in">sorted</span>(candidates)</span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>8刷：高频, 面经, amazon。o(2^n) 注意：…<strong>if i &gt; idx</strong> and nums[i] == nums[i - 1]: continue…</p>
<h3 id="216-combination-sum-iii-medium"><a href="#216-combination-sum-iii-medium" class="headerlink" title="216. combination sum iii (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iii/description/">216. combination sum iii (medium)</a></h3><p>find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.<br>note:<br>all numbers will be positive integers.<br>the solution set must not contain duplicate combinations.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example 1:</span><br><span class="line">input: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">output: [[1,2,4]]</span><br><span class="line"></span><br><span class="line">example 2:</span><br><span class="line">input: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationsum3</span>(<span class="params">self, k, n</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == k <span class="keyword">and</span> <span class="built_in">sum</span>(cur) == n:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cur) &lt; k <span class="keyword">and</span> <span class="built_in">sum</span>(cur) &lt; n:</span><br><span class="line">                    cur.append(j)</span><br><span class="line">                    dfs(j + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        dfs(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>6刷：面经</p>
<h3 id="77-combinations-medium"><a href="#77-combinations-medium" class="headerlink" title="77. combinations (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations/">77. combinations (medium)</a></h3><p>given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>example:<br>input: n = 4, k = 2<br>output:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; list[list[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == k:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, n + <span class="number">1</span>):</span><br><span class="line">                cur.append(i)</span><br><span class="line">                dfs(i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        dfs(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>4刷：面经：amazon</p>
<h3 id="131-palindrome-partitioning-medium"><a href="#131-palindrome-partitioning-medium" class="headerlink" title="131. palindrome partitioning (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning/description/">131. palindrome partitioning (medium)</a></h3><p>given a string s, partition s such that every substring of the partition is a palindrome.<br>return all possible palindrome partitioning of s.</p>
<p>example:<br>input: “aab”<br>output:<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; list[list[str]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        cur = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">len</span>(s):</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx + <span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">                w = s[idx : i]</span><br><span class="line">                <span class="keyword">if</span> w == w[::-<span class="number">1</span>]:</span><br><span class="line">                    cur.append(w)</span><br><span class="line">                    dfs(i)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>6刷：高频，o(n*(2^n))</p>
<h3 id="93-restore-ip-addresses-medium"><a href="#93-restore-ip-addresses-medium" class="headerlink" title="93. restore ip addresses (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/restore-ip-addresses/description/">93. restore ip addresses (medium)</a></h3><p>given a string containing only digits, restore it by returning all possible valid ip address combinations.</p>
<p>example:<br>input: “25525511135”<br>output: [“255.255.11.135”, “255.255.111.35”]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreipaddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; list[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        cur = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">len</span>(s) <span class="keyword">and</span> <span class="built_in">len</span>(cur) == <span class="number">4</span>:</span><br><span class="line">                ans.append(<span class="string">&quot;.&quot;</span>.join(cur))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx + <span class="number">1</span>, idx + <span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> i &lt;= <span class="built_in">len</span>(s):</span><br><span class="line">                    num = s[idx: i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">int</span>(num) &lt;= <span class="number">255</span> <span class="keyword">and</span> num == <span class="built_in">str</span>(<span class="built_in">int</span>(num)):</span><br><span class="line">                        cur.append(num)</span><br><span class="line">                        dfs(i)</span><br><span class="line">                        <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans     </span><br></pre></td></tr></table></figure>
<p>10刷：高频。注意：查idx + i是否越界，查num里是否有前缀为0。时间复杂度是一件有趣的事情，正常情况下分割字符串是o(2^n)复杂度，但是ip地址是有限的，因此这个题有个常数的时间复杂度上限</p>
<h3 id="linc-680-split-string-easy"><a href="#linc-680-split-string-easy" class="headerlink" title="linc 680. split string (easy)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/split-string/description">linc 680. split string (easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">give a string, you can choose to split the string after one character or two adjacent characters, and make the string to be composed of only one character or two characters. output all possible results.</span><br><span class="line"></span><br><span class="line">example</span><br><span class="line">given the string &quot;123&quot;</span><br><span class="line">return [[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;12&quot;,&quot;3&quot;],[&quot;1&quot;,&quot;23&quot;]]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">len</span>(s):</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> idx + i &lt;= <span class="built_in">len</span>(s):</span><br><span class="line">                    cur.append(s[idx:idx + i])</span><br><span class="line">                    dfs(idx + i)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>5刷</p>
<h3 id="90-subsets-ii-medium"><a href="#90-subsets-ii-medium" class="headerlink" title="90. subsets ii (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets-ii/description/">90. subsets ii (medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</span><br><span class="line"></span><br><span class="line">note: the solution set must not contain duplicate subsets.</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line"></span><br><span class="line">input: [1,2,2]</span><br><span class="line">output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>无额外空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetswithdup</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; list[list[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; idx <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                dfs(i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans, cur = [], [] </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>有额外空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetswithdup</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; list[list[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur.append(nums[i])</span><br><span class="line">                used[i] = true</span><br><span class="line">                dfs(i + <span class="number">1</span>)</span><br><span class="line">                used[i] = false</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        used = [false <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>8刷：高频，无额外空间的解法需要if i &gt; idx and …是因为要防止第一次就跳过重复的数字。在47题：permutations ii中因为全排列没有idx这个参数，需要用到用额外空间的写法去重</p>
<h3 id="140-Word-Break-II-Hard"><a href="#140-Word-Break-II-Hard" class="headerlink" title="140. Word Break II (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break-ii/">140. Word Break II (Hard)</a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>Output:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]<br>Example 2:</p>
<p>Input:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output:<br>[]</p>
<p>TLE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">len</span>(s):</span><br><span class="line">                ans.append(<span class="string">&#x27; &#x27;</span>.join(cur[:]))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(s)):</span><br><span class="line">                w = s[idx:i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">                    cur.append(w)</span><br><span class="line">                    dfs(i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>] </span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>AC: dfs + memo<br>写法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[idx]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">                <span class="keyword">if</span> s[idx:].startswith(w):</span><br><span class="line">                    <span class="keyword">if</span> w == s[idx:]:</span><br><span class="line">                        res.append(w)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        restW = dfs(idx + <span class="built_in">len</span>(w))</span><br><span class="line">                        <span class="keyword">for</span> item <span class="keyword">in</span> restW:</span><br><span class="line">                            res.append(w + <span class="string">&#x27; &#x27;</span> + item)</span><br><span class="line">            memo[idx] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        memo = &#123;&#125; </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[s]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">                <span class="keyword">if</span> s.startswith(w):</span><br><span class="line">                    <span class="keyword">if</span> w == s:</span><br><span class="line">                        res.append(w)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        restW = dfs(s[<span class="built_in">len</span>(w):])</span><br><span class="line">                        <span class="keyword">for</span> item <span class="keyword">in</span> restW:</span><br><span class="line">                            res.append(w + <span class="string">&#x27; &#x27;</span> + item)</span><br><span class="line">            memo[s] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        memo = &#123;&#125; </span><br><span class="line">        <span class="keyword">return</span> dfs(s)</span><br></pre></td></tr></table></figure>
<p>5刷：面经：Amazon。九章。TODO 时间空间复杂度</p>
<h2 id="Permutation-based-DFS-基于排列的深度优先搜索"><a href="#Permutation-based-DFS-基于排列的深度优先搜索" class="headerlink" title="Permutation based DFS - 基于排列的深度优先搜索"></a>Permutation based DFS - 基于排列的深度优先搜索</h2><h3 id="46-Permutations-Medium"><a href="#46-Permutations-Medium" class="headerlink" title="46. Permutations (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/description/">46. Permutations (Medium)</a></h3><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:<br>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        ans = []</span><br><span class="line">        cur = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == <span class="built_in">len</span>(nums):</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">                    dfs()</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>10刷：高频, 关键：used = [False] * len(nums); def dfs(). subset从idx开始往后扫，全排每一位都有可能放任意数字，因此要从第一位往后扫。这样就需要一个used的变量来记住哪一位已经被用过了</p>
<h3 id="47-Permutations-II-Medium"><a href="#47-Permutations-II-Medium" class="headerlink" title="47. Permutations II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/description/">47. Permutations II (Medium)</a></h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>Example:<br>Input: [1,1,2]<br>Output:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<p>写法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == n:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    cur.append(nums[i])</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    dfs()</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        used = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> nums]</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>写法2:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">nonlocal</span> counter</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == <span class="built_in">len</span>(nums):</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> counter:</span><br><span class="line">                <span class="keyword">if</span> counter[n]:</span><br><span class="line">                    cur.append(n)</span><br><span class="line">                    counter[n] -= <span class="number">1</span></span><br><span class="line">                    dfs()</span><br><span class="line">                    counter[n] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        counter = Counter(nums)</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>13刷：高频，空间复杂度O(n)。时间复杂度：O(n*n!), 因为需要n步产生一个排列，总共有n！个可能的排列</p>
<h3 id="22-Generate-Parentheses-Medium"><a href="#22-Generate-Parentheses-Medium" class="headerlink" title="22. Generate Parentheses (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/description/">22. Generate Parentheses (Medium)</a></h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:<br>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l == r == n:</span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(cur))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; n:</span><br><span class="line">                cur.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                dfs(l + <span class="number">1</span>, r)</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                cur.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                dfs(l, r + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>9刷：高频。TODO：时间复杂度分析</p>
<h3 id="51-N-Queens-Hard"><a href="#51-N-Queens-Hard" class="headerlink" title="51. N-Queens (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens/description/">51. N-Queens (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</span><br><span class="line">Given an integer n, return all distinct solutions to the n-queens puzzle.</span><br><span class="line">Each solution contains a distinct board configuration of the n-queens&#x27; placement, where &#x27;Q&#x27; and &#x27;.&#x27; both indicate a queen and an empty space respectively.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: [</span><br><span class="line"> [&quot;.Q..&quot;,  // Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</span><br></pre></td></tr></table></figure>
<p>写法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">nonlocal</span> cur, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == n:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> nC <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> nC <span class="keyword">not</span> <span class="keyword">in</span> cur <span class="keyword">and</span> <span class="built_in">len</span>(cur) + nC <span class="keyword">not</span> <span class="keyword">in</span> [r + c <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(cur)] <span class="keyword">and</span> <span class="built_in">len</span>(cur) - nC <span class="keyword">not</span> <span class="keyword">in</span> [r - c <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(cur)]:</span><br><span class="line">                    cur.append(nC)</span><br><span class="line">                    dfs()</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> [[<span class="string">&#x27;.&#x27;</span> * i + <span class="string">&#x27;Q&#x27;</span> + <span class="string">&#x27;.&#x27;</span> * (n - i - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> b] <span class="keyword">for</span> b <span class="keyword">in</span> ans]</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>():</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == n:</span><br><span class="line">                ans.append([<span class="string">&quot;.&quot;</span> * i + <span class="string">&quot;Q&quot;</span> + <span class="string">&quot;.&quot;</span> * (n - i - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> cur])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> nC <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> nC <span class="keyword">not</span> <span class="keyword">in</span> cur <span class="keyword">and</span> legal(nC):</span><br><span class="line">                    cur.append(nC)</span><br><span class="line">                    dfs()</span><br><span class="line">                    <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">legal</span>(<span class="params">nC</span>):</span></span><br><span class="line">            nR = <span class="built_in">len</span>(cur)</span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(cur):</span><br><span class="line">                <span class="keyword">if</span> nR + nC == r + c <span class="keyword">or</span> nR - nC == r - c:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>6刷：高频。检查下一行的某列的合法性：举个栗子就能看出来，检查列就看此列是否已在cur中（皇后已在此列），检查/方向的对角线是坐标相加，检查\方向的对角线是坐标相减，行递增无需检查。时间：O(n^3)， 空间：O(n)。因为c (count) 是row，v（value）是column, 正常 for c, v in enuerate() 就写成 for r, c in enumerate()</p>
<h2 id="Graph-based-DFS-基于图的深度优先搜索"><a href="#Graph-based-DFS-基于图的深度优先搜索" class="headerlink" title="Graph based DFS 基于图的深度优先搜索"></a>Graph based DFS 基于图的深度优先搜索</h2><h3 id="17-Letter-Combinations-of-a-Phone-Number-Medium"><a href="#17-Letter-Combinations-of-a-Phone-Number-Medium" class="headerlink" title="17. Letter Combinations of a Phone Number (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">17. Letter Combinations of a Phone Number (Medium)</a></h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br><img src="/images/leetcode_17_lett_1.png" alt="keypad example"><br>Example:<br>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        kB = &#123;<span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>, <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cur) == <span class="built_in">len</span>(digits):</span><br><span class="line">                ans.append(<span class="string">&quot;&quot;</span>.join(cur))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> kB[digits[idx]]:</span><br><span class="line">                cur.append(c)</span><br><span class="line">                dfs(idx + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">del</span> cur[-<span class="number">1</span>]</span><br><span class="line">        cur, ans = [], []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>7刷：高频</p>
<h3 id="79-Word-Search-Medium"><a href="#79-Word-Search-Medium" class="headerlink" title="79. Word Search (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-search/description/">79. Word Search (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a 2D board and a word, find if the word exists in the grid.</span><br><span class="line"></span><br><span class="line">The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],</span><br><span class="line">  [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],</span><br><span class="line">  [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">r, c, i</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(word):</span><br><span class="line">                ans = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">and</span> <span class="number">0</span> &lt;= r &lt;= m - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt;= n - <span class="number">1</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(word) <span class="keyword">and</span> word[i] == board[r][c]:</span><br><span class="line">                tmp = board[r][c]</span><br><span class="line">                board[r][c] = <span class="string">&#x27;/&#x27;</span></span><br><span class="line">                <span class="keyword">for</span> rD, cD <span class="keyword">in</span> [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                    dfs(r + rD, c + cD, i + <span class="number">1</span>)</span><br><span class="line">                board[r][c] = tmp</span><br><span class="line">        m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="literal">False</span></span><br><span class="line">        [dfs(r, c, <span class="number">0</span>) <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> <span class="keyword">not</span> ans]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>8刷：高频。这题的难点在于，递归函数内各方向的循环内不要做任何判断，判断需在循环外，这样才能走到len(word)的位置。而且由于r, c均可能出界，判断[idx] == [r][c]之前要先判断r，c是否出界</p>
<h3 id="490-The-Maze-Medium-带锁"><a href="#490-The-Maze-Medium-带锁" class="headerlink" title="490. The Maze (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/the-maze">490. The Maze (Medium) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/the-maze/description">Lintcode 787. The Maze</a><br>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p>Example 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input 1: a maze represented by a 2D array</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 1 0</span><br><span class="line">1 1 0 1 1</span><br><span class="line">0 0 0 0 0</span><br><span class="line">Input 2: start coordinate (rowStart, colStart) &#x3D; (0, 4)</span><br><span class="line">Input 3: destination coordinate (rowDest, colDest) &#x3D; (4, 4)</span><br><span class="line"></span><br><span class="line">Output: true</span><br><span class="line">Explanation: One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.com/static/images/problemset/maze_1_example_1.png" alt="the maze example 1"></p>
<p>Example 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input 1: a maze represented by a 2D array</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 1 0</span><br><span class="line">1 1 0 1 1</span><br><span class="line">0 0 0 0 0</span><br><span class="line">Input 2: start coordinate (rowStart, colStart) &#x3D; (0, 4)</span><br><span class="line">Input 3: destination coordinate (rowDest, colDest) &#x3D; (3, 2)</span><br><span class="line"></span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way for the ball to stop at the destination.</span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.com/static/images/problemset/maze_1_example_2.png" alt="the maze example 2"></p>
<p>Note:<br>1.There is only one ball and one destination in the maze.<br>2.Both the ball and the destination exist on an empty space, and they will not be at the same position initially.<br>3.The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.<br>4.The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param maze: the maze</span></span><br><span class="line"><span class="string">    @param start: the start</span></span><br><span class="line"><span class="string">    @param destination: the destination</span></span><br><span class="line"><span class="string">    @return: whether the ball could stop at the destination</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span>(<span class="params">self, maze, start, destination</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">r, c</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> [r, c] == destination:</span><br><span class="line">                ans = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">                <span class="keyword">for</span> rd, cd <span class="keyword">in</span> [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                    nR, nC = r, c</span><br><span class="line">                    <span class="keyword">while</span> <span class="number">0</span> &lt;= nR + rd &lt;= <span class="built_in">len</span>(maze) - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= nC + cd &lt;= <span class="built_in">len</span>(maze[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> maze[nR + rd][nC + cd] != <span class="number">1</span>:</span><br><span class="line">                        nR += rd</span><br><span class="line">                        nC += cd</span><br><span class="line">                    <span class="keyword">if</span> maze[nR][nC] != <span class="number">2</span>:</span><br><span class="line">                        maze[nR][nC] = <span class="number">2</span></span><br><span class="line">                        dfs(nR, nC)</span><br><span class="line">        ans = <span class="literal">False</span></span><br><span class="line">        dfs(start[<span class="number">0</span>], start[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>7刷：面经：Amazon。TODO: BFS。确保不往回滚的关键是把滚到的终点标记为2，再往各可能方向滚好以后递归之前查看此点是否来过（为2)。for循环内要用nR, nC = r, c保存当前滚到的位置，才能四个方向都滚到</p>
<h3 id="417-Pacific-Atlantic-Water-Flow-Medium"><a href="#417-Pacific-Atlantic-Water-Flow-Medium" class="headerlink" title="417. Pacific Atlantic Water Flow (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow (Medium)</a></h3><p>Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.<br>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.<br>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p>Note:<br>The order of returned grid coordinates does not matter.<br>Both m and n are less than 150.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given the following 5x5 matrix:</span><br><span class="line">  Pacific ~   ~   ~   ~   ~</span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line">Return:</span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        reach_p = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        reach_a = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">r, c, reach</span>):</span></span><br><span class="line">            reach[r][c] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> rd, cd <span class="keyword">in</span> [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]:</span><br><span class="line">                nr, nc = r + rd, c + cd</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt;= m - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt;= n - <span class="number">1</span> <span class="keyword">and</span> matrix[nr][nc] &gt;= matrix[r][c] <span class="keyword">and</span> <span class="keyword">not</span> reach[nr][nc]:</span><br><span class="line">                    dfs(nr, nc, reach)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dfs(r, <span class="number">0</span>, reach_p)</span><br><span class="line">            dfs(r, n - <span class="number">1</span>, reach_a)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dfs(<span class="number">0</span>, c, reach_p)</span><br><span class="line">            dfs(m - <span class="number">1</span>, c, reach_a)</span><br><span class="line">        <span class="keyword">return</span> [[r, c] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> reach_p[r][c] == <span class="literal">True</span> <span class="keyword">and</span> reach_a[r][c] == <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>
<p>三刷：面经：Cruise Automation。dfs：从两个海接触的四条边上的点为起点往内陆灌，返回两个海都能灌到的点坐标 TODO bfs</p>
<h3 id="399-Evaluate-Division-Medium"><a href="#399-Evaluate-Division-Medium" class="headerlink" title="399. Evaluate Division (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-division/">399. Evaluate Division (Medium)</a></h3><p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.</p>
<p>Example:<br>Given a / b = 2.0, b / c = 3.0.<br>queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .<br>return [6.0, 0.5, -1.0, 1.0, -1.0 ].</p>
<p>The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.</p>
<p>According to the example above:<br>equations = [ [“a”, “b”], [“b”, “c”] ],<br>values = [2.0, 3.0],<br>queries = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].</p>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<p>DFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span>(<span class="params">self, equations: List[List[<span class="built_in">str</span>]], values: List[<span class="built_in">float</span>], queries: List[List[<span class="built_in">str</span>]]</span>) -&gt; List[float]:</span></span><br><span class="line">        d = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> [s, e], v <span class="keyword">in</span> <span class="built_in">zip</span>(equations, values):</span><br><span class="line">            d[s].append((e, v))</span><br><span class="line">            d[e].append((s, <span class="number">1.0</span> / v))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s, e, cur</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> s == e <span class="keyword">and</span> s <span class="keyword">in</span> d:</span><br><span class="line">                res = cur</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> d <span class="keyword">and</span> s <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add(s)</span><br><span class="line">                <span class="keyword">for</span> nS, w <span class="keyword">in</span> d[s]:</span><br><span class="line">                    dfs(nS, e, cur * w)</span><br><span class="line">                visited.remove(s)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> [s, e] <span class="keyword">in</span> queries:</span><br><span class="line">            res = -<span class="number">1.0</span></span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line">            dfs(s, e, <span class="number">1.0</span>)</span><br><span class="line">            ans.append(res)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>BFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span>(<span class="params">self, equations: List[List[<span class="built_in">str</span>]], values: List[<span class="built_in">float</span>], queries: List[List[<span class="built_in">str</span>]]</span>) -&gt; List[float]:</span></span><br><span class="line">        hMap = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> [s, e], v <span class="keyword">in</span> <span class="built_in">zip</span>(equations, values):</span><br><span class="line">            hMap[s].append((e, v))</span><br><span class="line">            hMap[e].append((s, <span class="number">1.0</span> / v))</span><br><span class="line">        ans = [-<span class="number">1.0</span>] * <span class="built_in">len</span>(queries)</span><br><span class="line">        <span class="keyword">for</span> i, [s, e] <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> hMap:</span><br><span class="line">                q = [(s, <span class="number">1.0</span>)]</span><br><span class="line">                visited = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">while</span> q:</span><br><span class="line">                    (c, v) = q.pop(<span class="number">0</span>)</span><br><span class="line">                    visited.add(c)</span><br><span class="line">                    <span class="keyword">if</span> c == e:</span><br><span class="line">                        ans[i] = v</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> c <span class="keyword">in</span> hMap:</span><br><span class="line">                        <span class="keyword">for</span> (n, w) <span class="keyword">in</span> hMap[c]:</span><br><span class="line">                            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                                q.append((n, v * w))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>7刷：面经：头条。Currency Calculator一种题，先build graph，再用BFS寻最短路径的乘积</p>
<h3 id="332-Reconstruct-Itinerary-Medium"><a href="#332-Reconstruct-Itinerary-Medium" class="headerlink" title="332. Reconstruct Itinerary (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reconstruct-itinerary/">332. Reconstruct Itinerary (Medium)</a></h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:<br>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.</p>
<p>Example 1:<br>Input: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>Output: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</p>
<p>Example 2:<br>Input: [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>Output: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>Explanation: Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”].<br>             But it is larger in lexical order.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span>(<span class="params">self, tickets: List[List[<span class="built_in">str</span>]]</span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        flights = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tickets:</span><br><span class="line">            flights[t[<span class="number">0</span>]].append(t[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> flights:</span><br><span class="line">            flights[k].sort()</span><br><span class="line">        ans = [<span class="string">&quot;JFK&quot;</span>]</span><br><span class="line">        self.dfs(<span class="string">&quot;JFK&quot;</span>, flights, ans, <span class="built_in">len</span>(tickets))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, departure, flights, path, numTix</span>):</span></span><br><span class="line">        <span class="keyword">if</span> departure <span class="keyword">not</span> <span class="keyword">in</span> flights:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arrival = flights[departure]</span><br><span class="line">        <span class="keyword">for</span> i, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(arrival):</span><br><span class="line">            path.append(a)</span><br><span class="line">            <span class="keyword">del</span> arrival[i]</span><br><span class="line">            self.dfs(a, flights, path, numTix)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == numTix + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            arrival.insert(i, a)</span><br><span class="line">            <span class="keyword">del</span> path[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>一刷：这个if len(path) == numTix + 1必须在递归调用后面来查看是否已满足需求，即不剪枝 todo：没有100%的理解</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><h3 id="LinC-6-Merge-Two-Sorted-Arrays-Easy"><a href="#LinC-6-Merge-Two-Sorted-Arrays-Easy" class="headerlink" title="LinC 6. Merge Two Sorted Arrays (Easy)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/merge-two-sorted-arrays/description">LinC 6. Merge Two Sorted Arrays (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Merge two given sorted integer array A and B into a new sorted integer array.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">A=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">B=[2,4,5,6]</span><br><span class="line"></span><br><span class="line">return [1,2,2,3,4,4,5,6]</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">How can you optimize your algorithm if one array is very large and the other is very small?</span><br></pre></td></tr></table></figure>
<p>思路：热身题，直接做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: sorted integer array A</span></span><br><span class="line"><span class="string">    @param B: sorted integer array B</span></span><br><span class="line"><span class="string">    @return: A new sorted integer array</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSortedArray</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        ans = []</span><br><span class="line">        indexA = <span class="number">0</span></span><br><span class="line">        indexB = <span class="number">0</span></span><br><span class="line">        indexC = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> indexC &lt; <span class="built_in">len</span>(A) + <span class="built_in">len</span>(B):</span><br><span class="line">            <span class="keyword">if</span> indexA == <span class="built_in">len</span>(A) <span class="keyword">or</span> indexB == <span class="built_in">len</span>(B):</span><br><span class="line">                <span class="keyword">if</span> indexA == <span class="built_in">len</span>(A):</span><br><span class="line">                    ans.append(B[indexB])</span><br><span class="line">                    indexB += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(A[indexA])</span><br><span class="line">                    indexA += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> A[indexA] &lt; B[indexB]:</span><br><span class="line">                    ans.append(A[indexA])</span><br><span class="line">                    indexA += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(B[indexB])</span><br><span class="line">                    indexB += <span class="number">1</span></span><br><span class="line">            indexC += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：非常值得刷的一道热身题， 需要考虑两个 array 越界的问题。看了下答案用三个 while 循环也可以。</p>
<h3 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/description/">88. Merge Sorted Array (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The number of elements initialized in nums1 and nums2 are m and n respectively.</span><br><span class="line">You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p>思路：直觉上想不太出来怎么不创建新的存储空间把小数组 merge 到大数组里。看了答案，如果 nums1 后面空着这么些空，就从后面开始填。哎，曾经是能自主想的出的。。。正着困难的话就反着试试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) == <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">                nums1[i] = nums2[i]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index1 = m - <span class="number">1</span></span><br><span class="line">        index2 = n - <span class="number">1</span></span><br><span class="line">        index3 = <span class="built_in">len</span>(nums1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index3 &gt;= <span class="number">0</span> <span class="keyword">and</span> index2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> index1 &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[index3] = nums2[index2]</span><br><span class="line">                index2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums1[index1] &lt; nums2[index2]:</span><br><span class="line">                    nums1[index3] = nums2[index2]</span><br><span class="line">                    index2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums1[index3] = nums1[index1]</span><br><span class="line">                    index1 -= <span class="number">1</span></span><br><span class="line">            index3 -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：虽然是 easy 题，要考虑情况：1.nums1 和 nums2 一样大的话需要逐个考过去；2.index2 如果走到最前面就可以结束了。注意题目的输入包含了 m 和 n 要利用好</p>
<p>高频：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            nums1[:] = nums2[:]</span><br><span class="line">        i1 = m - <span class="number">1</span></span><br><span class="line">        i2 = n - <span class="number">1</span></span><br><span class="line">        im = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i1 &gt;= <span class="number">0</span> <span class="keyword">and</span> i2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i1] &lt; nums2[i2]:</span><br><span class="line">                nums1[im] = nums2[i2]</span><br><span class="line">                i2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[im] = nums1[i1]</span><br><span class="line">                i1 -= <span class="number">1</span></span><br><span class="line">            im -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i1 &lt; <span class="number">0</span>:</span><br><span class="line">            nums1[:i2 + <span class="number">1</span>] = nums2[:i2 + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>总结：代码简化，也更好理解一些，算法还是原来的，从nums1后往前填��注意最后如果nums1都填完了要把nums2剩余的都天过去nums1[:i2 <strong>+ 1</strong>] = nums2[:i2 <strong>+ 1</strong>]</p>
<h3 id="73-Set-Matrix-Zeroes-Medium"><a href="#73-Set-Matrix-Zeroes-Medium" class="headerlink" title="73. Set Matrix Zeroes (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/set-matrix-zeroes/">73. Set Matrix Zeroes (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">A straight forward solution using O(mn) space is probably a bad idea.</span><br><span class="line">A simple improvement uses O(m + n) space, but still not the best solution.</span><br><span class="line">Could you devise a constant space solution?</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        r0 = <span class="built_in">set</span>()</span><br><span class="line">        c0 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[r][c] == <span class="number">0</span>:</span><br><span class="line">                    r0.add(r)</span><br><span class="line">                    c0.add(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> r0:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                matrix[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> c0:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">                matrix[r][c] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>总结：O(m+n)空间的解法<br>二刷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        is1stRZ, is1stCZ = <span class="literal">True</span> <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> matrix[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">False</span>, <span class="literal">True</span> <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))[<span class="number">0</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, r <span class="keyword">in</span> <span class="built_in">enumerate</span>(matrix):</span><br><span class="line">            <span class="keyword">for</span> j, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(r):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">and</span> j <span class="keyword">and</span> c == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                matrix[i] = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> is1stRZ:</span><br><span class="line">            matrix[<span class="number">0</span>] = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">if</span> is1stCZ:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>总结：O(1)空间</p>
<h3 id="56-Merge-Intervals-Medium"><a href="#56-Merge-Intervals-Medium" class="headerlink" title="56. Merge Intervals (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of intervals, merge all overlapping intervals.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        cur, ans = intervals[<span class="number">0</span>], []</span><br><span class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> it[<span class="number">0</span>] &lt;= cur[<span class="number">1</span>]:</span><br><span class="line">                cur[<span class="number">1</span>] = <span class="built_in">max</span>(cur[<span class="number">1</span>], it[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(cur)</span><br><span class="line">                cur = it</span><br><span class="line">        ans.append(cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>2刷，面经：Cruise。…cur[1] = <strong>max(intervals[i][1], cur[1])</strong>…</p>
<h3 id="LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><a href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy" class="headerlink" title="LinC 839. Merge Two Sorted Interval Lists (Easy)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/merge-two-sorted-interval-lists/description">LinC 839. Merge Two Sorted Interval Lists (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Merge two sorted (ascending) lists of interval and return it as a new sorted list. The new sorted list should be made by splicing together the intervals of the two lists and sorted in ascending order.</span><br><span class="line"></span><br><span class="line">The intervals in the given list do not overlap.</span><br><span class="line">The intervals in different lists may overlap.</span><br><span class="line">Example</span><br><span class="line">Given list1 = [(1,2),(3,4)] and list2 = [(2,3),(5,6)], return [(1,4),(5,6)].</span><br></pre></td></tr></table></figure>
<p>思路：思路跟上题 merge interval一样，可以不做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of Interval.</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start, end):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end = end</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param list1: one of the given list</span></span><br><span class="line"><span class="string">    @param list2: another list</span></span><br><span class="line"><span class="string">    @return: the new sorted list of interval</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoInterval</span>(<span class="params">self, list1, list2</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        list3 = list1 + list2</span><br><span class="line">        list3.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        ans = [list3[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(list3)):</span><br><span class="line">            <span class="keyword">if</span> list3[i].start &lt;= ans[-<span class="number">1</span>].end:</span><br><span class="line">                ans[-<span class="number">1</span>].end = <span class="built_in">max</span>(list3[i].end, ans[-<span class="number">1</span>].end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(list3[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>二刷：删掉一刷代码，统一思路</p>
<h3 id="228-Summary-Ranges-Medium"><a href="#228-Summary-Ranges-Medium" class="headerlink" title="228. Summary Ranges (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/summary-ranges/description/">228. Summary Ranges (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted integer array without duplicates, return the summary of its ranges.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先写 O(n) 的再优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans, start = [], <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addToRes</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                ans.append(<span class="built_in">str</span>(nums[l]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(nums[l])&#125;</span>-&gt;<span class="subst">&#123;<span class="built_in">str</span>(nums[r])&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i + <span class="number">1</span>] - <span class="number">1</span>:</span><br><span class="line">                addToRes(start, i)</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">        addToRes(start, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>二刷：删掉了一刷的思路，代码和总结。 ..start = 0…def addToRes(l, r):…start = i + 1…</p>
<h3 id="67-Add-Binary-Easy"><a href="#67-Add-Binary-Easy" class="headerlink" title="67. Add Binary (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/">67. Add Binary (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given two binary strings, return their sum (also a binary string).</span><br><span class="line"></span><br><span class="line">The input strings are both non-empty and contains only characters 1 or 0.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        m = <span class="built_in">len</span>(a)</span><br><span class="line">        n = <span class="built_in">len</span>(b)</span><br><span class="line">        l = <span class="built_in">max</span>(m, n)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= l:</span><br><span class="line">            <span class="keyword">if</span> i &lt;= m <span class="keyword">and</span> i &lt;= n:</span><br><span class="line">                val = <span class="built_in">int</span>(a[-i]) + <span class="built_in">int</span>(b[-i]) + carry</span><br><span class="line">            <span class="keyword">elif</span> i &lt;= m:</span><br><span class="line">                val = <span class="built_in">int</span>(a[-i]) + carry</span><br><span class="line">            <span class="keyword">elif</span> i &lt;= n:</span><br><span class="line">                val = <span class="built_in">int</span>(b[-i]) + carry</span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="number">1</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            ans = <span class="built_in">str</span>(val % <span class="number">2</span>) + ans</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">            ans = <span class="string">&quot;1&quot;</span> + ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：…<strong>i = 1</strong>…while i **&lt;=** l:…if val &gt; 1: carry = 1; else: carry = 0; ans = str(val % 2) + ans; i += 1…</p>
<h3 id="12-Integer-to-Roman-Medium"><a href="#12-Integer-to-Roman-Medium" class="headerlink" title="12. Integer to Roman (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-to-roman/">12. Integer to Roman (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</span><br><span class="line"></span><br><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">For example, two is written as II in Roman numeral, just two one&#x27;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</span><br><span class="line"></span><br><span class="line">Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</span><br><span class="line"></span><br><span class="line">I can be placed before V (5) and X (10) to make 4 and 9.</span><br><span class="line">X can be placed before L (50) and C (100) to make 40 and 90.</span><br><span class="line">C can be placed before D (500) and M (1000) to make 400 and 900.</span><br><span class="line">Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        n = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        l = [<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>]</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(n):</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            t = num // v</span><br><span class="line">            ans += l[i] * t</span><br><span class="line">            num %= v</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：有了n和l俩数组就是easy了</p>
<h3 id="43-Multiply-Strings-Medium"><a href="#43-Multiply-Strings-Medium" class="headerlink" title="43. Multiply Strings (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/multiply-strings/">43. Multiply Strings (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The length of both num1 and num2 is &lt; 110.</span><br><span class="line">Both num1 and num2 contain only digits 0-9.</span><br><span class="line">Both num1 and num2 do not contain any leading zero, except the number 0 itself.</span><br><span class="line">You must not use any built-in BigInteger library or convert the inputs to integer directly.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num1) + <span class="built_in">len</span>(num2))]</span><br><span class="line">        num1 = num1[::-<span class="number">1</span>]</span><br><span class="line">        num2 = num2[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num2)):</span><br><span class="line">                res[i + j] += <span class="built_in">int</span>(num1[i]) * <span class="built_in">int</span>(num2[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">            d = res[i] % <span class="number">10</span></span><br><span class="line">            c = res[i] // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(res) - <span class="number">1</span>:</span><br><span class="line">                res[i + <span class="number">1</span>] += c</span><br><span class="line">            res[i] = d</span><br><span class="line"></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">while</span> res[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(res) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> res)</span><br></pre></td></tr></table></figure>
<p>高频：…for i in range(len(res)):…res[i] = d…<strong>while</strong> res[0] == 0 and len(res) &gt; 1:…</p>
<h3 id="128-Longest-Consecutive-Sequence-Medium"><a href="#128-Longest-Consecutive-Sequence-Medium" class="headerlink" title="128. Longest Consecutive Sequence (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</span><br><span class="line"></span><br><span class="line">Your algorithm should run in O(n) complexity.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums = <span class="built_in">set</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                m = n + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> m <span class="keyword">in</span> nums:</span><br><span class="line">                    m += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, m - n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：不明白为什么要作为高频题，除了惊叹于答案之神乎其技， 几乎学不到任何东西</p>
<h3 id="66-Plus-One-Easy"><a href="#66-Plus-One-Easy" class="headerlink" title="66. Plus One (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">66. Plus One (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</span><br><span class="line"></span><br><span class="line">The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</span><br><span class="line"></span><br><span class="line">You may assume the integer does not contain any leading zero, except the number 0 itself.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(digits):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                d += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d += c</span><br><span class="line">            c = d // <span class="number">10</span></span><br><span class="line">            d = d % <span class="number">10</span></span><br><span class="line">            digits[i] = d</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            digits.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频</p>
<h3 id="9-Palindrome-Number-Easy"><a href="#9-Palindrome-Number-Easy" class="headerlink" title="9. Palindrome Number (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/">9. Palindrome Number (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 121</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">Coud you solve it without converting the integer to a string?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        ox = x</span><br><span class="line">        nx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            t = x % <span class="number">10</span></span><br><span class="line">            nx = nx * <span class="number">10</span> + t</span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> nx == ox</span><br></pre></td></tr></table></figure>
<p>高频：…nx = nx * 10 + t…</p>
<h3 id="59-Spiral-Matrix-II-Medium"><a href="#59-Spiral-Matrix-II-Medium" class="headerlink" title="59. Spiral Matrix II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix-ii/">59. Spiral Matrix II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        mode, r, c, circle = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n * n + <span class="number">1</span>):</span><br><span class="line">            ans[r][c] = i</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c == n - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">1</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> r == n - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">2</span>:</span><br><span class="line">                c -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c == circle:</span><br><span class="line">                    mode = <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> r == circle + <span class="number">1</span>:</span><br><span class="line">                    mode = <span class="number">0</span></span><br><span class="line">                    circle += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：…if c == n - 1 - circle:…if r == n - 1 - circle:…if c == circle:…if r = circle + 1:…</p>
<h3 id="48-Rotate-Image-Medium"><a href="#48-Rotate-Image-Medium" class="headerlink" title="48. Rotate Image (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/">48. Rotate Image (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">You are given an n x n 2D matrix representing an image.</span><br><span class="line">Rotate the image by 90 degrees (clockwise).</span><br><span class="line">Note:</span><br><span class="line">You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        matrix.reverse()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(r, n):</span><br><span class="line">                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]</span><br></pre></td></tr></table></figure>
<p>高频：需要懂得顺时针转就是上下翻转以后对角线翻转，逆时针转就是左右翻转以后对角线翻转。懂list(zip(*list))的话就是一行代码</p>
<h3 id="54-Spiral-Matrix-Medium"><a href="#54-Spiral-Matrix-Medium" class="headerlink" title="54. Spiral Matrix (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/">54. Spiral Matrix (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        mode, circle, r, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">            ans.append(matrix[r][c])</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> c == n - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">1</span></span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> r == m - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">2</span></span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> c == circle:</span><br><span class="line">                    mode = <span class="number">3</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> r == circle + <span class="number">1</span>:</span><br><span class="line">                    mode = <span class="number">0</span></span><br><span class="line">                    circle += <span class="number">1</span></span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：相比其他答案，更喜欢这个sprial matrix II用过的模板，不同之处是这里要先处理转向，用来应对[[1],[2]]这种输入</p>
<h3 id="68-Text-Justification-Hard"><a href="#68-Text-Justification-Hard" class="headerlink" title="68. Text Justification (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/text-justification/">68. Text Justification (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.</span><br><span class="line"></span><br><span class="line">You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &#x27; &#x27; when necessary so that each line has exactly maxWidth characters.</span><br><span class="line"></span><br><span class="line">Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</span><br><span class="line"></span><br><span class="line">For the last line of text, it should be left justified and no extra space is inserted between words.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">A word is defined as a character sequence consisting of non-space characters only.</span><br><span class="line">Each word&#x27;s length is guaranteed to be greater than 0 and not exceed maxWidth.</span><br><span class="line">The input array words contains at least one word.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">Explanation: Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;,</span><br><span class="line">             because the last line must be left-justified instead of fully-justified.</span><br><span class="line">             Note that the second line is also left-justified becase it contains only one word.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,</span><br><span class="line">         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]</span><br><span class="line">maxWidth = 20</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;Science  is  what we&quot;,</span><br><span class="line">  &quot;understand      well&quot;,</span><br><span class="line">  &quot;enough to explain to&quot;,</span><br><span class="line">  &quot;a  computer.  Art is&quot;,</span><br><span class="line">  &quot;everything  else  we&quot;,</span><br><span class="line">  &quot;do                  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words: List[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        ans, line, letter_count = [], [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> letter_count + <span class="built_in">len</span>(w) + <span class="built_in">len</span>(line) &gt; maxWidth:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxWidth - letter_count):</span><br><span class="line">                    line[i % (<span class="built_in">len</span>(line) - <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>)] += <span class="string">&#x27; &#x27;</span></span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(line))</span><br><span class="line">                line = []</span><br><span class="line">                letter_count = <span class="number">0</span></span><br><span class="line">            line += [w]</span><br><span class="line">            letter_count += <span class="built_in">len</span>(w)</span><br><span class="line">        ans.append(<span class="string">&#x27; &#x27;</span>.join(line).ljust(maxWidth))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：需要知道很巧妙的round robin填空格的方法：…line[i % (len(line) - 1 or 1)] += ‘ ‘…，str.ljust(width[, fillchar])默认填空格</p>
<h3 id="36-Valid-Sudoku-Medium"><a href="#36-Valid-Sudoku-Medium" class="headerlink" title="36. Valid Sudoku (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-sudoku/">36. Valid Sudoku (Medium)</a></h3><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:<br>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.<br>A partially filled sudoku which is valid.<br>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being</span><br><span class="line">    modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure>
<p>Note:<br>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.<br>The given board contain only digits 1-9 and the character ‘.’.<br>The given board size is always 9x9.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment">#check every row</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> board:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.validate(r):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#check every col</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">zip</span>(*board):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.validate(<span class="built_in">list</span>(c)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#check every 3x3</span></span><br><span class="line">        <span class="keyword">for</span> dr <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">            <span class="keyword">for</span> dc <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">                flat = []</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                        flat.append(board[r + dr][c + dc])</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.validate(flat):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, r</span>):</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> r:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    visited.add(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>高频, 面经：维萨。*用来unpack二维数组，zip(*board)用来返回一个用每行同一列位置的元素拼成的新的tuple的iterator</p>
<h3 id="38-Count-and-Say-Easy"><a href="#38-Count-and-Say-Easy" class="headerlink" title="38. Count and Say (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-and-say/">38. Count and Say (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">The count-and-say sequence is the sequence of integers with the first five terms as following:</span><br><span class="line"></span><br><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">1 is read off as &quot;one 1&quot; or 11.</span><br><span class="line">11 is read off as &quot;two 1s&quot; or 21.</span><br><span class="line">21 is read off as &quot;one 2, then one 1&quot; or 1211.</span><br><span class="line"></span><br><span class="line">Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</span><br><span class="line">Note: Each term of the sequence of integers will be represented as a string.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>
<p>用itertools.groupby():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        ans = <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            t = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> d, g <span class="keyword">in</span> itertools.groupby(ans):</span><br><span class="line">                cnt = <span class="built_in">len</span>(<span class="built_in">list</span>(g))</span><br><span class="line">                t += <span class="built_in">str</span>(cnt) + <span class="built_in">str</span>(d)</span><br><span class="line">            ans = t</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>不用groupby:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        ans = <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            res = <span class="string">&quot;&quot;</span></span><br><span class="line">            t = ans + <span class="string">&quot;#&quot;</span></span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t) - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t[i] == t[i + <span class="number">1</span>]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += <span class="built_in">str</span>(cnt) + t[i]</span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">            ans = res</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：题目描述不是很清楚，用groupby：…for d, g in itertools.groupby():…。不用groupby：…res = “”; t = ans + “#”…</p>
<h3 id="14-Longest-Common-Prefix-Easy"><a href="#14-Longest-Common-Prefix-Easy" class="headerlink" title="14. Longest Common Prefix (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">14. Longest Common Prefix (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Write a function to find the longest common prefix string amongst an array of strings.</span><br><span class="line"></span><br><span class="line">If there is no common prefix, return an empty string &quot;&quot;.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All given inputs are in lowercase letters a-z.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        ans = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(ans) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(strs[i]) <span class="keyword">and</span> ans[j] == strs[i][j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                ans = ans[:j]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：<br>面经：Quora。删掉了高频的总结，换成我自己想出来的解法。</p>
<h3 id="119-Pascal’s-Triangle-II-Easy"><a href="#119-Pascal’s-Triangle-II-Easy" class="headerlink" title="119. Pascal’s Triangle II (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/">119. Pascal’s Triangle II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&#x27;s triangle.</span><br><span class="line">Note that the row index starts from 0.</span><br><span class="line">In Pascal&#x27;s triangle, each number is the sum of the two numbers directly above it.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Could you optimize your algorithm to use only O(k) extra space?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rowIndex):</span><br><span class="line">            ans = [x + y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(ans + [<span class="number">0</span>], [<span class="number">0</span>] + ans)]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：很巧妙的…[x + y for x, y in zip(ans + [0], [0] + ans)]…</p>
<h3 id="6-ZigZag-Conversion-Medium"><a href="#6-ZigZag-Conversion-Medium" class="headerlink" title="6. ZigZag Conversion (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/zigzag-conversion/">6. ZigZag Conversion (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</span><br><span class="line"></span><br><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br><span class="line">And then read line by line: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line"></span><br><span class="line">Write the code that will take a string and make this conversion given a number of rows:</span><br><span class="line"></span><br><span class="line">string convert(string s, int numRows);</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span>] * numRows</span><br><span class="line">        r, move = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> s:</span><br><span class="line">            res[r] += l</span><br><span class="line">            r += move</span><br><span class="line">            <span class="keyword">if</span> r == numRows - <span class="number">1</span>:</span><br><span class="line">                move = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> r == <span class="number">0</span>:</span><br><span class="line">                move = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>
<p>高频：想太多反而写不出来，直接粗暴拼反而能拼出来，注意numRows为1时单独处理</p>
<h3 id="8-String-to-Integer-atoi-Medium"><a href="#8-String-to-Integer-atoi-Medium" class="headerlink" title="8. String to Integer (atoi) (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-to-integer-atoi/">8. String to Integer (atoi) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Implement atoi which converts a string to an integer.</span><br><span class="line"></span><br><span class="line">The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</span><br><span class="line"></span><br><span class="line">The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</span><br><span class="line"></span><br><span class="line">If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</span><br><span class="line"></span><br><span class="line">If no valid conversion could be performed, a zero value is returned.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Only the space character &#x27; &#x27; is considered as whitespace character.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &#x27;-&#x27;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &#x27;3&#x27; as the next character is not a numerical digit.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &#x27;w&#x27;, which is not a numerical</span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="built_in">str</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        valid = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        signs = <span class="string">&#x27;+-&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> valid <span class="keyword">and</span> s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> signs:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> signs:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> l <span class="keyword">in</span> valid:</span><br><span class="line">                ans += l</span><br><span class="line">                <span class="keyword">if</span> sign == -<span class="number">1</span> <span class="keyword">and</span> -<span class="built_in">int</span>(ans) &lt; -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">                    <span class="keyword">return</span> -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">int</span>(ans) &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> sign * <span class="built_in">int</span>(ans) <span class="keyword">if</span> ans <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * <span class="built_in">int</span>(ans) <span class="keyword">if</span> ans <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>高频：从例子之多就能看出来要考虑的case非常多。比的是细致</p>
<h3 id="57-Insert-Interval-Hard"><a href="#57-Insert-Interval-Hard" class="headerlink" title="57. Insert Interval (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-interval/description/">57. Insert Interval (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</span><br><span class="line"></span><br><span class="line">You may assume that the intervals were initially sorted according to their start times.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br><span class="line">NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, intervals, newInterval</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> [newInterval]</span><br><span class="line">        ans = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]:</span><br><span class="line">                ans.append(intervals[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]:</span><br><span class="line">            newInterval[<span class="number">0</span>] = <span class="built_in">min</span>(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>])</span><br><span class="line">            newInterval[<span class="number">1</span>] = <span class="built_in">max</span>(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans.append(newInterval)</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals):</span><br><span class="line">            ans.append(intervals[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：重点是知道先把，结束小于新开始的…if intervals[i][1] &lt; newInterval[0]:…加到ans里，然后过开始小于新结束的…if…and intervals[i][0] &lt;= newInterval[1]: …min…max…这个方法</p>
<h3 id="937-Reorder-Log-Files-Easy"><a href="#937-Reorder-Log-Files-Easy" class="headerlink" title="937. Reorder Log Files (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-log-files/">937. Reorder Log Files (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">You have an array of logs.  Each log is a space delimited string of words.</span><br><span class="line"></span><br><span class="line">For each log, the first word in each log is an alphanumeric identifier.  Then, either:</span><br><span class="line"></span><br><span class="line">Each word after the identifier will consist only of lowercase letters, or;</span><br><span class="line">Each word after the identifier will consist only of digits.</span><br><span class="line">We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.</span><br><span class="line"></span><br><span class="line">Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.</span><br><span class="line"></span><br><span class="line">Return the final order of the logs.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]</span><br><span class="line">Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">0 &lt;= logs.length &lt;= 100</span><br><span class="line">3 &lt;= logs[i].length &lt;= 100</span><br><span class="line">logs[i] is guaranteed to have an identifier, and a word after the identifier.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span>(<span class="params">self, logs: List[<span class="built_in">str</span>]</span>) -&gt; List[str]:</span></span><br><span class="line">        nums, letters = [], []</span><br><span class="line">        <span class="keyword">for</span> log <span class="keyword">in</span> logs:</span><br><span class="line">            words = log.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> words[<span class="number">1</span>].isdigit():</span><br><span class="line">                nums.append(log)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                letters.append(log)</span><br><span class="line">        letters.sort(key = <span class="keyword">lambda</span> x: x.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">        letters.sort(key = <span class="keyword">lambda</span> x: x.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> letters + nums</span><br></pre></td></tr></table></figure>
<p>面经：Amazon，用key function，sort是stable</p>
<h3 id="189-Rotate-Array-Easy"><a href="#189-Rotate-Array-Easy" class="headerlink" title="189. Rotate Array (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/">189. Rotate Array (Easy)</a></h3><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,4,5,6,7] and k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [-1,-100,3,99] and k &#x3D; 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<p>O(n) space:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        original = nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums[(i + k) % n] = original[i]</span><br></pre></td></tr></table></figure>
<p>O(1) space:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        k = k % <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        nums.reverse()</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, k, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, nums, s, e</span>):</span></span><br><span class="line">        <span class="keyword">while</span> s &lt; e:</span><br><span class="line">            nums[s], nums[e] = nums[e], nums[s]</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            e -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>面经：维萨. 向右走2：—&gt;–&gt; to –&gt;—&gt; 或者向左走2：&lt;–&lt;— to &lt;—&lt;–</p>
<h3 id="296-Best-Meeting-Point-Hard-带锁"><a href="#296-Best-Meeting-Point-Hard-带锁" class="headerlink" title="296. Best Meeting Point (Hard) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-meeting-point">296. Best Meeting Point (Hard) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/best-meeting-point/description">LinC 912. Best Meeting Point</a><br>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p>
<p>Example 1:<br>Input:<br>[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br>Output:<br>6<br>Explanation:<br>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of <code>2 + 2 + 2 = 6</code> is minimal. So return <code>6</code>.</p>
<p>Example 2:<br>Input:<br>[[1,1,0,0,1],[1,0,1,0,0],[0,0,1,0,1]]<br>Output:<br>14</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTotalDistance</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        rows, cols = [], []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="number">1</span>:</span><br><span class="line">                    rows.append(r)</span><br><span class="line">                    cols.append(c)</span><br><span class="line">        rows.sort()</span><br><span class="line">        cols.sort()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(rows) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            ans += rows[j] - rows[i] + cols[j] - cols[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：维萨。关键是知道将行和列排序，然后从两边算距离的方法。</p>
<h2 id="Sliding-Window-滑动窗口"><a href="#Sliding-Window-滑动窗口" class="headerlink" title="Sliding Window 滑动窗口"></a>Sliding Window 滑动窗口</h2><h3 id="438-Find-All-Anagrams-in-a-String-Medium"><a href="#438-Find-All-Anagrams-in-a-String-Medium" class="headerlink" title="438. Find All Anagrams in a String (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String (Medium)</a></h3><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.<br>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.<br>The order of output does not matter.</p>
<p>Example 1:<br>Input:<br>s: “cbaebabacd” p: “abc”<br>Output:<br>[0, 6]<br>Explanation:<br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.</p>
<p>Example 2:<br>Input:<br>s: “abab” p: “ab”<br>Output:<br>[0, 1, 2]<br>Explanation:<br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        n, m = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        pCounter = Counter(p)</span><br><span class="line">        sCounter = Counter(s[:m - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, n):</span><br><span class="line">            si = i - m + <span class="number">1</span></span><br><span class="line">            sCounter[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pCounter == sCounter:</span><br><span class="line">                ans.append(si)</span><br><span class="line">            sCounter[s[si]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sCounter[s[si]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> sCounter[s[si]]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。注意sCounter[s[si]] -= 1需要减相应字母的计数，否则会产生bug。todo：也用sliding window的模板改下代码</p>
<h3 id="3-Longest-Substring-Without-Repeating-Characters-Medium"><a href="#3-Longest-Substring-Without-Repeating-Characters-Medium" class="headerlink" title="3. Longest Substring Without Repeating Characters (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters (Medium)</a></h3><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:<br>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.</p>
<p>Example 2:<br>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p>
<p>Example 3:<br>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        p, d, ans = <span class="number">0</span>, &#123;&#125;, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> d:</span><br><span class="line">                p = <span class="built_in">max</span>(p, d[v] + <span class="number">1</span>)</span><br><span class="line">            d[v] = i</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - p + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经，3刷：Amazon。sliding window模板代码看不懂了。l和i两个指针，如果c重复了，就将l挪到上次出现的c后一位. l不能往回走，如abba，到最后a的时候l不能回到0+1的位置上去</p>
<h3 id="76-Minimum-Window-Substring-Hard"><a href="#76-Minimum-Window-Substring-Hard" class="headerlink" title="76. Minimum Window Substring (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring (Hard)</a></h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:<br>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line">        targetMap = Counter(t)</span><br><span class="line">        window = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        targetLen, formed = <span class="built_in">len</span>(targetMap), <span class="number">0</span></span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">#search left to right</span></span><br><span class="line">        <span class="keyword">while</span> r &lt;= <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">            c = s[r]</span><br><span class="line">            window[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> targetMap <span class="keyword">and</span> window[c] == targetMap[c]:</span><br><span class="line">                formed += <span class="number">1</span></span><br><span class="line">            <span class="comment">#found a valid substring, contracts left</span></span><br><span class="line">            <span class="keyword">while</span> formed == targetLen:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">or</span> r - l + <span class="number">1</span> &lt; <span class="built_in">len</span>(ans):</span><br><span class="line">                    ans = s[l:r + <span class="number">1</span>]</span><br><span class="line">                tempC = s[l]</span><br><span class="line">                window[tempC] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tempC <span class="keyword">in</span> targetMap <span class="keyword">and</span> window[tempC] &lt; targetMap[tempC]:</span><br><span class="line">                    formed -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经, 二刷：Amazon。双指针sliding window，r前进，找到符合条件的substring以后收缩l寻找更短符合条件的substring</p>
<h3 id="1151-Minimum-Swaps-to-Group-All-1’s-Together-Medium-带锁"><a href="#1151-Minimum-Swaps-to-Group-All-1’s-Together-Medium-带锁" class="headerlink" title="1151    Minimum Swaps to Group All 1’s Together (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together">1151    Minimum Swaps to Group All 1’s Together (Medium) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/minimum-swaps-required-group-1s-together/">geeks for geeks article</a><br>Given an array of 0’s and 1’s, we need to write a program to find the minimum number of swaps required to group all 1’s present in the array together.</p>
<p>Examples:<br>Input : arr[] = {1, 0, 1, 0, 1}<br>Output : 1<br>Explanation: Only 1 swap is required to<br>group all 1’s together. Swapping index 1<br>and 4 will give arr[] = {1, 1, 1, 0, 0}</p>
<p>Input : arr[] = {1, 0, 1, 0, 1, 1}<br>Output : 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    counter = Counter(arr)</span><br><span class="line">    targetLen = counter[<span class="number">1</span>]</span><br><span class="line">    counter = Counter(arr[<span class="number">0</span>:targetLen])</span><br><span class="line">    most1s = counter[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr) - targetLen + <span class="number">1</span>):</span><br><span class="line">        <span class="comment">#because I already know how many 1s in previous subarray. Just add or subtract as I go</span></span><br><span class="line">        <span class="keyword">if</span> boxes[i - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            counter[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> boxes[i + targetLen - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            counter[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> counter[<span class="number">1</span>] &gt; most1s:</span><br><span class="line">            most1s = counter[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> targetLen - most1s</span><br></pre></td></tr></table></figure>
<p>面经：Celo。算法的核心是：find the subarray of counter[1] length that has the most 1’s. Then just move the 1’s from elsewhere to fill the 0’s in this subarray</p>
<h3 id="1004-Max-Consecutive-Ones-III-medium"><a href="#1004-Max-Consecutive-Ones-III-medium" class="headerlink" title="1004. Max Consecutive Ones III medium"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-iii/">1004. Max Consecutive Ones III medium</a></h3><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1.<br>Return the length of the longest (contiguous) subarray that contains only 1s.</p>
<p>Example 1:<br>Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>Output: 6<br>Explanation:<br>[1,1,1,0,0,1,1,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p>
<p>Example 2:<br>Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>Output: 10<br>Explanation:<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p>
<p>Note:<br>1 &lt;= A.length &lt;= 20000<br>0 &lt;= K &lt;= A.length<br>A[i] is 0 or 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, A: List[<span class="built_in">int</span>], K: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">            K -= <span class="number">1</span> - A[r]</span><br><span class="line">            <span class="keyword">if</span> K &lt; <span class="number">0</span>:</span><br><span class="line">                K += <span class="number">1</span> - A[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r - l + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag</p>
<h2 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List 链表"></a>Linked List 链表</h2><h3 id="83-Remove-Duplicates-from-Sorted-List-Easy-83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="[83. Remove Duplicates from Sorted List (Easy)](83. Remove Duplicates from Sorted List)"></a>[83. Remove Duplicates from Sorted List (Easy)](83. Remove Duplicates from Sorted List)</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>Example 1:<br>Input: 1-&gt;1-&gt;2<br>Output: 1-&gt;2</p>
<p>Example 2:<br>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>Output: 1-&gt;2-&gt;3</p>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>总结：…<strong>temp = head</strong>; while temp and temp.next: …temp.next = temp.next.next; else: temp = temp.next…</p>
<h3 id="82-Remove-Duplicates-from-Sorted-List-II-Medium"><a href="#82-Remove-Duplicates-from-Sorted-List-II-Medium" class="headerlink" title="82. Remove Duplicates from Sorted List II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">82. Remove Duplicates from Sorted List II (Medium)</a></h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>Example 1:<br>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>Output: 1-&gt;2-&gt;5</p>
<p>Example 2:<br>Input: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>Output: 2-&gt;3</p>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            has_dupe = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == cur.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                has_dupe = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> has_dupe:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>高频：…cur = dummy…has_dupe = False…cur.next = cur.next.next…</p>
<h3 id="21-Merge-Two-Sorted-Lists-Easy"><a href="#21-Merge-Two-Sorted-Lists-Easy" class="headerlink" title="21. Merge Two Sorted Lists (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists (Easy)</a></h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = l1</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = l2</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>高频：面经：Cruise。<br>三刷：手熟尔</p>
<h3 id="19-Remove-Nth-Node-From-End-of-List-Medium"><a href="#19-Remove-Nth-Node-From-End-of-List-Medium" class="headerlink" title="19. Remove Nth Node From End of List (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List (Medium)</a></h3><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>
<p>Note:<br>Given n will always be valid.</p>
<p>Follow up:<br>Could you do this in one pass?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        fast = slow = dummy</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>高频：dummy = ListNode(0)…fast = slow = dummy…slow.next = slow.next.next…</p>
<h3 id="2-Add-Two-Numbers-Medium"><a href="#2-Add-Two-Numbers-Medium" class="headerlink" title="2. Add Two Numbers (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers/">2. Add Two Numbers (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</span><br><span class="line"></span><br><span class="line">You may assume the two numbers do not contain any leading zero, except the number 0 itself.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<p>写法1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: Optional[ListNode], l2: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        ans = prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">                d = l1.val + l2.val + carry</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> l1:</span><br><span class="line">                d = l1.val + carry</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d = l2.val + carry</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            carry = <span class="number">0</span> <span class="keyword">if</span> d &lt; <span class="number">10</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            cur = ListNode(d % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">                ans = prev = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.<span class="built_in">next</span> = cur</span><br><span class="line">                prev = cur</span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            prev.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>写法2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: Optional[ListNode], l2: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">l2n</span>(<span class="params">n</span>):</span></span><br><span class="line">            res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                res = <span class="built_in">str</span>(n.val) + res</span><br><span class="line">                n = n.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(res)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">n2l</span>(<span class="params">n</span>):</span></span><br><span class="line">            head = <span class="literal">None</span></span><br><span class="line">            n = <span class="built_in">str</span>(n)</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> n:</span><br><span class="line">                cur = ListNode(d)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                    head = cur</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp = head</span><br><span class="line">                    head = cur</span><br><span class="line">                    cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">return</span> n2l(l2n(l1) + l2n(l2))</span><br></pre></td></tr></table></figure>
<p>写法3：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l2n</span>(<span class="params">n</span>):</span></span><br><span class="line">    res, d = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += n.val * (<span class="number">10</span> ** d)</span><br><span class="line">        d += <span class="number">1</span></span><br><span class="line">        n = n.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n2l</span>(<span class="params">n</span>):</span></span><br><span class="line">    res = prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        cur = ListNode(n % <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            res = prev = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev.<span class="built_in">next</span> = cur</span><br><span class="line">            prev = cur</span><br><span class="line">        n //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">return</span> n2l(l2n(l1) + l2n(l2))</span><br></pre></td></tr></table></figure>
<p>2刷：总结：写l2n和n2l两个函数</p>
<h3 id="86-Partition-List-Medium"><a href="#86-Partition-List-Medium" class="headerlink" title="86. Partition List (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-list/description/">86. Partition List (Medium)</a></h3><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>Example:<br>Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        loHead = loDummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        hiHead = hiDummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                loHead.<span class="built_in">next</span> = head</span><br><span class="line">                loHead = loHead.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hiHead.<span class="built_in">next</span> = head</span><br><span class="line">                hiHead = hiHead.<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        loHead.<span class="built_in">next</span> = hiDummy.<span class="built_in">next</span></span><br><span class="line">        hiHead.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> loDummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>高频, 五刷：两个dummy，两个worker</p>
<h3 id="141-Linked-List-Cycle-Easy"><a href="#141-Linked-List-Cycle-Easy" class="headerlink" title="141. Linked List Cycle (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/description/">141. Linked List Cycle (Easy)</a></h3><p>Given a linked list, determine if it has a cycle in it.<br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p>
<p>Example 1:<br>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Linked List Cycle example1"></p>
<p>Example 2:<br>Input: head = [1,2], pos = 0<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="Linked List Cycle example2"></p>
<p>Example 3:<br>Input: head = [1], pos = -1<br>Output: false<br>Explanation: There is no cycle in the linked list.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="Linked List Cycle example3"></p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s = f = head</span><br><span class="line">        <span class="keyword">while</span> f.<span class="built_in">next</span> <span class="keyword">and</span> f.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            f = f.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> s == f:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>二刷，面经：维萨。</p>
<h3 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II (Medium)</a></h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.<br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.<br>Note: Do not modify the linked list.</p>
<p>Example 1:<br>Input: head = [3,2,0,-4], pos = 1<br>Output: tail connects to node index 1<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Linked List Cycle II example1"></p>
<p>Example 2:<br>Input: head = [1,2], pos = 0<br>Output: tail connects to node index 0<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="Linked List Cycle II example2"></p>
<p>Example 3:<br>Input: head = [1], pos = -1<br>Output: no cycle<br>Explanation: There is no cycle in the linked list.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="Linked List Cycle II example3"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        s = f = head</span><br><span class="line">        loop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> f.<span class="built_in">next</span> <span class="keyword">and</span> f.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            f = f.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> s == f:</span><br><span class="line">                loop = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> loop:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        s = head</span><br><span class="line">        <span class="keyword">while</span> s != f:</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            f = f.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>面经：维萨。关键知识点是1.相遇点是慢指针在环里的 <strong>第一圈</strong>。是快指针在环里的第n圈。2. 慢指针走了x+y, 快指针走了 <strong>2(x + y)</strong> 3. 快指针这个 <strong>距离又等同于 x + y + nr</strong> 4. x = nr - y 4. <strong>由下图可见， nr - y = z</strong> 5. z 和 x 是相等的。 6. 因此可以head与快或慢同时前进，相遇即是B点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    x            y</span><br><span class="line">A ------ B --------+</span><br><span class="line">         |         |</span><br><span class="line">       z |         |</span><br><span class="line">         +----C----+</span><br><span class="line">* 环的长度为 r</span><br><span class="line">* C: 快慢指针相遇点</span><br></pre></td></tr></table></figure>

<h3 id="206-Reverse-Linked-List-Easy"><a href="#206-Reverse-Linked-List-Easy" class="headerlink" title="206. Reverse Linked List (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List (Easy)</a></h3><p>Reverse a singly linked list.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>Follow up:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?<br>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nextHead = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nextHead</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        savedListHead = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> savedListHead</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(head, <span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, head, pre</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        nextHead = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="keyword">return</span> self.helper(nextHead, head)</span><br></pre></td></tr></table></figure>
<p>高频, 四刷：遍历：pre = None…nextHead = head.next…递归：增加了<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=O0By4Zq0OFc">这个油管视频的递归方法</a>。savedListHead是base case，然后最后层层传回去。…return f(nextHead, head)…</p>
<h3 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">160. Intersection of Two Linked Lists (Easy)</a></h3><p>Write a program to find the node at which the intersection of two singly linked lists begins.<br>For example, the following two linked lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗</span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>begin to intersect at node c1.</p>
<p>Notes:<br>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        savedHeadA, savedHeadB = headA, headB</span><br><span class="line">        <span class="keyword">if</span> headA == <span class="literal">None</span> <span class="keyword">or</span> headB == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        lenA, lenB = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headA.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headB.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            diff = lenA - lenB</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(diff):</span><br><span class="line">                savedHeadA = savedHeadA.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff = lenB - lenA</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(diff):</span><br><span class="line">                savedHeadB = savedHeadB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> savedHeadA != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> savedHeadA == savedHeadB:</span><br><span class="line">                <span class="keyword">return</span> savedHeadA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                savedHeadA = savedHeadA.<span class="built_in">next</span></span><br><span class="line">                savedHeadB = savedHeadB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>思路：统计两条链走到头的长度，lenA 和 lenB, 然后让长的那条先走两者的差值，然后一起走，返回相遇的那点。或者将A的尾巴连到B的开头，找环的入口<br>总结：1.注意空输入（不能假设 headA 或 B 有 next）2.注意 headA headB 是一个节点 i.e. 合体的情况</p>
<h3 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs (Medium)</a></h3><p>Given a linked list, swap every two adjacent nodes and return its head.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>Example:<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">            a, b = head, head.<span class="built_in">next</span></span><br><span class="line">            head = b.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = b</span><br><span class="line">            b.<span class="built_in">next</span> = a</span><br><span class="line">            cur = a</span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            cur.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        neighbor = head.<span class="built_in">next</span></span><br><span class="line">        frontier = neighbor.<span class="built_in">next</span></span><br><span class="line">        neighbor.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(frontier)</span><br><span class="line">        <span class="keyword">return</span> neighbor</span><br></pre></td></tr></table></figure>
<p>总结：a, b, 挪head，连接 cur.next，b的next到a，挪cur到a，切掉cur-&gt;。todo：理解递归答案</p>
<h3 id="61-Rotate-List-Medium"><a href="#61-Rotate-List-Medium" class="headerlink" title="61. Rotate List (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-list/">61. Rotate List (Medium)</a></h3><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p>
<p>Example 1:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>Example 2:<br>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</p>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        f = dummy</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f <span class="keyword">and</span> f.<span class="built_in">next</span>:</span><br><span class="line">            f = f.<span class="built_in">next</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        s = dummy</span><br><span class="line">        k %= l</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l - k):</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">        f.<span class="built_in">next</span> = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = s.<span class="built_in">next</span></span><br><span class="line">        s.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>高频，二刷：链长l，k %= l, 将第l - k位置的以后的放链表前面：s走l - k步，f.next接到dummy.next上，dummy.next接到s.next; s.next = None</p>
<h3 id="146-LRU-Cache-Medium"><a href="#146-LRU-Cache-Medium" class="headerlink" title="146. LRU Cache (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">146. LRU Cache (Medium)</a></h3><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br>The cache is initialized with a positive capacity.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* capacity *&#x2F; );</span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; evicts key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; evicts key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; returns -1 (not found)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; returns 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; returns 4</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, v</span>):</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.val = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.tail = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = self.d[key]</span><br><span class="line">            self.remove(n)</span><br><span class="line">            self.push(n)</span><br><span class="line">            <span class="keyword">return</span> n.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            self.remove(self.d[key])</span><br><span class="line">            <span class="keyword">del</span> self.d[key]</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self.d[key] = n</span><br><span class="line">        self.push(n)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.d) &gt; self.capacity:</span><br><span class="line">            <span class="keyword">del</span> self.d[self.tail.prev.key]</span><br><span class="line">            self.remove(self.tail.prev)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        n.prev.<span class="built_in">next</span> = n.<span class="built_in">next</span></span><br><span class="line">        n.<span class="built_in">next</span>.prev = n.prev</span><br><span class="line">        n.prev = <span class="literal">None</span></span><br><span class="line">        n.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        n.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = n</span><br><span class="line">        n.prev = self.head</span><br><span class="line">        self.head.<span class="built_in">next</span> = n</span><br></pre></td></tr></table></figure>
<p>高频, 4刷：dict的k为k，v为链表的节点n。注意put的时候要先把旧的重复key对从双链表中删除。或者使用OrderedDict这个数据结构，支持头部删除(mapping.popitem(last = False))和move_to_end(key)</p>
<h3 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/">234. Palindrome Linked List (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a singly linked list, determine if it is a palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br><span class="line">Follow up:</span><br><span class="line">Could you do it in O(n) time and O(1) space?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        s = f = head</span><br><span class="line">        midHead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> f <span class="keyword">and</span> f.<span class="built_in">next</span>:</span><br><span class="line">            f = f.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            nextHead = s.<span class="built_in">next</span></span><br><span class="line">            s.<span class="built_in">next</span> = midHead</span><br><span class="line">            midHead = s</span><br><span class="line">            s = nextHead</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            <span class="keyword">if</span> midHead.val != s.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = s.<span class="built_in">next</span></span><br><span class="line">                midHead = midHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>高频, 二刷：慢指针边走边反转，当链表是奇数个时需要s跳过中间节点再s,midhead同时前进：…if f: s = s.next…</p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><h3 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing just the characters &#x27;(&#x27;, &#x27;)&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;, &#x27;[&#x27; and &#x27;]&#x27;, determine if the input string is valid.</span><br><span class="line"></span><br><span class="line">An input string is valid if:</span><br><span class="line"></span><br><span class="line">Open brackets must be closed by the same type of brackets.</span><br><span class="line">Open brackets must be closed in the correct order.</span><br><span class="line">Note that an empty string is also considered valid.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        d = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">        ll = <span class="string">&#x27;(&#123;[&#x27;</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> ll:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                l = stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> d <span class="keyword">or</span> l != d[c]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>2刷：高频：注意在出栈前检验栈是否为空，走完以后检查栈是否为空</p>
<h3 id="71-Simplify-Path-Medium"><a href="#71-Simplify-Path-Medium" class="headerlink" title="71. Simplify Path (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/simplify-path/">71. Simplify Path (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.</span><br><span class="line"></span><br><span class="line">In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix</span><br><span class="line"></span><br><span class="line">Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;/home/&quot;</span><br><span class="line">Output: &quot;/home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;/../&quot;</span><br><span class="line">Output: &quot;/&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;/home//foo/&quot;</span><br><span class="line">Output: &quot;/home/foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;/a/./b/../../c/&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;/a/../../b/../c//.//&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br><span class="line">Example 6:</span><br><span class="line"></span><br><span class="line">Input: &quot;/a//b////c/d//././/..&quot;</span><br><span class="line">Output: &quot;/a/b/c&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        t = path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> p != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> p == <span class="string">&#x27;..&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> s:</span><br><span class="line">                        s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s.append(p)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>
<p>高频：注意split(‘/‘)是’/‘的会变成数组里一个空的元素</p>
<h3 id="150-Evaluate-Reverse-Polish-Notation-Medium"><a href="#150-Evaluate-Reverse-Polish-Notation-Medium" class="headerlink" title="150. Evaluate Reverse Polish Notation (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Evaluate the value of an arithmetic expression in Reverse Polish Notation.</span><br><span class="line"></span><br><span class="line">Valid operators are +, -, *, /. Each operand may be an integer or another expression.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Division between two integers should truncate toward zero.</span><br><span class="line">The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&#x27;t be any divide by zero operation.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) = 9</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 / 5)) = 6</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation:</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        operators = <span class="string">&quot;+-*/&quot;</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> op <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> op <span class="keyword">not</span> <span class="keyword">in</span> operators:</span><br><span class="line">                s.append(<span class="built_in">int</span>(op))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = s.pop()</span><br><span class="line">                a = s.pop()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    res = a + b</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    res = a - b</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    res = a * b</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> a * b &lt; <span class="number">0</span> <span class="keyword">and</span> a % b != <span class="number">0</span>:</span><br><span class="line">                        res = a // b + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res = a // b</span><br><span class="line">                s.append(res)</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>高频：需要注意leetcode里-1//20为0，而python里为-1，-21//20python里为-2。需要单独处理一下</p>
<h3 id="155-Min-Stack-Easy"><a href="#155-Min-Stack-Easy" class="headerlink" title="155. Min Stack (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/">155. Min Stack (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</span><br><span class="line"></span><br><span class="line">push(x) -- Push element x onto stack.</span><br><span class="line">pop() -- Removes the element on top of the stack.</span><br><span class="line">top() -- Get the top element.</span><br><span class="line">getMin() -- Retrieve the minimum element in the stack.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        curMin = self.getMin() <span class="keyword">if</span> self.stack <span class="keyword">else</span> sys.maxsize</span><br><span class="line">        <span class="keyword">if</span> x &lt; curMin:</span><br><span class="line">            curMin = x</span><br><span class="line">        self.stack.append((x, curMin))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：一个stack就用tuple，两个stack就相当于第二个stack来维持curMin</p>
<h3 id="224-Basic-Calculator-Hard"><a href="#224-Basic-Calculator-Hard" class="headerlink" title="224. Basic Calculator (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator/">224. Basic Calculator (Hard)</a></h3><p>Implement a basic calculator to evaluate a simple expression string.<br>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>Example 1:<br>Input: “1 + 1”<br>Output: 2<br>Example 2:</p>
<p>Input: “ 2-1 + 2 “<br>Output: 3<br>Example 3:</p>
<p>Input: “(1+(4+5+2)-3)+(6+8)”<br>Output: 23<br>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        num, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">                ans += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&quot;+&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(ans)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                ans = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                ans += sign * num</span><br><span class="line">                ans *= stack.pop()</span><br><span class="line">                ans += stack.pop()</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans + sign * num</span><br></pre></td></tr></table></figure>
<p>面经：Cruise …num = 0…ans = 0; sign = 1…num = 0…</p>
<h3 id="227-Basic-Calculator-II-Medium"><a href="#227-Basic-Calculator-II-Medium" class="headerlink" title="227. Basic Calculator II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II (Medium)</a></h3><p>Implement a basic calculator to evaluate a simple expression string.<br>The expression string contains only non-negative integers, +, -, * , / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>Example 1:<br>Input: “3+2*2”<br>Output: 7<br>Example 2:</p>
<p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p>
<p>Input: “ 3+5 / 2 “<br>Output: 5</p>
<p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        operator = <span class="string">&quot;+&quot;</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> s[i].isdigit() <span class="keyword">and</span> s[i] != <span class="string">&quot; &quot;</span>) <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> operator == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> operator == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> operator == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    stack.append(stack.pop() * num)</span><br><span class="line">                <span class="keyword">elif</span> operator == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop() / num))</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                operator = s[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<p>面经：Cruise。符号或操作符均是在最后变化。因为要处理最后一个字符的问题，所以要么两个if，要么得在s后面跟一个“+”</p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><h3 id="LinC-642-Moving-Average-from-Data-Stream-Easy"><a href="#LinC-642-Moving-Average-from-Data-Stream-Easy" class="headerlink" title="LinC 642. Moving Average from Data Stream (Easy)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/moving-average-from-data-stream/description">LinC 642. Moving Average from Data Stream (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1 // return 1.00000</span><br><span class="line">m.next(10) = (1 + 10) / 2 // return 5.50000</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3 // return 4.66667</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3 // return 6.00000</span><br></pre></td></tr></table></figure>
<p>思路：建个 window size 的队列，返回队列的平均值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    maxLen = <span class="number">0</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: size: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.maxLen = size</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: val: An integer</span></span><br><span class="line"><span class="string">    @return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        self.q.append(val)</span><br><span class="line">        self.<span class="built_in">sum</span> += val</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.q) &gt; self.maxLen:</span><br><span class="line">            temp = self.q.popleft()</span><br><span class="line">            self.<span class="built_in">sum</span> -= temp</span><br><span class="line">        avg = self.<span class="built_in">sum</span> / <span class="built_in">len</span>(self.q)</span><br><span class="line">        <span class="keyword">return</span> avg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MovingAverage(size)</span></span><br><span class="line"><span class="comment"># param = obj.next(val)</span></span><br></pre></td></tr></table></figure>
<p>总结：注意 class 变量要加 self，另外 sum 不要每次都 loop 一遍算， 直接放到 class 变量里，每次只增 and / or 减一次。</p>
<h2 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash 哈希表"></a>Hash 哈希表</h2><h3 id="290-Word-Pattern-Easy"><a href="#290-Word-Pattern-Easy" class="headerlink" title="290. Word Pattern (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-pattern/description/">290. Word Pattern (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given a pattern and a string str, find if str follows the same pattern.</span><br><span class="line"></span><br><span class="line">Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">Output: false</span><br><span class="line">Notes:</span><br><span class="line">You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</span><br></pre></td></tr></table></figure>
<p>思路：关键在于懂得建立 pattern 里每个字母和 str 里每个 word 的映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern, <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        words = <span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) != <span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(pattern):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">                <span class="keyword">if</span> mapping[char] != words[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> words[i] <span class="keyword">in</span> mapping.values():</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                mapping[char] = words[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>总结：注意需要用 enumerate， 因为要同时遍历 pattern 和 str. 很好的哈希表热身题。Word Pattern II 的 str 里没有空格了，不能直接 split，难度直接推到 Hard。目前刷题的水平先跳过吧 :(</p>
<h3 id="387-First-Unique-Character-in-a-String-Easy"><a href="#387-First-Unique-Character-in-a-String-Easy" class="headerlink" title="387. First Unique Character in a String (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-unique-character-in-a-string/description/">387. First Unique Character in a String (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a string, find the first non-repeating character in it and return it&#x27;s index. If it doesn&#x27;t exist, return -1.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br><span class="line">Note: You may assume the string contain only lowercase letters.</span><br></pre></td></tr></table></figure>
<p>思路：过两遍，第一遍数出现多少次， 第二遍把第一个为 1 的 index 返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                <span class="built_in">dict</span>[char] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">dict</span>[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">dict</span>[char] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>总结：基本题，注意 dict entry 初始化为 1 的情况</p>
<h3 id="409-Longest-Palindrome-Easy"><a href="#409-Longest-Palindrome-Easy" class="headerlink" title="409. Longest Palindrome (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindrome/description/">409. Longest Palindrome (Easy)</a></h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.<br>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>
<p>Example:<br>Input:<br>“abccccdd”<br>Output:<br>7</p>
<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        counter = Counter(s)</span><br><span class="line">        <span class="keyword">for</span> c, v <span class="keyword">in</span> counter.items():</span><br><span class="line">            <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> ans % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ans += v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += v - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。去掉了一刷二刷的hashmap和dp解法。就用简单好懂的解法吧</p>
<h3 id="380-Insert-Delete-GetRandom-O-1-Medium"><a href="#380-Insert-Delete-GetRandom-O-1-Medium" class="headerlink" title="380. Insert Delete GetRandom O(1) (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/">380. Insert Delete GetRandom O(1) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Design a data structure that supports all following operations in average O(1) time.</span><br><span class="line"></span><br><span class="line">insert(val): Inserts an item val to the set if not already present.</span><br><span class="line">remove(val): Removes an item val from the set if present.</span><br><span class="line">getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>
<p>思路：看答案知道需要用 list 和 dictionary，因为要满足 O(1), 因为仅有 list 的 in 操作不能满足 O(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">list</span> = []</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.<span class="built_in">list</span>.append(val)</span><br><span class="line">            self.<span class="built_in">dict</span>[val] = <span class="built_in">len</span>(self.<span class="built_in">list</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            index, lastVal = self.<span class="built_in">dict</span>[val], self.<span class="built_in">list</span>[<span class="built_in">len</span>(self.<span class="built_in">list</span>) - <span class="number">1</span>]</span><br><span class="line">            self.<span class="built_in">list</span>[index], self.<span class="built_in">dict</span>[lastVal] = lastVal, index</span><br><span class="line">            self.<span class="built_in">list</span>.pop()</span><br><span class="line">            self.<span class="built_in">dict</span>.pop(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">list</span>[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.<span class="built_in">list</span>) - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RandomizedSet()</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>
<p>总结：可能是用 python 的原因，搞明白问什么了一次过</p>
<h3 id="LinC-960-First-Unique-Number-in-a-Stream-II-Medium-960-First-Unique-Number-in-a-Stream-II"><a href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium-960-First-Unique-Number-in-a-Stream-II" class="headerlink" title="[LinC 960. First Unique Number in a Stream II (Medium)](960. First Unique Number in a Stream II)"></a>[LinC 960. First Unique Number in a Stream II (Medium)](960. First Unique Number in a Stream II)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">We need to implement a data structure named DataStream. There are two methods required to be implemented:</span><br><span class="line"></span><br><span class="line">void add(number) // add a new number</span><br><span class="line">int firstUnique() // return first unique number</span><br><span class="line">You can assume that there must be at least one unique number in the stream when calling the firstUnique.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">add(1)</span><br><span class="line">add(2)</span><br><span class="line">firstUnique() =&gt; 1</span><br><span class="line">add(1)</span><br><span class="line">firstUnique() =&gt; 2</span><br></pre></td></tr></table></figure>
<p>思路：维持一个 deque / queue，碰到相同的就 popleft 出去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStream</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>():</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.q = collections.deque()</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param num: next number in stream</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            self.<span class="built_in">dict</span>[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.<span class="built_in">dict</span>[num] = <span class="number">1</span></span><br><span class="line">            self.q.append(num)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @return: the first unique number in stream</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUnique</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.q) &gt; <span class="number">0</span> <span class="keyword">and</span> self.<span class="built_in">dict</span>[self.q[<span class="number">0</span>]] &gt; <span class="number">1</span>:</span><br><span class="line">                self.q.popleft()</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>总结：1.popleft 要在 firstUnique 里面，不然有些 testcase 过不了；2.注意 popleft 的条件要用 while， 用 for 会出错</p>
<h3 id="49-Group-Anagrams-Medium"><a href="#49-Group-Anagrams-Medium" class="headerlink" title="49. Group Anagrams (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/group-anagrams/">49. Group Anagrams (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given an array of strings, group anagrams together.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All inputs will be in lowercase.</span><br><span class="line">The order of your output does not matter.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        d = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            tmps = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(s))</span><br><span class="line">            d[tmps].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<p>总结：sorted(s)返回一个char list，“”.join(list)将这个list拼回字符串。list(d.values())可返回defaultdict的值</p>
<h3 id="953-Verifying-an-Alien-Dictionary-Easy"><a href="#953-Verifying-an-Alien-Dictionary-Easy" class="headerlink" title="953. Verifying an Alien Dictionary (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/verifying-an-alien-dictionary/">953. Verifying an Alien Dictionary (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.</span><br><span class="line"></span><br><span class="line">Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &#x27;h&#x27; comes before &#x27;l&#x27; in this language, then the sequence is sorted.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &#x27;d&#x27; comes after &#x27;l&#x27; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#x27;l&#x27; &gt; &#x27;∅&#x27;, where &#x27;∅&#x27; is defined as the blank character which is less than any other character (More info).</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= words.length &lt;= 100</span><br><span class="line">1 &lt;= words[i].length &lt;= 20</span><br><span class="line">order.length == 26</span><br><span class="line">All characters in words[i] and order are English lowercase letters.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span>(<span class="params">self, words: List[<span class="built_in">str</span>], order: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        d = &#123;v:i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(order)&#125;</span><br><span class="line">        <span class="keyword">for</span> w1, w2 <span class="keyword">in</span> <span class="built_in">zip</span>(words, words[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(w1, w2):</span><br><span class="line">                <span class="keyword">if</span> d[c1] &lt; d[c2]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> d[c1] &gt; d[c2]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> w1[:<span class="built_in">len</span>(w2)] == w2 <span class="keyword">and</span> <span class="built_in">len</span>(w1) &gt; <span class="built_in">len</span>(w2):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Heap-Priority-Queue"><a href="#Heap-Priority-Queue" class="headerlink" title="Heap (Priority Queue)"></a>Heap (Priority Queue)</h2><h3 id="264-Ugly-Number-II-Medium"><a href="#264-Ugly-Number-II-Medium" class="headerlink" title="264. Ugly Number II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ugly-number-ii/description/">264. Ugly Number II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Write a program to find the n-th ugly number.</span><br><span class="line"></span><br><span class="line">Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">1 is typically treated as an ugly number.</span><br><span class="line">n does not exceed 1690.</span><br></pre></td></tr></table></figure>
<p>思路：九章的 python 答案可以 work，但是实在是不好理解。写个好理解一点的版本。heapq 和 hashMap, 从 heapq 中取 n - 1 次（第一个数为 1），每取一次将原始 ugly numbers 2, 3, 5 过一遍</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        q = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        hashMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            hashMap[q[i]] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            ans = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                new_val = ans * primes[j]</span><br><span class="line">                <span class="keyword">if</span> new_val <span class="keyword">not</span> <span class="keyword">in</span> hashMap:</span><br><span class="line">                    heapq.heappush(q, new_val)</span><br><span class="line">                    hashMap[new_val] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：可以 AC，也可以理解，good enough<br>二刷：其实是道dp题，用set和heapq也能过，但是时间上没有优势</p>
<h3 id="973-K-Closest-Points-to-Origin-Medium"><a href="#973-K-Closest-Points-to-Origin-Medium" class="headerlink" title="973. K Closest Points to Origin (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin (Medium)</a></h3><p>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).<br>(Here, the distance between two points on a plane is the Euclidean distance.)<br>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p>Example 1:<br>Input: points = [[1,3],[-2,2]], K = 1<br>Output: [[-2,2]]<br>Explanation:<br>The distance between (1, 3) and the origin is sqrt(10).<br>The distance between (-2, 2) and the origin is sqrt(8).<br>Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.<br>We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</p>
<p>Example 2:<br>Input: points = [[3,3],[5,-1],[-2,4]], K = 2<br>Output: [[3,3],[-2,4]]<br>(The answer [[-2,4],[3,3]] would also be accepted.)</p>
<p>Note:<br>1 &lt;= K &lt;= points.length &lt;= 10000<br>-10000 &lt; points[i][0] &lt; 10000<br>-10000 &lt; points[i][1] &lt; 10000</p>
<p>O(nlogn):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> p: p[<span class="number">0</span>] ** <span class="number">2</span> + p[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> points[:k]]</span><br></pre></td></tr></table></figure>
<p>O(nlogk):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        pq = []</span><br><span class="line">        <span class="keyword">for</span> [x, y] <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pq) &lt; k:</span><br><span class="line">                heapq.heappush(pq, (- x * x - y * y, x, y))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappushpop(pq, (- x * x - y * y, x, y))</span><br><span class="line">        <span class="keyword">return</span> [[x, y] <span class="keyword">for</span> v, x, y <span class="keyword">in</span> pq]</span><br></pre></td></tr></table></figure>
<p>O(n) on average:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">qs</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; r:</span><br><span class="line">                p = partition(l, r)</span><br><span class="line">                <span class="keyword">if</span> p == k:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> p &lt; k:</span><br><span class="line">                    qs(p + <span class="number">1</span>, r)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    qs(l, p - <span class="number">1</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            p = random.randint(l, r)</span><br><span class="line">            points[p], points[r] = points[r], points[p]</span><br><span class="line">            c = l</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">                <span class="keyword">if</span> points[i][<span class="number">0</span>] ** <span class="number">2</span> + points[i][<span class="number">1</span>] ** <span class="number">2</span> &lt; points[r][<span class="number">0</span>] ** <span class="number">2</span> + points[r][<span class="number">1</span>] ** <span class="number">2</span>:</span><br><span class="line">                    points[i], points[c] = points[c], points[i]</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">            points[c], points[r] = points[r], points[c]</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">        qs(<span class="number">0</span>, <span class="built_in">len</span>(points) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br></pre></td></tr></table></figure>
<p>2刷，面经：Amazon。</p>
<h3 id="LinC-545-Top-k-Largest-Numbers-II-Medium"><a href="#LinC-545-Top-k-Largest-Numbers-II-Medium" class="headerlink" title="LinC 545. Top k Largest Numbers II (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/top-k-largest-numbers-ii/description">LinC 545. Top k Largest Numbers II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Implement a data structure, provide two interfaces:</span><br><span class="line">add(number). Add a new number in the data structure.</span><br><span class="line">topk(). Return the top k largest numbers in this data structure. k is given when we create the data structure.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">s = new Solution(3);</span><br><span class="line">&gt;&gt; create a new data structure.</span><br><span class="line">s.add(3)</span><br><span class="line">s.add(10)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [10, 3]</span><br><span class="line">s.add(1000)</span><br><span class="line">s.add(-99)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 10, 3]</span><br><span class="line">s.add(4)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 10, 4]</span><br><span class="line">s.add(100)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 100, 10]</span><br></pre></td></tr></table></figure>
<p>思路：看着是非常直观的 min heap 问题。。。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: k: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.q = []</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: num: Number to be added</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heappush(self.q, num)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.q) &gt; self.k:</span><br><span class="line">            heapq.heappop(self.q)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @return: Top k element</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(self.q, reverse = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>总结：一句 sorted(self.q, reverse = True) 完爆。。。哎， python 的 buit-in function 返回一个 sorted new list…学习了。</p>
<h3 id="LinC-486-Merge-K-Sorted-Arrays-Medium"><a href="#LinC-486-Merge-K-Sorted-Arrays-Medium" class="headerlink" title="LinC 486. Merge K Sorted Arrays (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/merge-k-sorted-arrays/description">LinC 486. Merge K Sorted Arrays (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given k sorted integer arrays, merge them into one sorted array.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given 3 sorted arrays:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1, 3, 5, 7],</span><br><span class="line">  [2, 4, 6],</span><br><span class="line">  [0, 8, 9, 10, 11]</span><br><span class="line">]</span><br><span class="line">return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">Do it in O(N log k).</span><br><span class="line"></span><br><span class="line">N is the total number of integers.</span><br><span class="line">k is the number of arrays.</span><br></pre></td></tr></table></figure>
<p>思路：看答案，用 heap 屌爆了。加了链接到上面 heap 的部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param arrays: k sorted integer arrays</span></span><br><span class="line"><span class="string">    @return: a sorted array</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergekSortedArrays</span>(<span class="params">self, arrays</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">for</span> level, array <span class="keyword">in</span> <span class="built_in">enumerate</span>(arrays):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(q, (array[<span class="number">0</span>], level, <span class="number">0</span>))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur, level, index = heapq.heappop(q)</span><br><span class="line">            ans.append(cur)</span><br><span class="line">            <span class="keyword">if</span> index + <span class="number">1</span> &lt; <span class="built_in">len</span>(arrays[level]):</span><br><span class="line">                heapq.heappush(q, (arrays[level][index + <span class="number">1</span>], level, index + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>总结：只能说 python 的 heapq 屌爆了</p>
<h3 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/description/">23. Merge k Sorted Lists (Hard)</a></h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<p>PriorityQueue:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(lists):</span><br><span class="line">            <span class="keyword">if</span> n:</span><br><span class="line">                heapq.heappush(h, (n.val, i, n))</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            v, i, n = heapq.heappop(h)</span><br><span class="line">            cur.<span class="built_in">next</span> = n</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> n.<span class="built_in">next</span>:</span><br><span class="line">                heapq.heappush(h, (n.<span class="built_in">next</span>.val, i, n.<span class="built_in">next</span>))</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>分治：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        n = <span class="built_in">len</span>(lists)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        l = self.mergeKLists(lists[:mid])</span><br><span class="line">        r = self.mergeKLists(lists[mid:])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">                <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">                    cur.<span class="built_in">next</span> = l</span><br><span class="line">                    l = l.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span> = r</span><br><span class="line">                    r = r.<span class="built_in">next</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = l <span class="keyword">if</span> <span class="keyword">not</span> r <span class="keyword">else</span> r</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> merge(l, r)</span><br></pre></td></tr></table></figure>
<p>三种方法，都需要练习. 方法一:使用 PriorityQueue 方法二:类似归并排序的分治算法 方法三:自底向上的两两归并算法. 时间复杂度均为 O(NlogK) Strong Hire: 能够用至少2种方法进行实现，代码无大 BUG<br>高频：如果不能加<strong>lt</strong>()，就用(n.val, i, n)tuple防v.val重复的。<br>todo 把缺的第三种方法补了</p>
<h3 id="295-Find-Median-from-Data-Stream-Hard"><a href="#295-Find-Median-from-Data-Stream-Hard" class="headerlink" title="295. Find Median from Data Stream (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream (Hard)</a></h3><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>For example,<br>[2,3,4], the median is 3<br>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Design a data structure that supports the following two operations:<br>void addNum(int num) - Add a integer number from the data stream to the data structure.<br>double findMedian() - Return the median of all elements so far.</p>
<p>Example:<br>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p>
<p>Follow up:<br>If all integer numbers from the stream are between 0 and 100, how would you optimize it?<br>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.upper = []</span><br><span class="line">        self.lower = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.upper) == <span class="built_in">len</span>(self.lower):</span><br><span class="line">            heapq.heappush(self.upper, -heapq.heappushpop(self.lower, -num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.lower, -heapq.heappushpop(self.upper, num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.upper) == <span class="built_in">len</span>(self.lower):</span><br><span class="line">            <span class="keyword">return</span> self.upper[<span class="number">0</span>] * <span class="number">0.5</span> - self.lower[<span class="number">0</span>] * <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(self.upper[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>面经：Amazon，maxheap + minheap，lower要用负数来模拟maxheap。 注意:…heapq.heappushpop(lower, <strong>-num</strong>)…</p>
<h3 id="743-Network-Delay-Time-Medium"><a href="#743-Network-Delay-Time-Medium" class="headerlink" title="743. Network Delay Time (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/network-delay-time/">743. Network Delay Time (Medium)</a></h3><p>There are N network nodes, labelled 1 to N.<br>Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.<br>Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.<br><img src="https://i.imgur.com/e6P0mDW.png" alt="network example"><br>Example 1:<br>Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2<br>Output: 2<br>Note:<br>N will be in the range [1, 100].<br>K will be in the range [1, N].<br>The length of times will be in the range [1, 6000].<br>All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 0 &lt;= w &lt;= 100.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span>(<span class="params">self, times: List[List[<span class="built_in">int</span>]], N: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        graph = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</span><br><span class="line">            graph[u - <span class="number">1</span>][v - <span class="number">1</span>] = w</span><br><span class="line">        distances = [sys.maxsize] * N</span><br><span class="line">        distances[K - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        pq = [(<span class="number">0</span>, K - <span class="number">1</span>)]</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            dist, v1 = heapq.heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> v1 <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(v1)</span><br><span class="line">                <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                    <span class="keyword">if</span> v2 <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        prev = distances[v2]</span><br><span class="line">                        cur = dist + graph[v1][v2]</span><br><span class="line">                        <span class="keyword">if</span> cur &lt; prev:</span><br><span class="line">                            distances[v2] = cur</span><br><span class="line">                            heapq.heappush(pq, (cur, v2))</span><br><span class="line">        ans = <span class="built_in">max</span>(distances)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans == sys.maxsize <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：练习某家小公司的OA，Dijkstra Graph 最短路径，Dijkstra有很多变种问题，不同写法。</p>
<h3 id="787-Cheapest-Flights-Within-K-Stops-Medium"><a href="#787-Cheapest-Flights-Within-K-Stops-Medium" class="headerlink" title="787. Cheapest Flights Within K Stops (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">787. Cheapest Flights Within K Stops (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.</span><br><span class="line"></span><br><span class="line">Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 1</span><br><span class="line">Output: 200</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line"></span><br><span class="line">The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.</span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 0</span><br><span class="line">Output: 500</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line"></span><br><span class="line">The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.</span><br><span class="line">The size of flights will be in range [0, n * (n - 1) / 2].</span><br><span class="line">The format of each flight will be (src, dst, price).</span><br><span class="line">The price of each flight will be in the range [1, 10000].</span><br><span class="line">k is in the range of [0, n - 1].</span><br><span class="line">There will not be any duplicated flights or self cycles.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">self, n: <span class="built_in">int</span>, flights: List[List[<span class="built_in">int</span>]], src: <span class="built_in">int</span>, dst: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        graph = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> flights:</span><br><span class="line">            graph[u][v] = w</span><br><span class="line">        costs = [sys.maxsize] * n</span><br><span class="line">        costs[src] = <span class="number">0</span></span><br><span class="line">        pq = [(<span class="number">0</span>,  src, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            <span class="keyword">import</span> heapq</span><br><span class="line">            cost, v1, stop = heapq.heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> stop - <span class="number">1</span> &lt;= K:</span><br><span class="line">                <span class="keyword">if</span> v1 == dst:</span><br><span class="line">                    <span class="keyword">return</span> cost</span><br><span class="line">                <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                    pre = costs[v2]</span><br><span class="line">                    cur = cost + graph[v1][v2]</span><br><span class="line">                    <span class="keyword">if</span> cur &lt; pre:</span><br><span class="line">                        heapq.heappush(pq, (cur, v2, stop + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>面经：与上题不同之处是这里问的不是全局最优，而是符合条件的最优，同一个点可能需要重复访问才能找到符合条件的最优，因此无需seen这个set</p>
<h3 id="855-Exam-Room-Medium"><a href="#855-Exam-Room-Medium" class="headerlink" title="855. Exam Room (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/exam-room/">855. Exam Room (Medium)</a></h3><p>In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.<br>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)<br>Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.</p>
<p>Example 1:<br>Input: [“ExamRoom”,”seat”,”seat”,”seat”,”seat”,”leave”,”seat”], [[10],[],[],[],[],[4],[]]<br>Output: [null,0,9,4,2,null,5]<br>Explanation:<br>ExamRoom(10) -&gt; null<br>seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.<br>seat() -&gt; 9, the student sits at the last seat number 9.<br>seat() -&gt; 4, the student sits at the last seat number 4.<br>seat() -&gt; 2, the student sits at the last seat number 2.<br>leave(4) -&gt; null<br>seat() -&gt; 5, the student sits at the last seat number 5.</p>
<p>Note:<br>1 &lt;= N &lt;= 10^9<br>ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.<br>Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.N = N</span><br><span class="line">        self.L = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seat</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.L:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d, res = self.L[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(self.L, self.L[<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">if</span> (y - x) // <span class="number">2</span> &gt; d:</span><br><span class="line">                    d = (y - x) // <span class="number">2</span></span><br><span class="line">                    res = x + (y - x) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.N - <span class="number">1</span> - self.L[-<span class="number">1</span>] &gt; d:</span><br><span class="line">                res = self.N - <span class="number">1</span></span><br><span class="line">        bisect.insort(self.L, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leave</span>(<span class="params">self, p: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.L.remove(p)</span><br></pre></td></tr></table></figure>
<p>面经： Cruise。正常思路是得用PriorityQueue。但是corner case写不出来，讨论区答案里java用个特殊的数据结构搭配pq，加上一个trick，不适合模板解题。…if <strong>y - x // 2</strong> &gt; d:…if <strong>self.N - 1 - self.L[-1]</strong> &gt; d: res = self.N - 1…bisect.<strong>insort</strong>(…)…</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="208-Implement-Trie-Prefix-Tree-Medium"><a href="#208-Implement-Trie-Prefix-Tree-Medium" class="headerlink" title="208. Implement Trie (Prefix Tree) (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">208. Implement Trie (Prefix Tree) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Implement a trie with insert, search, and startsWith methods.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // returns true</span><br><span class="line">trie.search(&quot;app&quot;);     // returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // returns true</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // returns true</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You may assume that all inputs are consist of lowercase letters a-z.</span><br><span class="line">All inputs are guaranteed to be non-empty strings.</span><br></pre></td></tr></table></figure>
<p>思路：没啥思路，看答案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="comment"># Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.word=<span class="literal">False</span></span><br><span class="line">        self.children=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; word</span></span><br><span class="line">    <span class="comment"># @return &#123;void&#125;</span></span><br><span class="line">    <span class="comment"># Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                node.children[i]=TrieNode()</span><br><span class="line">            node=node.children[i]</span><br><span class="line">        node.word=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; word</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="comment"># Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node=node.children[i]</span><br><span class="line">        <span class="keyword">return</span> node.word</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; prefix</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="comment"># Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment"># that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix</span>):</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node=node.children[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line">    <span class="comment"># obj = Trie()</span></span><br><span class="line">    <span class="comment"># obj.insert(word)</span></span><br><span class="line">    <span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line">    <span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>
<p>总结：1.需要加 TrieNode 2. Leetcode 的 python3 找不到 class 是个 bug</p>
<h3 id="211-Add-and-Search-Word-Data-structure-design-Medium"><a href="#211-Add-and-Search-Word-Data-structure-design-Medium" class="headerlink" title="211. Add and Search Word - Data structure design (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-and-search-word-data-structure-design/">211. Add and Search Word - Data structure design (Medium)</a></h3><p>Design a data structure that supports the following two operations:</p>
<p>void addWord(word)<br>bool search(word)<br>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>Example:</p>
<p>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt; false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”) -&gt; true<br>Note:<br>You may assume that all words are consist of lowercase letters a-z.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.end = <span class="literal">False</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds a word into the data structure.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        root = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> root.children:</span><br><span class="line">                root.children[c] = TrieNode()</span><br><span class="line">            root = root.children[c]</span><br><span class="line">        root.end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.ans = <span class="literal">False</span></span><br><span class="line">        self.helper(self.root, word)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, word</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">if</span> root.end:</span><br><span class="line">                self.ans = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> word[<span class="number">0</span>] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> root.children.values():</span><br><span class="line">                self.helper(v, word[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> word[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> root.children:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.helper(root.children[word[<span class="number">0</span>]], word[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>面经：Celo。insert:…root.end = True…</p>
<h2 id="Union-Find-MST"><a href="#Union-Find-MST" class="headerlink" title="Union Find / MST"></a>Union Find / MST</h2><h3 id="LinC-629-Minimum-Spanning-Tree-Hard"><a href="#LinC-629-Minimum-Spanning-Tree-Hard" class="headerlink" title="LinC 629. Minimum Spanning Tree (Hard)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/minimum-spanning-tree/description">LinC 629. Minimum Spanning Tree (Hard)</a></h3><p>Given a list of Connections, which is the Connection class (the city name at both ends of the edge and a cost between them), find edges that can connect all the cities and spend the least amount.<br>Return the connects if can connect all the cities, otherwise return empty list.</p>
<p>Example<br>Example 1:</p>
<p>Input:<br>[“Acity”,”Bcity”,1]<br>[“Acity”,”Ccity”,2]<br>[“Bcity”,”Ccity”,3]<br>Output:<br>[“Acity”,”Bcity”,1]<br>[“Acity”,”Ccity”,2]<br>Example 2:</p>
<p>Input:<br>[“Acity”,”Bcity”,2]<br>[“Bcity”,”Dcity”,5]<br>[“Acity”,”Dcity”,4]<br>[“Ccity”,”Ecity”,1]<br>Output:<br>[]</p>
<p>Explanation:<br>No way<br>Notice<br>Return the connections sorted by the cost, or sorted city1 name if their cost is same, or sorted city2 if their city1 name is also same.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Definition for a Connection</span></span><br><span class="line"><span class="string">class Connection:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, city1, city2, cost):</span></span><br><span class="line"><span class="string">        self.city1, self.city2, self.cost = city1, city2, cost</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.size = n</span><br><span class="line">        self.graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.graph[i] = i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, v1, v2</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.find(v1) == self.find(v2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, v</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.graph[v] == v:</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        self.graph[v] = self.find(self.graph[v])</span><br><span class="line">        <span class="keyword">return</span> self.graph[v]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, v1, v2</span>):</span></span><br><span class="line">        root_a = self.find(v1)</span><br><span class="line">        root_b = self.find(v2)</span><br><span class="line">        <span class="keyword">if</span> root_a != root_b:</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">            self.graph[root_a] = self.graph[root_b]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_connected</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;Connection[]&#125; connections given a list of connections</span></span><br><span class="line">    <span class="comment"># include two cities and cost</span></span><br><span class="line">    <span class="comment"># @return &#123;Connection[]&#125; a list of connections from results</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCost</span>(<span class="params">self, connections</span>):</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        connections.sort(key = <span class="keyword">lambda</span> x: x.city2)</span><br><span class="line">        connections.sort(key = <span class="keyword">lambda</span> x: x.city1)</span><br><span class="line">        connections.sort(key = <span class="keyword">lambda</span> x: x.cost)</span><br><span class="line">        citymap = &#123;&#125;</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> connections:</span><br><span class="line">            <span class="keyword">if</span> c.city1 <span class="keyword">not</span> <span class="keyword">in</span> citymap:</span><br><span class="line">                citymap[c.city1] = cnt</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c.city2 <span class="keyword">not</span> <span class="keyword">in</span> citymap:</span><br><span class="line">                citymap[c.city2] = cnt</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        union = Union(cnt)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> connections:</span><br><span class="line">            c1 = citymap[c.city1]</span><br><span class="line">            c2 = citymap[c.city2]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> union.query(c1, c2):</span><br><span class="line">                union.connect(c1, c2)</span><br><span class="line">                ans.append(c)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> union.all_connected() <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。</p>
<h1 id="DP-Dynamic-Programming-动态规划"><a href="#DP-Dynamic-Programming-动态规划" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h1><h3 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/description/">70. Climbing Stairs (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">You are climbing a stair case. It takes n steps to reach to the top.</span><br><span class="line"></span><br><span class="line">Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</span><br><span class="line"></span><br><span class="line">Note: Given n will be a positive integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<p>思路：f[n] 是为 n 时的方案数，f[1] 是为 1 时的方案数 = 1。<strong>那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的</strong>，所以递推公式非常容易的就得出了：f[n] = f[n - 1] + f[n - 2]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<p>总结：和三年前比没有变化，呵呵呵<br>高频：没有太多优化空间，背：爬到第n层的方法要么是从第n-1层1步上来的，要不就是从n-2层2步上来的</p>
<h3 id="120-Triangle-Medium"><a href="#120-Triangle-Medium" class="headerlink" title="120. Triangle (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/description/">120. Triangle (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</span><br><span class="line"></span><br><span class="line">For example, given the following triangle</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</span><br></pre></td></tr></table></figure>
<p>思路：看了 top down 的 DP， 还是比较好理解的。f 代表到达 row 和 col 位置的最小 sum，f[i][j] 和 f[i - 1][j - 1] 的关系是：f[i][j] = mins(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]. 规划的目标是最后一行中的最小值。；DP 以外还有三种解法，DFS：Traverse， DFS：Divide and Conquer， DFS：Divide and Conquer 加 memorization</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(triangle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(triangle) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        f = []</span><br><span class="line">        f.append([triangle[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            f.append([<span class="number">0</span>] * (i + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">                f[row][col] = <span class="built_in">min</span>(f[row - <span class="number">1</span>][col - <span class="number">1</span>], f[row - <span class="number">1</span>][col]) + triangle[row][col]</span><br><span class="line">        ans = f[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, f[n - <span class="number">1</span>][i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        f = [[<span class="number">0</span>] * (i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == i:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(f[n - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>bottom up:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        f = [[<span class="number">0</span>] * (i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        f[n - <span class="number">1</span>] = triangle[-<span class="number">1</span>][:]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(r + <span class="number">1</span>):</span><br><span class="line">                f[r][c] = <span class="built_in">min</span>(f[r + <span class="number">1</span>][c], f[r + <span class="number">1</span>][c + <span class="number">1</span>]) + triangle[r][c]</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>总结：填充 f 每行第一个和最后一个的时候别忘了 + triangle[i][0] 和 triangle[i][i]<br>高频：注意topdown：下一层f[i][j]的时候要根据j的情况来分类判断f的值如何获得， 一刷的时候提前把三角的两条边先初始化了，循环的时候不循环那些元素。也是个好办法。代码稍微长一点。bottomup：代码简单很多。还可以进一步将空间降为O(n)，因为之前算出来的f[r + 1][]都没用</p>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock (Easy)</a></h3><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
<p>Example 2:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<p>DP：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(prices)</span><br><span class="line">        low = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt;= prices[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">                low = <span class="built_in">min</span>(prices[i], low)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - low)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>greedy:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        low = prices[<span class="number">0</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - low)</span><br><span class="line">            low = <span class="built_in">min</span>(low, p)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频，4刷</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II (Easy)</a></h3><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<p>Example 2:<br>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频，二刷：可以无限买卖=可以抓住所有价格上升的机会，可优化为O(1)空间的算法，因为不在乎中间利润，中间利润累加上去返回</p>
<h3 id="91-Decode-Ways-Medium"><a href="#91-Decode-Ways-Medium" class="headerlink" title="91. Decode Ways (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/">91. Decode Ways (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A message containing letters from A-Z is being encoded to numbers using the following mapping:</span><br><span class="line"></span><br><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br><span class="line">Given a non-empty string containing only digits, determine the total number of ways to decode it.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            one = <span class="built_in">int</span>(s[i - <span class="number">1</span>: i])</span><br><span class="line">            two = <span class="built_in">int</span>(s[i - <span class="number">2</span>: i])</span><br><span class="line">            <span class="keyword">if</span> one &gt; <span class="number">0</span>:</span><br><span class="line">                f[i] += f[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= two &lt;= <span class="number">26</span>:</span><br><span class="line">                f[i] += f[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<p>总结：f[n]为第n个数的方案数，0个字1个方案，1个字1个方案，…if 10 &lt;= two &lt;= 26:…防止误判“05”， “06”等情况</p>
<h3 id="62-Unique-Paths-Medium"><a href="#62-Unique-Paths-Medium" class="headerlink" title="62. Unique Paths (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">62. Unique Paths (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A robot is located at the top-left corner of a m x n grid (marked &#x27;Start&#x27; in the diagram below).</span><br><span class="line"></span><br><span class="line">The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#x27;Finish&#x27; in the diagram below).</span><br><span class="line"></span><br><span class="line">How many possible unique paths are there?</span><br><span class="line"></span><br><span class="line">Above is a 7 x 3 grid. How many possible unique paths are there?</span><br><span class="line"></span><br><span class="line">Note: m and n will be at most 100.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        f = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, m + <span class="number">1</span>):</span><br><span class="line">                f[r][c] = f[r - <span class="number">1</span>][c] + f[r][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<p>高频</p>
<h3 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>高频，面经：维萨…if <strong>dp[i - 1]</strong> &lt; 0:…</p>
<h3 id="63-Unique-Paths-II-Medium"><a href="#63-Unique-Paths-II-Medium" class="headerlink" title="63. Unique Paths II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II (Medium)</a></h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br>An obstacle and empty space is marked as 1 and 0 respectively in the grid.<br>Note: m and n will be at most 100.</p>
<p>Example 1:<br>Input:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>Output: 2<br>Explanation:<br>There is one obstacle in the middle of the 3x3 grid above.<br>There are two ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Right -&gt; Down -&gt; Down</li>
<li>Down -&gt; Down -&gt; Right -&gt; Right</li>
</ol>
<p>space O(mxn):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">      m, n = <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">      dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">      obs = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(obstacleGrid[<span class="number">0</span>]):</span><br><span class="line">          <span class="keyword">if</span> v == <span class="number">1</span>:</span><br><span class="line">              obs = <span class="literal">True</span></span><br><span class="line">          <span class="keyword">if</span> obs:</span><br><span class="line">              dp[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">      obs = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">          <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">              obs = <span class="literal">True</span></span><br><span class="line">          <span class="keyword">if</span> obs:</span><br><span class="line">              dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">          <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">              <span class="keyword">if</span> obstacleGrid[r][c] == <span class="number">1</span>:</span><br><span class="line">                  dp[r][c] = <span class="number">0</span></span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  dp[r][c] = dp[r - <span class="number">1</span>][c] + dp[r][c - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>space: O(n):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        obs = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                obs = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> obs:</span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] <span class="keyword">if</span> obstacleGrid[r][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[r][c] == <span class="number">1</span>:</span><br><span class="line">                    dp[c] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[c] = dp[c - <span class="number">1</span>] + dp[c]</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频<br>面经：Celo, todo: space: O(1)</p>
<h3 id="64-Minimum-Path-Sum-Medium"><a href="#64-Minimum-Path-Sum-Medium" class="headerlink" title="64. Minimum Path Sum (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum (Medium)</a></h3><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>Example:</p>
<p>Input:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>Output: 7<br>Explanation: Because the path 1→3→1→1→1 minimizes the sum.<br>空间O(m*n):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        rl = <span class="built_in">len</span>(grid)</span><br><span class="line">        cl = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cl)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rl)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rl):</span><br><span class="line">            f[r][<span class="number">0</span>] = f[r - <span class="number">1</span>][<span class="number">0</span>] + grid[r][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cl):</span><br><span class="line">            f[<span class="number">0</span>][c] = f[<span class="number">0</span>][c - <span class="number">1</span>] + grid[<span class="number">0</span>][c]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rl):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cl):</span><br><span class="line">                f[r][c] = <span class="built_in">min</span>(f[r - <span class="number">1</span>][c], f[r][c - <span class="number">1</span>]) + grid[r][c]</span><br><span class="line">        <span class="keyword">return</span> f[rl - <span class="number">1</span>][cl - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>空间O(n):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[c] = dp[c - <span class="number">1</span>] + grid[<span class="number">0</span>][c]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp[<span class="number">0</span>] += grid[r][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[c] = <span class="built_in">min</span>(dp[c], dp[c - <span class="number">1</span>]) + grid[r][c]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：优化空间可以将二维数组f压缩为一维，因为答案不关心中间值<br>面经：Amazon。优化空间</p>
<h3 id="72-Edit-Distance-Hard"><a href="#72-Edit-Distance-Hard" class="headerlink" title="72. Edit Distance (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/">72. Edit Distance (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</span><br><span class="line"></span><br><span class="line">You have the following 3 operations permitted on a word:</span><br><span class="line"></span><br><span class="line">Insert a character</span><br><span class="line">Delete a character</span><br><span class="line">Replace a character</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">horse -&gt; rorse (replace &#x27;h&#x27; with &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (remove &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (remove &#x27;e&#x27;)</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">intention -&gt; inention (remove &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (replace &#x27;i&#x27; with &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (replace &#x27;n&#x27; with &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (replace &#x27;n&#x27; with &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (insert &#x27;u&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>高频：f 为从 m 的前 i 个变到 n 的前 j 个字符串所需的最少步骤, 第前 i 个字符串 == word1[i - 1]…if word1[i - 1] == word2[j - 1]: f[i][j] = f[i - 1][j - 1]…else: f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1]) + 1</p>
<h3 id="132-Palindrome-Partitioning-II-Hard"><a href="#132-Palindrome-Partitioning-II-Hard" class="headerlink" title="132. Palindrome Partitioning II (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning-ii/">132. Palindrome Partitioning II (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, partition s such that every substring of the partition is a palindrome.</span><br><span class="line"></span><br><span class="line">Return the minimum cuts needed for a palindrome partitioning of s.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        p = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            f[i] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i - j &lt; <span class="number">2</span> <span class="keyword">or</span> p[j + <span class="number">1</span>][i - <span class="number">1</span>]):</span><br><span class="line">                    p[j][i] = <span class="literal">True</span></span><br><span class="line">                    f[i] = <span class="number">0</span> <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">min</span>(f[i], f[j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：f为从0到i(i从0到n-1)字符串的mincut数。p为从j到i是否是回文，因为j（从0到i，i从0到n-1）可能到j+1，因此p […in range(n <strong>+ 1</strong>)]。…for j in range(i + 1):…and (i - j &lt; 2 <strong>or</strong> p[j + 1][i - 1])…</p>
<h3 id="5-Longest-Palindromic-Substring-Medium"><a href="#5-Longest-Palindromic-Substring-Medium" class="headerlink" title="5. Longest Palindromic Substring (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>Expand around center:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">aroundI</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> l + <span class="number">1</span>, r</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            l, r = aroundI(i, i)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>]:</span><br><span class="line">                ans = (l, r)</span><br><span class="line">            l, r = aroundI(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>]:</span><br><span class="line">                ans = (l, r)</span><br><span class="line">        <span class="keyword">return</span> s[ans[<span class="number">0</span>]:ans[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>dp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        f = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (j - i &lt;= <span class="number">2</span> <span class="keyword">or</span> f[i + <span class="number">1</span>][j - <span class="number">1</span>]):</span><br><span class="line">                    f[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> f[i][j] <span class="keyword">and</span> j - i &gt; y - x:</span><br><span class="line">                    x, y = i, j</span><br><span class="line">        <span class="keyword">return</span> s[x:y + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>暴力 TLE：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i:j] == s[i:j][::-<span class="number">1</span>] <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; <span class="built_in">len</span>(ans):</span><br><span class="line">                    ans = s[i:j]</span><br><span class="line">        <span class="keyword">return</span> ans      </span><br></pre></td></tr></table></figure>
<p>2刷：高频：expand around center…def aroundI(l, r):…return l + 1, r…。dp: f为从i到j是否为回文串，…for j in range(n): for i in range(j <strong>+ 1</strong>):…</p>
<h3 id="55-Jump-Game-Medium"><a href="#55-Jump-Game-Medium" class="headerlink" title="55. Jump Game (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">55. Jump Game (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given an array of non-negative integers, you are initially positioned at the first index of the array.</span><br><span class="line"></span><br><span class="line">Each element in the array represents your maximum jump length at that position.</span><br><span class="line"></span><br><span class="line">Determine if you are able to reach the last index.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>
<p>dp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> f[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>greedy:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> reach &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            reach = <span class="built_in">max</span>(reach, i + n)</span><br></pre></td></tr></table></figure>
<p>高频：dp: f为当前位置的剩余步数 f[i] = max(f[i - 1], nums[i - 1]) - 1。greedy：reach为从0点能到的最远距离</p>
<h3 id="96-Unique-Binary-Search-Trees-Medium"><a href="#96-Unique-Binary-Search-Trees-Medium" class="headerlink" title="96. Unique Binary Search Trees (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given n, how many structurally unique BST&#x27;s (binary search trees) that store values 1 ... n?</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&#x27;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                f[i] += f[j - <span class="number">1</span>] * f[i - j]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<p>高频：关键是要知道f推导公式：g[i, n]代表以i为root的bst，f[n] = g[1, n] + g[2, n] +…+ g[n, n], g[i, n] = f[i - 1] * f[n - i]。以i为root的左边是i - 1个数，右边是n - i个数，具体数值对于f方案数并不是那么重要。</p>
<h3 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees-ii/">95. Unique Binary Search Trees II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Given an integer n, generate all structurally unique BST&#x27;s (binary search trees) that store values 1 ... n.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&#x27;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">s, e</span>):</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; e: <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, e + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> gen(s, i - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> gen(i + <span class="number">1</span>, e):</span><br><span class="line">                        root = TreeNode(i)</span><br><span class="line">                        root.left = l</span><br><span class="line">                        root.right = r</span><br><span class="line">                        res.append(root)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> gen(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>
<p>高频：看着像非主流dp题。…def gen(s, e):…res = []…for l in gen(s, i <strong>- 1</strong>):…return gen(1, n)</p>
<h3 id="198-House-Robber-Easy"><a href="#198-House-Robber-Easy" class="headerlink" title="198. House Robber (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">198. House Robber (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</span><br><span class="line"></span><br><span class="line">Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class="line">             Total amount you can rob = 2 + 9 + 1 = 12.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i - <span class="number">2</span>] + nums[i], f[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：f[i]有两个决定， 一个是抢，或不抢当前的房，取max即可<br>面经：Quora。</p>
<h3 id="213-House-Robber-II-Medium"><a href="#213-House-Robber-II-Medium" class="headerlink" title="213. House Robber II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II (Medium)</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:<br>Input: [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),<br>             because they are adjacent houses.<br>Example 2:<br>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        dp1 = [<span class="number">0</span>] * n</span><br><span class="line">        dp2 = [<span class="number">0</span>] * n</span><br><span class="line">        dp1[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp1[<span class="number">1</span>] = dp1[<span class="number">0</span>]</span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n - <span class="number">1</span>):</span><br><span class="line">            dp1[i] = <span class="built_in">max</span>(dp1[i - <span class="number">1</span>], dp1[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">            dp2[i] = <span class="built_in">max</span>(dp2[i - <span class="number">1</span>], dp2[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1[n - <span class="number">2</span>], <span class="built_in">max</span>(dp2[n - <span class="number">2</span>], dp2[n - <span class="number">3</span>] + nums[n - <span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>面经：Quora。</p>
<h3 id="10-Regular-Expression-Matching-Hard"><a href="#10-Regular-Expression-Matching-Hard" class="headerlink" title="10. Regular Expression Matching (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Given an input string (s) and a pattern (p), implement regular expression matching with support for &#x27;.&#x27; and &#x27;*&#x27;.</span><br><span class="line"></span><br><span class="line">&#x27;.&#x27; Matches any single character.</span><br><span class="line">&#x27;*&#x27; Matches zero or more of the preceding element.</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">s could be empty and contains only lowercase letters a-z.</span><br><span class="line">p could be empty and contains only lowercase letters a-z, and characters like . or *.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#x27;*&#x27; means zero or more of the precedeng element, &#x27;a&#x27;. Therefore, by repeating &#x27;a&#x27; once, it becomes &quot;aa&quot;.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>DP：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        ls, lp = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (lp + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(ls + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lp):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                f[<span class="number">0</span>][j + <span class="number">1</span>] = f[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lp):</span><br><span class="line">                <span class="keyword">if</span> p[j] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> s[i] == p[j]:</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>] = f[i][j]</span><br><span class="line">                <span class="keyword">if</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] != p[j - <span class="number">1</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                        f[i + <span class="number">1</span>][j + <span class="number">1</span>] = f[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        f[i + <span class="number">1</span>][j + <span class="number">1</span>] =  f[i][j + <span class="number">1</span>] <span class="keyword">or</span> f[i + <span class="number">1</span>][j] <span class="keyword">or</span> f[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> f[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>Backtracking：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        first_matched = <span class="built_in">len</span>(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> (first_matched <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_matched <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>高频：dp:怎么写都不是很直观，目前采用range和p[],s[]取值简化写。当前p的字符位’.’或者和s当前字符相等即前进。’*‘分两种情况：1.p前一位不是’.’与当前s字符也不等，a* counts as empty 2.等或者是’.(*)’，a* counts as multiple a / a* counts as single a / a* counts as empty。时间空间复杂度均为O(ls<em>lp)<br>backtracking: 关键要用s = “aab” p = “c</em>a<em>b”来记住如果有</em>，要么忽略这部分p，要么删掉第一个匹配的字符这个算法。…if not p:…firt_matched = len(s) &gt; 0 and (s[0]…)…时间空间复杂度：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/solution/">leetcode solution</a>里有，较复杂</p>
<h3 id="44-Wildcard-Matching-Hard"><a href="#44-Wildcard-Matching-Hard" class="headerlink" title="44. Wildcard Matching (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wildcard-matching/">44. Wildcard Matching (Hard)</a></h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘<em>‘.<br>‘?’ Matches any single character.<br>‘</em>‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:<br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or * .</p>
<p>Example 1:<br>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
<p>Example 2:<br>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.</p>
<p>Example 3:<br>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.</p>
<p>Example 4:<br>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em> ‘ matches the substring “dce”.</p>
<p>Example 5:<br>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        ls, lp = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (lp + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(ls + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lp):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lp):</span><br><span class="line">                <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] <span class="keyword">or</span> dp[i + <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：和上题统一的模板，当j位置的p是’?’ 或者和i位置���s相等时，均前进…f[i + 1][j + 1] = f[i][j],当j位置是’*‘时，两种情况，* count as multiple char / * count as single char …f[i + 1][j + 1] = f[i][j + 1] or f[i + 1][j]…<br>面经：Quora。</p>
<h3 id="139-Word-Break-Medium"><a href="#139-Word-Break-Medium" class="headerlink" title="139. Word Break (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break/">139. Word Break (Medium)</a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:<br>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.</p>
<p>Example 1:<br>Input: s = “leetcode”, wordDict = [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.</p>
<p>Example 2:<br>Input: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br>             Note that you are allowed to reuse a dictionary word.<br>Example 3:<br>Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false<br>从当前位置往前找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s, wordDict</span>):</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[j:i + <span class="number">1</span>] <span class="keyword">in</span> wordDict <span class="keyword">and</span> dp[j]:</span><br><span class="line">                    dp[i + <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>面经：Amazon，维萨。删掉了之前的解法，这个解法更适合现场想</p>
<h3 id="377-Combination-Sum-IV-Medium"><a href="#377-Combination-Sum-IV-Medium" class="headerlink" title="377. Combination Sum IV (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV (Medium)</a></h3><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p>Example:<br>nums = [1, 2, 3]<br>target = 4</p>
<p>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>Note that different sequences are counted as different combinations.<br>Therefore the output is 7.</p>
<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?<br>memo[4] = memo[4 - 1] + memo[4 - 3] + memo[4 - 1]的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        memo = [-<span class="number">1</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, target, memo)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, target, memo</span>):</span></span><br><span class="line">        <span class="keyword">if</span> memo[target] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[target]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[i]:</span><br><span class="line">                cnt += self.helper(nums, target - nums[i], memo)</span><br><span class="line">        memo[target] = cnt</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>稍微DFS一点的模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(nums, target, &#123;&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, nums, target, memo</span>):</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[target]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[i]:</span><br><span class="line">                res += self.dfs(nums, target - nums[i], memo)</span><br><span class="line">        memo[target] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。</p>
<h3 id="152-Maximum-Product-Subarray-Medium"><a href="#152-Maximum-Product-Subarray-Medium" class="headerlink" title="152. Maximum Product Subarray (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray (Medium)</a></h3><p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:<br>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.</p>
<p>Example 2:<br>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        dpMin = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dpMax = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = dpMin[<span class="number">0</span>] = dpMax[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dpMin[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(dpMin[i - <span class="number">1</span>] * nums[i], dpMax[i - <span class="number">1</span>] * nums[i]), nums[i])</span><br><span class="line">            dpMax[i] = <span class="built_in">max</span>(<span class="built_in">max</span>(dpMin[i - <span class="number">1</span>] * nums[i], dpMax[i - <span class="number">1</span>] * nums[i]), nums[i])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpMax[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>O(1)空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        ans = preMin = preMax = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            dpMin = <span class="built_in">min</span>(preMin * v, preMax * v, v)</span><br><span class="line">            dpMax = <span class="built_in">max</span>(preMin * v, preMax * v, v)</span><br><span class="line">            preMin, preMax = dpMin, dpMax</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpMax)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经： 维萨。核心是要保存当前最大和最小值，因为最小值随时可能乘出最大值。 优化是用O(1)空间， 因为仅需要中途算出来的最大值</p>
<h3 id="516-Longest-Palindromic-Subsequence-Medium"><a href="#516-Longest-Palindromic-Subsequence-Medium" class="headerlink" title="516. Longest Palindromic Subsequence (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-subsequence/">516. Longest Palindromic Subsequence (Medium)</a></h3><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:<br>“bbbab”<br>Output:<br>4<br>One possible longest palindromic subsequence is “bbbb”.</p>
<p>Example 2:<br>Input:<br>“cbbd”<br>Output:<br>2<br>One possible longest palindromic subsequence is “bb”.</p>
<p>brute force recursion O(2^n) worst case TLE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>, s)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, l, r, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> + self.helper(l + <span class="number">1</span>, r - <span class="number">1</span>, s) <span class="keyword">if</span> s[l] == s[r] <span class="keyword">else</span> <span class="built_in">max</span>(self.helper(l + <span class="number">1</span>, r, s), self.helper(l, r - <span class="number">1</span>, s))</span><br></pre></td></tr></table></figure>
<p>add memo time complexity to O(n^2):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>, s, &#123;&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, l, r, s, memo</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (l, r) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(l, r)]</span><br><span class="line">        memo[(l, r)] = <span class="number">2</span> + self.helper(l + <span class="number">1</span>, r - <span class="number">1</span>, s, memo) <span class="keyword">if</span> s[l] == s[r] <span class="keyword">else</span> <span class="built_in">max</span>(self.helper(l + <span class="number">1</span>, r, s, memo), self.helper(l, r - <span class="number">1</span>, s, memo))</span><br><span class="line">        <span class="keyword">return</span> memo[(l, r)]</span><br></pre></td></tr></table></figure>
<p>dp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>面经：维萨<br>Subsequence is not substring. Every sub string is a sub sequence<br>e.g. leetcode<br>Both substring and subsequence leet, code<br>Sub sequence ltcode, eecode, ecode, ltde // and not substring<br>dp：从 i 到 j， dp[i][i] = 1, i从最后一个开始，j从i+1开始，构建斜上半个dpmatrix, 如果s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</p>
<h3 id="300-Longest-Increasing-Subsequence-Medium"><a href="#300-Longest-Increasing-Subsequence-Medium" class="headerlink" title="300. Longest Increasing Subsequence (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence (Medium)</a></h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:<br>Input: [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.<br>Note:</p>
<p>There may be more than one LIS combination, it is only necessary for you to return the length.<br>Your algorithm should run in O(n2) complexity.<br>Follow up: Could you improve it to O(n log n) time complexity?</p>
<p>Bruteforce O(2^n), TLE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, -sys.maxsize, <span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, prev, idx</span>):</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        take = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> prev &lt; nums[idx]:</span><br><span class="line">            take = <span class="number">1</span> + self.helper(nums, nums[idx], idx + <span class="number">1</span>)</span><br><span class="line">        notake = self.helper(nums, prev, idx + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(take, notake)</span><br></pre></td></tr></table></figure>
<p>DP: O(n^2):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fV-TF4OvZpk">这个youtube视频讲的不错</a></p>
<h3 id="1143-Longest-Common-Subsequence-Medium"><a href="#1143-Longest-Common-Subsequence-Medium" class="headerlink" title="1143. Longest Common Subsequence (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence (Medium)</a></h3><p>Given two strings text1 and text2, return the length of their longest common subsequence.<br>A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.<br>If there is no common subsequence, return 0.</p>
<p>Example 1:<br>Input: text1 = “abcde”, text2 = “ace”<br>Output: 3<br>Explanation: The longest common subsequence is “ace” and its length is 3.</p>
<p>Example 2:<br>Input: text1 = “abc”, text2 = “abc”<br>Output: 3<br>Explanation: The longest common subsequence is “abc” and its length is 3.</p>
<p>Example 3:<br>Input: text1 = “abc”, text2 = “def”<br>Output: 0<br>Explanation: There is no such common subsequence, so the result is 0.</p>
<p>Constraints:<br>1 &lt;= text1.length &lt;= 1000<br>1 &lt;= text2.length &lt;= 1000<br>The input strings consist of lowercase English characters only.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>一刷：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunll9201/p/9996161.html">系列题讲解还有可以输出具体LCS的代码</a></p>
<h3 id="1027-Longest-Arithmetic-Sequence-Medium"><a href="#1027-Longest-Arithmetic-Sequence-Medium" class="headerlink" title="1027. Longest Arithmetic Sequence (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-arithmetic-sequence/">1027. Longest Arithmetic Sequence (Medium)</a></h3><p>Given an array A of integers, return the length of the longest arithmetic subsequence in A.<br>Recall that a subsequence of A is a list A[i_1], A[i_2], …, A[i_k] with 0 &lt;= i_1 &lt; i_2 &lt; … &lt; i_k &lt;= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 &lt;= i &lt; B.length - 1).</p>
<p>Example 1:<br>Input: [3,6,9,12]<br>Output: 4<br>Explanation:<br>The whole array is an arithmetic sequence with steps of length = 3.</p>
<p>Example 2:<br>Input: [9,4,7,2,10]<br>Output: 3<br>Explanation:<br>The longest arithmetic subsequence is [4,7,10].</p>
<p>Example 3:<br>Input: [20,1,15,3,10,5,8]<br>Output: 4<br>Explanation:<br>The longest arithmetic subsequence is [20,15,10,5].</p>
<p>Note:<br>2 &lt;= A.length &lt;= 2000<br>0 &lt;= A[i] &lt;= 10000</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestArithSeqLength</span>(<span class="params">self, A: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(A)):</span><br><span class="line">                dp[j, A[j] - A[i]] = dp.get((i, A[j] - A[i]), <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp.values())</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="322-Coin-Change-Medium"><a href="#322-Coin-Change-Medium" class="headerlink" title="322. Coin Change (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/">322. Coin Change (Medium)</a></h3><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p>
<p>Example 2:<br>Input: coins = [2], amount = 3<br>Output: -1</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        MAX = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        dp = [MAX] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>([dp[i - coin] <span class="keyword">if</span> i - coin &gt;= <span class="number">0</span> <span class="keyword">else</span> MAX <span class="keyword">for</span> coin <span class="keyword">in</span> coins]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != MAX <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>面经: Cruise。sys.maxsize和float(‘inf’)是有区别的，前者可以被+1，后者+1还是inf<br>面经：维萨</p>
<h3 id="474-Ones-and-Zeroes-Medium"><a href="#474-Ones-and-Zeroes-Medium" class="headerlink" title="474. Ones and Zeroes (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ones-and-zeroes/">474. Ones and Zeroes (Medium)</a></h3><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.<br>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.<br>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.<br>Note:<br>The given numbers of 0s and 1s will both not exceed 100<br>The size of given string array won’t exceed 600.</p>
<p>Example 1:<br>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>Output: 4<br>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</p>
<p>Example 2:<br>Input: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>Output: 2<br>Explanation: You could form “10”, but then you’d have nothing left. Better form “0” and “1”.<br>Bruteforce:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">            <span class="keyword">return</span> self.helper(strs, m, n, <span class="number">0</span>, collections.defaultdict(<span class="built_in">dict</span>))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, strs, m, n, idx, memo</span>):</span></span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">in</span> memo <span class="keyword">and</span> n <span class="keyword">in</span> memo[m] <span class="keyword">and</span> idx <span class="keyword">in</span> memo[m][n]:</span><br><span class="line">                <span class="keyword">return</span> memo[m][n][idx]</span><br><span class="line">            memo.setdefault(m, &#123;&#125;).setdefault(n, &#123;&#125;)[idx] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, <span class="built_in">len</span>(strs)):</span><br><span class="line">                zeros, ones = strs[i].count(<span class="string">&#x27;0&#x27;</span>), strs[i].count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> zeros &lt;= m <span class="keyword">and</span> ones &lt;= n:</span><br><span class="line">                    memo[m][n][idx] = <span class="built_in">max</span>(memo[m][n][idx], self.helper(strs, m - zeros, n - ones, i + <span class="number">1</span>, memo) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[m][n][idx]</span><br></pre></td></tr></table></figure>
<p>DP:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs) + <span class="number">1</span>):</span><br><span class="line">            zeros, ones = strs[i - <span class="number">1</span>].count(<span class="string">&#x27;0&#x27;</span>), strs[i - <span class="number">1</span>].count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= zeros <span class="keyword">and</span> k &gt;= ones:</span><br><span class="line">                        dp[i][j][k] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - zeros][k - ones] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j][k] = dp[i - <span class="number">1</span>][j][k]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>面经：Cruise。可惜两种方法都过不了python3的oj</p>
<h3 id="416-Partition-Equal-Subset-Sum-Medium"><a href="#416-Partition-Equal-Subset-Sum-Medium" class="headerlink" title="416. Partition Equal Subset Sum (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum (Medium)</a></h3><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p>Note:<br>Each of the array element will not exceed 100.<br>The array size will not exceed 200.</p>
<p>Example 1:<br>Input: [1, 5, 11, 5]<br>Output: true<br>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>
<p>Example 2:<br>Input: [1, 2, 3, 5]<br>Output: false<br>Explanation: The array cannot be partitioned into equal sum subsets.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        target = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> target % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(nums) &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums) + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>面经：Cruise。dp为从前i个序列中是否能有组成和为j的组合，要么用i - 1，要么不用i - 1，用的话那么取决于dp[i - 1][j - nums[i -1]]</p>
<h1 id="Recursion-递归-Backtracking"><a href="#Recursion-递归-Backtracking" class="headerlink" title="Recursion 递归 / Backtracking"></a>Recursion 递归 / Backtracking</h1><h3 id="13-Roman-to-Integer-Easy"><a href="#13-Roman-to-Integer-Easy" class="headerlink" title="13. Roman to Integer (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/">13. Roman to Integer (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</span><br><span class="line"></span><br><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">For example, two is written as II in Roman numeral, just two one&#x27;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</span><br><span class="line"></span><br><span class="line">Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</span><br><span class="line"></span><br><span class="line">I can be placed before V (5) and X (10) to make 4 and 9.</span><br><span class="line">X can be placed before L (50) and C (100) to make 40 and 90.</span><br><span class="line">C can be placed before D (500) and M (1000) to make 400 and 900.</span><br><span class="line">Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> mapping[s]</span><br><span class="line">        first, second, rest = s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> mapping[first] &lt; mapping[second]:</span><br><span class="line">            <span class="keyword">return</span> mapping[second] - mapping[first] + self.romanToInt(rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mapping[first] + self.romanToInt(second + rest)</span><br></pre></td></tr></table></figure>
<p>总结：…else: return <strong>mapping[first] + self.romanToInt(second + rest)</strong></p>
<h3 id="50-Pow-x-n-Medium"><a href="#50-Pow-x-n-Medium" class="headerlink" title="50. Pow(x, n) (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/powx-n/description/">50. Pow(x, n) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Implement pow(x, n), which calculates x raised to the power n (xn).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n is a 32-bit signed integer, within the range [−231, 231 − 1]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(x, n) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/self.helper(x, -n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = self.helper(x, n//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res * res <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x * res * res</span><br></pre></td></tr></table></figure>
<p>总结：有固定写法套路的题目， 不值得做。<br>高频：稍微精简了一点，为高频而刷</p>
<h3 id="4-Median-of-Two-Sorted-Arrays-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-Hard" class="headerlink" title="4. Median of Two Sorted Arrays (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">There are two sorted arrays nums1 and nums2 of size m and n respectively.</span><br><span class="line"></span><br><span class="line">Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</span><br><span class="line"></span><br><span class="line">You may assume nums1 and nums2 cannot be both empty.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1 <span class="keyword">and</span> <span class="keyword">not</span> nums2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findK</span>(<span class="params">a, b, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">                <span class="keyword">return</span> b[k]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b:</span><br><span class="line">                <span class="keyword">return</span> a[k]</span><br><span class="line">            ai, bi = <span class="built_in">len</span>(a) // <span class="number">2</span>, <span class="built_in">len</span>(b) // <span class="number">2</span></span><br><span class="line">            am, bm = a[ai], b[bi]</span><br><span class="line">            <span class="keyword">if</span> k &gt; ai + bi:</span><br><span class="line">                <span class="keyword">if</span> am &lt; bm:</span><br><span class="line">                    <span class="keyword">return</span> findK(a[ai + <span class="number">1</span>:], b, k - ai - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> findK(a, b[bi + <span class="number">1</span>:], k - bi - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> am &gt; bm:</span><br><span class="line">                    <span class="keyword">return</span> findK(a[:ai], b, k)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> findK(a, b[:bi], k)</span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> findK(nums1, nums2, (m + n) // <span class="number">2</span>) * <span class="number">0.5</span> + findK(nums1, nums2, (m + n) //<span class="number">2</span> - <span class="number">1</span>) * <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> findK(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>高频：总长度是奇偶数分开做，…def findK(a, b, k):…if…:…return findK(a[ai + 1:], b, k - ai - 1)…</p>
<h1 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h1><h3 id="231-Power-of-Two-Easy"><a href="#231-Power-of-Two-Easy" class="headerlink" title="231. Power of Two (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-two/description/">231. Power of Two (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given an integer, write a function to determine if it is a power of two.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 2^0 = 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 2^4 = 16</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 218</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：既然是 bit manipulation 的题，肯定是变成 bits 操作，稍微看一下 2 的倍数都是 1 后面全是 0。怎么用 python 检查这个比较没思路。。。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n)[<span class="number">2</span>:] == <span class="string">&#x27;1&#x27;</span>.ljust(<span class="built_in">len</span>(<span class="built_in">bin</span>(n)) - <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>总结：看了三年前比较屌的 trick 是 return n &amp; n - 1, 当然 bin 这种土办法也 OK 的。</p>
<h3 id="29-Divide-Two-Integers-Medium"><a href="#29-Divide-Two-Integers-Medium" class="headerlink" title="29. Divide Two Integers (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/description/">29. Divide Two Integers (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</span><br><span class="line"></span><br><span class="line">Return the quotient after dividing dividend by divisor.</span><br><span class="line"></span><br><span class="line">The integer division should truncate toward zero.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Both dividend and divisor will be 32-bit signed integers.</span><br><span class="line">The divisor will never be 0.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        positive = (dividend &lt; <span class="number">0</span>) <span class="keyword">is</span> (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = <span class="built_in">abs</span>(dividend), <span class="built_in">abs</span>(divisor)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">            t, p = divisor, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= t:</span><br><span class="line">                dividend -= t</span><br><span class="line">                ans += p</span><br><span class="line">                t &lt;&lt;= <span class="number">1</span></span><br><span class="line">                p &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> positive:</span><br><span class="line">            ans = -ans</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (-<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) &lt;= ans &lt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：…while dividend &gt;= divisor: …while dividend &gt;= t: dividend -= t; ans += p; t &lt;&lt;= 1; p &lt;&lt;= 1…</p>
<h3 id="89-Gray-Code-Medium"><a href="#89-Gray-Code-Medium" class="headerlink" title="89. Gray Code (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/gray-code/">89. Gray Code (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">The gray code is a binary numeral system where two successive values differ in only one bit.</span><br><span class="line"></span><br><span class="line">Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2</span><br><span class="line">Output: [0,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">For a given n, a gray code sequence may not be uniquely defined.</span><br><span class="line">For example, [0,2,3,1] is also a valid gray code sequence.</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 0</span><br><span class="line">Output: [0]</span><br><span class="line">Explanation: We define the gray code sequence to begin with 0.</span><br><span class="line">             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.</span><br><span class="line">             Therefore, for n = 0 the gray code sequence is [0].</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += [x + <span class="built_in">pow</span>(<span class="number">2</span>, i) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(ans)]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：这道题无面试意义，考点在于知道格雷码的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/grandyang/p/4315649.html">镜像性质</a></p>
<h1 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h1><h3 id="65-Valid-Number-Hard"><a href="#65-Valid-Number-Hard" class="headerlink" title="65. Valid Number (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-number/">65. Valid Number (Hard)</a></h3><p>Validate if a given string can be interpreted as a decimal number.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Some examples:</span><br><span class="line">&quot;0&quot; &#x3D;&gt; true</span><br><span class="line">&quot; 0.1 &quot; &#x3D;&gt; true</span><br><span class="line">&quot;abc&quot; &#x3D;&gt; false</span><br><span class="line">&quot;1 a&quot; &#x3D;&gt; false</span><br><span class="line">&quot;2e10&quot; &#x3D;&gt; true</span><br><span class="line">&quot; -90e3   &quot; &#x3D;&gt; true</span><br><span class="line">&quot; 1e&quot; &#x3D;&gt; false</span><br><span class="line">&quot;e3&quot; &#x3D;&gt; false</span><br><span class="line">&quot; 6e-1&quot; &#x3D;&gt; true</span><br><span class="line">&quot; 99e2.5 &quot; &#x3D;&gt; false</span><br><span class="line">&quot;53.5e93&quot; &#x3D;&gt; true</span><br><span class="line">&quot; --6 &quot; &#x3D;&gt; false</span><br><span class="line">&quot;-+3&quot; &#x3D;&gt; false</span><br><span class="line">&quot;95a54e53&quot; &#x3D;&gt; false</span><br></pre></td></tr></table></figure>
<p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:<br>Numbers 0-9<br>Exponent - “e”<br>Positive/negative sign - “+”/“-“<br>Decimal point - “.”<br>Of course, the context of these characters also matters in the input.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        pattern = <span class="string">r&#x27;^[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[+-]?[0-9]+)?$&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> re.match(pattern, s.strip()) != <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>高频：学习了^, [], ?, +, *, |, $的用法</p>
<h1 id="Multi-threading-多线程"><a href="#Multi-threading-多线程" class="headerlink" title="Multi-threading 多线程"></a>Multi-threading 多线程</h1><h3 id="1114-Print-in-Order-Easy"><a href="#1114-Print-in-Order-Easy" class="headerlink" title="1114. Print in Order (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/print-in-order/">1114. Print in Order (Easy)</a></h3><p>Suppose we have a class:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">  public void first() &#123; print(&quot;first&quot;); &#125;</span><br><span class="line">  public void second() &#123; print(&quot;second&quot;); &#125;</span><br><span class="line">  public void third() &#123; print(&quot;third&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,3,2]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure>
<p>Note:<br>We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seems to imply the ordering. The input format you see is mainly to ensure our tests’ comprehensiveness.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">import</span> threading</span><br><span class="line">        self.barrier1 = threading.Barrier(<span class="number">2</span>)</span><br><span class="line">        self.barrier2 = threading.Barrier(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span>(<span class="params">self, printFirst: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.barrier1.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span>(<span class="params">self, printSecond: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.barrier1.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.barrier2.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span>(<span class="params">self, printThird: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.barrier2.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>
<p>一刷：Lock, Event, Semaphore或Condition也可以解。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation">这篇讨论帖很好</a></p>
<h3 id="1115-Print-FooBar-Alternately-Medium"><a href="#1115-Print-FooBar-Alternately-Medium" class="headerlink" title="1115. Print FooBar Alternately (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/print-foobar-alternately/">1115. Print FooBar Alternately (Medium)</a></h3><p>Suppose you are given the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">  public void foo() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      print(&quot;foo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public void bar() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      print(&quot;bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The same instance of FooBar will be passed to two different threads. Thread A will call foo() while thread B will call bar(). Modify the given program to output “foobar” n times.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: &quot;foobar&quot;</span><br><span class="line">Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar(). &quot;foobar&quot; is being output 1 time.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: &quot;foobarfoobar&quot;</span><br><span class="line">Explanation: &quot;foobar&quot; is being output 2 times.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">import</span> threading</span><br><span class="line">        self.n = n</span><br><span class="line">        self.fooLock = threading.Lock()</span><br><span class="line">        self.barLock = threading.Lock()</span><br><span class="line">        self.fooLock.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, printFoo: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            self.barLock.acquire()</span><br><span class="line">            printFoo()</span><br><span class="line">            self.fooLock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">self, printBar: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            self.fooLock.acquire()</span><br><span class="line">            printBar()</span><br><span class="line">            self.barLock.release()</span><br></pre></td></tr></table></figure>
<p>一刷：Barrier, Condition, Event, Semaphore也可以解</p>
<h3 id="1116-Print-Zero-Even-Odd-Medium"><a href="#1116-Print-Zero-Even-Odd-Medium" class="headerlink" title="1116. Print Zero Even Odd (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/print-zero-even-odd/">1116. Print Zero Even Odd (Medium)</a></h3><p>Suppose you are given the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ZeroEvenOdd &#123;</span><br><span class="line">  public ZeroEvenOdd(int n) &#123; ... &#125;      &#x2F;&#x2F; constructor</span><br><span class="line">  public void zero(printNumber) &#123; ... &#125;  &#x2F;&#x2F; only output 0&#39;s</span><br><span class="line">  public void even(printNumber) &#123; ... &#125;  &#x2F;&#x2F; only output even numbers</span><br><span class="line">  public void odd(printNumber) &#123; ... &#125;   &#x2F;&#x2F; only output odd numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The same instance of ZeroEvenOdd will be passed to three different threads:<br>Thread A will call zero() which should only output 0’s.<br>Thread B will call even() which should only ouput even numbers.<br>Thread C will call odd() which should only output odd numbers.<br>Each of the threads is given a printNumber method to output an integer. Modify the given program to output the series 010203040506… where the length of the series must be 2n.</p>
<p>Example 1:<br>Input: n = 2<br>Output: “0102”<br>Explanation: There are three threads being fired asynchronously. One of them calls zero(), the other calls even(), and the last one calls odd(). “0102” is the correct output.</p>
<p>Example 2:<br>Input: n = 5<br>Output: “0102030405”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">import</span> threading</span><br><span class="line">        self.n = n</span><br><span class="line">        self.cur = <span class="number">0</span></span><br><span class="line">        self.semas = [threading.Semaphore() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">        self.semas[<span class="number">0</span>].acquire()</span><br><span class="line">        self.semas[<span class="number">1</span>].acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># printNumber(x) outputs &quot;x&quot;, where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero</span>(<span class="params">self, printNumber: <span class="string">&#x27;Callable[[int], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            self.semas[<span class="number">2</span>].acquire()</span><br><span class="line">            printNumber(<span class="number">0</span>)</span><br><span class="line">            self.cur += <span class="number">1</span></span><br><span class="line">            self.semas[self.cur % <span class="number">2</span>].release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">even</span>(<span class="params">self, printNumber: <span class="string">&#x27;Callable[[int], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">2</span>):</span><br><span class="line">            self.semas[<span class="number">0</span>].acquire()</span><br><span class="line">            printNumber(self.cur)</span><br><span class="line">            self.semas[<span class="number">2</span>].release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">odd</span>(<span class="params">self, printNumber: <span class="string">&#x27;Callable[[int], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((self.n + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">            self.semas[<span class="number">1</span>].acquire()</span><br><span class="line">            printNumber(self.cur)</span><br><span class="line">            self.semas[<span class="number">2</span>].release()</span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="1117-Building-H2O-Medium"><a href="#1117-Building-H2O-Medium" class="headerlink" title="1117. Building H2O (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/building-h2o/">1117. Building H2O (Medium)</a></h3><p>There are two kinds of threads, oxygen and hydrogen. Your goal is to group these threads to form water molecules. There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must be able to immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.</p>
<p>In other words:<br>If an oxygen thread arrives at the barrier when no hydrogen threads are present, it has to wait for two hydrogen threads.<br>If a hydrogen thread arrives at the barrier when no other threads are present, it has to wait for an oxygen thread and another hydrogen thread.<br>We don’t have to worry about matching the threads up explicitly; that is, the threads do not necessarily know which other threads they are paired up with. The key is just that threads pass the barrier in complete sets; thus, if we examine the sequence of threads that bond and divide them into groups of three, each group should contain one oxygen and two hydrogen threads.</p>
<p>Write synchronization code for oxygen and hydrogen molecules that enforces these constraints.</p>
<p>Example 1:<br>Input: “HOH”<br>Output: “HHO”<br>Explanation: “HOH” and “OHH” are also valid answers.</p>
<p>Example 2:<br>Input: “OOHHHH”<br>Output: “HHOHHO”<br>Explanation: “HOHHHO”, “OHHHHO”, “HHOHOH”, “HOHHOH”, “OHHHOH”, “HHOOHH”, “HOHOHH” and “OHHOHH” are also valid answers.</p>
<p>Constraints:<br>Total length of input string will be 3n, where 1 ≤ n ≤ 20.<br>Total number of H will be 2n in the input string.<br>Total number of O will be n in the input string.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H2O</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">import</span> threading</span><br><span class="line">        self.H = <span class="number">0</span></span><br><span class="line">        self.O = <span class="number">0</span></span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hydrogen</span>(<span class="params">self, releaseHydrogen: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.releaseH = releaseHydrogen</span><br><span class="line">            self.H += <span class="number">1</span></span><br><span class="line">            self.helper()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oxygen</span>(<span class="params">self, releaseOxygen: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.releaseO = releaseOxygen</span><br><span class="line">            self.O += <span class="number">1</span></span><br><span class="line">            self.helper()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.H &gt;= <span class="number">2</span> <span class="keyword">and</span> self.O &gt;= <span class="number">1</span>:</span><br><span class="line">            self.releaseH()</span><br><span class="line">            self.releaseH()</span><br><span class="line">            self.releaseO()</span><br><span class="line">            self.H -= <span class="number">2</span></span><br><span class="line">            self.O -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h1 id="Misc-杂类型，偏门-特殊算法"><a href="#Misc-杂类型，偏门-特殊算法" class="headerlink" title="Misc 杂类型，偏门/特殊算法"></a>Misc 杂类型，偏门/特殊算法</h1><h3 id="7-Reverse-Integer-Easy"><a href="#7-Reverse-Integer-Easy" class="headerlink" title="7. Reverse Integer (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/">7. Reverse Integer (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a 32-bit signed integer, reverse digits of an integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br><span class="line">Note:</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</span><br></pre></td></tr></table></figure>
<p>高频</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            x = -x</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span> <span class="keyword">and</span> ans &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) <span class="keyword">or</span> (sign == -<span class="number">1</span> <span class="keyword">and</span> ans &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * ans</span><br></pre></td></tr></table></figure>
<p>总结：…while x:…ans = ans * 10 + x <strong>%</strong> 10。转成字符串[::-1]是更优解</p>
<h3 id="31-Next-Permutation-Medium"><a href="#31-Next-Permutation-Medium" class="headerlink" title="31. Next Permutation (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/">31. Next Permutation (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</span><br><span class="line"></span><br><span class="line">If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</span><br><span class="line"></span><br><span class="line">The replacement must be in-place and use only constant extra memory.</span><br><span class="line"></span><br><span class="line">Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</span><br><span class="line"></span><br><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment">#find pivot</span></span><br><span class="line">        pivot = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                pivot = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> pivot == -<span class="number">1</span>:</span><br><span class="line">            reverse(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment">#find rightmost &gt; element in surfix and swap</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, pivot, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[pivot]:</span><br><span class="line">                rightmostI = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[pivot], nums[rightmostI] = nums[rightmostI], nums[pivot]</span><br><span class="line">        <span class="comment">#reverse surfix</span></span><br><span class="line">        reverse(pivot + <span class="number">1</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>高频，面经：维萨。lexicographical顺序的下一个排列<a target="_blank" rel="noopener" href="https://www.nayuki.io/page/next-lexicographical-permutation-algorithm">算法描述</a>，删去基于<a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/discuss/13867/C%2B%2B-from-Wikipedia">十四世纪的一个算法</a>代码。知识型的不适合面试。</p>
<h3 id="60-Permutation-Sequence-Medium"><a href="#60-Permutation-Sequence-Medium" class="headerlink" title="60. Permutation Sequence (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-sequence/">60. Permutation Sequence (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The set [1,2,3,...,n] contains a total of n! unique permutations.</span><br><span class="line"></span><br><span class="line">By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</span><br><span class="line"></span><br><span class="line">&quot;123&quot;</span><br><span class="line">&quot;132&quot;</span><br><span class="line">&quot;213&quot;</span><br><span class="line">&quot;231&quot;</span><br><span class="line">&quot;312&quot;</span><br><span class="line">&quot;321&quot;</span><br><span class="line">Given n and k, return the kth permutation sequence.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Given n will be between 1 and 9 inclusive.</span><br><span class="line">Given k will be between 1 and n! inclusive.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n = 3, k = 3</span><br><span class="line">Output: &quot;213&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: n = 4, k = 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        nums = [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">import</span> math</span><br><span class="line">            nf = math.factorial(n - <span class="number">1</span>)</span><br><span class="line">            i = (k - <span class="number">1</span>) // nf</span><br><span class="line">            k = (k - <span class="number">1</span>) % nf + <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            ans += <span class="built_in">str</span>(nums.pop(i))</span><br><span class="line">        ans += <span class="built_in">str</span>(nums.pop())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：和上题一样无语。讨论区的python答案都不太行，提交结果里的高频可以。…while len(el) &gt; 1:…i = (k - 1) <strong>//</strong> nf; k = (k - 1) % nf <strong>+ 1</strong>…</p>
<h3 id="238-Product-of-Array-Except-Self-Medium"><a href="#238-Product-of-Array-Except-Self-Medium" class="headerlink" title="238. Product of Array Except Self (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self (Medium)</a></h3><p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:<br>Input:  [1,2,3,4]<br>Output: [24,12,8,6]<br>Note: Please solve it without division and in O(n).</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans[i] = p</span><br><span class="line">            p *= nums[i]</span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            ans[i] *= p</span><br><span class="line">            p *= nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频, 面经：Amazon。这题取决于知道从左到右，再从右到左把元素乘一遍放到结果里这个方法</p>
<h3 id="92-Reverse-Linked-List-II-Medium"><a href="#92-Reverse-Linked-List-II-Medium" class="headerlink" title="92. Reverse Linked List II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II (Medium)</a></h3><p>Reverse a linked list from position m to n. Do it in one-pass.<br>Note: 1 ≤ m ≤ n ≤ length of list.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - m):</span><br><span class="line">            t = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = t.<span class="built_in">next</span></span><br><span class="line">            t.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = t</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>高频，二刷：…cur = p.next…for…t = cur.next; cur.next = t.next…</p>
<h3 id="84-Largest-Rectangle-in-Histogram-Hard"><a href="#84-Largest-Rectangle-in-Histogram-Hard" class="headerlink" title="84. Largest Rectangle in Histogram (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram (Hard)</a></h3><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" alt="histogram example"><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt="largetst rectangle example"><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br></pre></td></tr></table></figure>
<p>一刷：有三个油管视频讲这个算法，<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RVIh0snn4Qc">目前对我最有用的是这个</a>， <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/largest-rectangle-under-histogram/">python代码可以看这个</a> todo</p>
<h3 id="42-Trapping-Rain-Water-Hard"><a href="#42-Trapping-Rain-Water-Hard" class="headerlink" title="42. Trapping Rain Water (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water (Hard)</a></h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water example"><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:<br>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        maxL = [<span class="number">0</span>] * n</span><br><span class="line">        maxLSoFar = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            <span class="keyword">if</span> h &gt; maxLSoFar:</span><br><span class="line">                maxLSoFar = h</span><br><span class="line">            maxL[i] = maxLSoFar</span><br><span class="line">        maxR = [<span class="number">0</span>] * n</span><br><span class="line">        maxRSoFar = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> height[i] &gt; maxRSoFar:</span><br><span class="line">                maxRSoFar = height[i]</span><br><span class="line">            maxR[i] = maxRSoFar</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            ans += <span class="built_in">min</span>(maxL[i], maxR[i]) - h <span class="keyword">if</span> <span class="built_in">min</span>(maxL[i], maxR[i]) - h <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>一刷：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/solution/">答案</a>中有bruteforce和衍生的类似dp解法。todo: 类似上题stackbased</p>
<h3 id="732-My-Calendar-III-Hard"><a href="#732-My-Calendar-III-Hard" class="headerlink" title="732. My Calendar III (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/my-calendar-iii/">732. My Calendar III (Hard)</a></h3><p>Implement a MyCalendarThree class to store your events. A new event can always be added.<br>Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end.<br>A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)<br>For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.<br>Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">MyCalendarThree();</span><br><span class="line">MyCalendarThree.book(10, 20); &#x2F;&#x2F; returns 1</span><br><span class="line">MyCalendarThree.book(50, 60); &#x2F;&#x2F; returns 1</span><br><span class="line">MyCalendarThree.book(10, 40); &#x2F;&#x2F; returns 2</span><br><span class="line">MyCalendarThree.book(5, 15); &#x2F;&#x2F; returns 3</span><br><span class="line">MyCalendarThree.book(5, 10); &#x2F;&#x2F; returns 3</span><br><span class="line">MyCalendarThree.book(25, 55); &#x2F;&#x2F; returns 3</span><br><span class="line">Explanation:</span><br><span class="line">The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.</span><br><span class="line">The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.</span><br><span class="line">The remaining events cause the maximum K-booking to be only a 3-booking.</span><br><span class="line">Note that the last event locally causes a 2-booking, but the answer is still 3 because</span><br><span class="line">eg. [10, 20), [10, 40), and [5, 15) are still triple booked.</span><br></pre></td></tr></table></figure>
<p>Note:<br>The number of calls to MyCalendarThree.book per test case will be at most 400.<br>In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarThree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.meetings = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span>(<span class="params">self, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> bisect <span class="keyword">import</span> insort</span><br><span class="line">        insort(self.meetings, (start, <span class="number">1</span>))</span><br><span class="line">        insort(self.meetings, (end, -<span class="number">1</span>))</span><br><span class="line">        cumsum = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, x <span class="keyword">in</span> self.meetings:</span><br><span class="line">            cumsum += x</span><br><span class="line">            res = <span class="built_in">max</span>(cumsum, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>一刷：开始+1， 结束-1， 统计遍历中最大值的方法很巧妙</p>
<h1 id="skipped"><a href="#skipped" class="headerlink" title="skipped"></a>skipped</h1><h2 id="DFS-Union-Find"><a href="#DFS-Union-Find" class="headerlink" title="DFS / Union Find"></a>DFS / Union Find</h2><h3 id="721-Accounts-Merge-Medium"><a href="#721-Accounts-Merge-Medium" class="headerlink" title="721. Accounts Merge (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/accounts-merge/">721. Accounts Merge (Medium)</a></h3><h2 id="DP-Dynamic-Programming-动态规划-1"><a href="#DP-Dynamic-Programming-动态规划-1" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h2><h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III-Hard"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-Hard" class="headerlink" title="123. Best Time to Buy and Sell Stock III (Hard)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123. Best Time to Buy and Sell Stock III (Hard)</a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems">generalized best time to buy and sell stocks</a></p>
<h1 id="非核心题"><a href="#非核心题" class="headerlink" title="非核心题"></a>非核心题</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="LinC-862-Next-Closest-Time-Medium"><a href="#LinC-862-Next-Closest-Time-Medium" class="headerlink" title="LinC 862. Next Closest Time (Medium)"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/next-closest-time/description">LinC 862. Next Closest Time (Medium)</a></h3><p>Given a time represented in the format “HH:MM”, form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.<br>You may assume the given input string is always valid. For example, “01:34”, “12:09” are all valid. “1:34”, “12:9” are all invalid.</p>
<p>Example：<br>Given time = “19:34”, return “19:39”.<br>Explanation:<br>The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.</p>
<p>Given time = “23:59”, return “22:22”.<br>Explanation:<br>The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day’s time since it is smaller than the input time numerically.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextClosestTime</span>(<span class="params">self, time</span>):</span></span><br><span class="line">        s = <span class="built_in">set</span>(time)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> time</span><br><span class="line">        digits = time[<span class="number">0</span>:<span class="number">2</span>] + time[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">        self.ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.minDiff = sys.maxsize</span><br><span class="line">        self.target = <span class="built_in">int</span>(time[<span class="number">0</span>:<span class="number">2</span>]) * <span class="number">60</span> + <span class="built_in">int</span>(time[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line">        self.dfs(digits, <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, digits, path, start</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># path 产生了一个合法的时间，判断和 target 距离 diff 和 self.minDiff 的关系</span></span><br><span class="line">            m = <span class="built_in">int</span>(path[<span class="number">0</span>:<span class="number">2</span>]) * <span class="number">60</span> + <span class="built_in">int</span>(path[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">            diff = m - self.target</span><br><span class="line">            <span class="keyword">if</span> diff == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">                diff = <span class="number">24</span> * <span class="number">60</span> + diff</span><br><span class="line">            <span class="keyword">if</span> diff &lt; self.minDiff:</span><br><span class="line">                self.minDiff = diff</span><br><span class="line">                self.ans = path[<span class="number">0</span>:<span class="number">2</span>] + <span class="string">&#x27;:&#x27;</span> + path[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> digits:</span><br><span class="line">            <span class="comment"># 处理 path, 把不合适的时间都 continue 过去, 但是怎么判断现在处理的是哪个位置？看了下答案， 其实不需要 enumerate</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">int</span>(digit) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">int</span>(path) * <span class="number">10</span> + <span class="built_in">int</span>(digit) &gt; <span class="number">23</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">int</span>(digit) &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">int</span>(path[<span class="number">2</span>:<span class="number">3</span>]) * <span class="number">10</span> + <span class="built_in">int</span>(digit) &gt; <span class="number">59</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(digits, path + digit, start + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>总结：python3 把 sys.maxint 改成 sys.maxsize 了。要一次对的话，很多取数的细节需要留心。1.input time 要取 [0:2] [3:5] 来跳过 ‘:’; 2.diff 是负数的时候要用 24 * 60 + diff（而不是 -）；3.for 循环里面的 digit 记得包上 int()</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="637-Average-of-Levels-in-Binary-Tree-Easy"><a href="#637-Average-of-Levels-in-Binary-Tree-Easy" class="headerlink" title="637. Average of Levels in Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree (Easy)</a></h3><p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">Output: [3, 14.5, 11]</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].<br>Note:<br>The range of node’s value is in the range of 32-bit signed integer.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[float]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = [[]]</span><br><span class="line">        self.helper(root, res, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">sum</span>(x) / <span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> res]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, res, depth</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> depth &gt;= <span class="built_in">len</span>(res):</span><br><span class="line">            res.append([])</span><br><span class="line">        res[depth].append(root.val)</span><br><span class="line">        self.helper(root.left, res, depth + <span class="number">1</span>)</span><br><span class="line">        self.helper(root.right, res, depth + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="270-Closest-Binary-Search-Tree-Value-Easy-带锁"><a href="#270-Closest-Binary-Search-Tree-Value-Easy-带锁" class="headerlink" title="270. Closest Binary Search Tree Value (Easy) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/closest-binary-search-tree-value">270. Closest Binary Search Tree Value (Easy) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/closest-binary-search-tree-value/description">Linc 900. Closest Binary Search Tree Value (Easy)</a><br>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.<br>Given target value is a floating point.<br>You are guaranteed to have only one unique value in the BST that is closest to the target.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example1</span><br><span class="line">Input: root &#x3D; &#123;5,4,9,2,#,8,10&#125; and target &#x3D; 6.124780</span><br><span class="line">Output: 5</span><br><span class="line">Explanation：</span><br><span class="line">Binary tree &#123;5,4,9,2,#,8,10&#125;,  denote the following structure:</span><br><span class="line">        5</span><br><span class="line">       &#x2F; \</span><br><span class="line">     4    9</span><br><span class="line">    &#x2F;    &#x2F; \</span><br><span class="line">   2    8  10</span><br><span class="line"></span><br><span class="line">Example2</span><br><span class="line">Input: root &#x3D; &#123;3,2,4,1&#125; and target &#x3D; 4.142857</span><br><span class="line">Output: 4</span><br><span class="line">Explanation：</span><br><span class="line">Binary tree &#123;3,2,4,1&#125;,  denote the following structure:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">  2    4</span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestValue</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        self.ans = root.val</span><br><span class="line">        self.helper(root, target)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(root.val - target) &lt; <span class="built_in">abs</span>(self.ans - target):</span><br><span class="line">            self.ans = root.val</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; target:</span><br><span class="line">            self.helper(root.left, target)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; target:</span><br><span class="line">            self.helper(root.right, target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.ans = root.val</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="272-Closest-Binary-Search-Tree-Value-II-Hard-带锁"><a href="#272-Closest-Binary-Search-Tree-Value-II-Hard-带锁" class="headerlink" title="272. Closest Binary Search Tree Value II (Hard) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/closest-binary-search-tree-value-ii">272. Closest Binary Search Tree Value II (Hard) 带锁</a></h3><p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/description">Linc 901. Closest Binary Search Tree Value II (Hard)</a><br>Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">&#123;1&#125;</span><br><span class="line">0.000000</span><br><span class="line">1</span><br><span class="line">Output:</span><br><span class="line">[1]</span><br><span class="line">Explanation：</span><br><span class="line">Binary tree &#123;1&#125;,  denote the following structure:</span><br><span class="line"> 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">&#123;3,1,4,#,2&#125;</span><br><span class="line">0.275000</span><br><span class="line">2</span><br><span class="line">Output:</span><br><span class="line">[1,2]</span><br><span class="line">Explanation：</span><br><span class="line">Binary tree &#123;3,1,4,#,2&#125;,  denote the following structure:</span><br><span class="line">  3</span><br><span class="line"> &#x2F;  \</span><br><span class="line">1    4</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>
<p>Challenge<br>Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p>
<p>Notice<br>Given target value is a floating point.<br>You may assume k is always valid, that is: k ≤ total nodes.<br>You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestKValues</span>(<span class="params">self, root, target, k</span>):</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.helper(root, target, k, ans)</span><br><span class="line">        <span class="keyword">return</span> [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> ans]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, target, k, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heappush(ans, (-<span class="built_in">abs</span>(root.val - target), root.val))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ans) == k + <span class="number">1</span>:</span><br><span class="line">            heapq.heappop(ans)</span><br><span class="line">        self.helper(root.left, target, k, ans)</span><br><span class="line">        self.helper(root.right, target, k, ans)</span><br></pre></td></tr></table></figure>

<h3 id="404-Sum-of-Left-Leaves-Easy"><a href="#404-Sum-of-Left-Leaves-Easy" class="headerlink" title="404. Sum of Left Leaves (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves (Easy)</a></h3><p>Find the sum of all left leaves in a given binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            <span class="keyword">return</span> root.left.val + self.sumOfLeftLeaves(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="653-Two-Sum-IV-Input-is-a-BST-Easy"><a href="#653-Two-Sum-IV-Input-is-a-BST-Easy" class="headerlink" title="653. Two Sum IV - Input is a BST (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">653. Two Sum IV - Input is a BST (Easy)</a></h3><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 9</span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 28</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>
<p>hash表/set方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">return</span> self.helper(root, k, seen)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, k, seen</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> k - root.val <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        seen.add(root.val)</span><br><span class="line">        <span class="keyword">return</span> self.helper(root.left, k, seen) <span class="keyword">or</span> self.helper(root.right, k, seen)</span><br></pre></td></tr></table></figure>
<p>遍历BFS：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        q = [root]</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                n = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> k - n.val <span class="keyword">in</span> seen:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                seen.add(n.val)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    q.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    q.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>in-order/中序遍历双指针：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        res = []</span><br><span class="line">        self.inorder(root, res)</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(res) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            t = res[i] + res[j]</span><br><span class="line">            <span class="keyword">if</span> t == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> t &lt; k:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(root.left, res)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        self.inorder(root.right, res)</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。</p>
<h3 id="655-Print-Binary-Tree-Medium"><a href="#655-Print-Binary-Tree-Medium" class="headerlink" title="655. Print Binary Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/print-binary-tree/">655. Print Binary Tree (Medium)</a></h3><p>Print a binary tree in an m*n 2D string array following these rules:</p>
<ol>
<li>The row number m should be equal to the height of the given binary tree.</li>
<li>The column number n should always be an odd number.</li>
<li>The root node’s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don’t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don’t need to leave space for both of them.</li>
<li>Each unused space should contain an empty string “”.</li>
<li>Print the subtrees following the same rules.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">     1</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line">Output:</span><br><span class="line">[[&quot;&quot;, &quot;1&quot;, &quot;&quot;],</span><br><span class="line"> [&quot;2&quot;, &quot;&quot;, &quot;&quot;]]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">     1</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \</span><br><span class="line">     4</span><br><span class="line">Output:</span><br><span class="line">[[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;1&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;],</span><br><span class="line"> [&quot;&quot;, &quot;2&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;3&quot;, &quot;&quot;],</span><br><span class="line"> [&quot;&quot;, &quot;&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]]</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input:</span><br><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   5</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br><span class="line">Output:</span><br><span class="line">[[&quot;&quot;,  &quot;&quot;,  &quot;&quot;, &quot;&quot;,  &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;1&quot;, &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;, &quot;&quot;, &quot;&quot;]</span><br><span class="line"> [&quot;&quot;,  &quot;&quot;,  &quot;&quot;, &quot;2&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;5&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]</span><br><span class="line"> [&quot;&quot;,  &quot;3&quot;, &quot;&quot;, &quot;&quot;,  &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;, &quot;&quot;, &quot;&quot;]</span><br><span class="line"> [&quot;4&quot;, &quot;&quot;,  &quot;&quot;, &quot;&quot;,  &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;,  &quot;&quot;, &quot;&quot;, &quot;&quot;]]</span><br></pre></td></tr></table></figure>
Note: The height of binary tree is in the range of [1, 10].</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        h = self.maxDepth(root)</span><br><span class="line">        w = <span class="number">2</span> ** h - <span class="number">1</span></span><br><span class="line">        ans = [[<span class="string">&quot;&quot;</span>] * w <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(h)]</span><br><span class="line">        self.updateMatrix(root, ans, <span class="number">0</span>, <span class="number">0</span>, w - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateMatrix</span>(<span class="params">self, root, ans, row, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        ans[row][mid] = <span class="built_in">str</span>(root.val)</span><br><span class="line">        self.updateMatrix(root.left, ans, row + <span class="number">1</span>, l, mid - <span class="number">1</span>)</span><br><span class="line">        self.updateMatrix(root.right, ans, row + <span class="number">1</span>, mid + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure>
<p>一刷：比较重要的insight是宽度是2 ** h - 1</p>
<h3 id="701-Insert-into-a-Binary-Search-Tree-Medium"><a href="#701-Insert-into-a-Binary-Search-Tree-Medium" class="headerlink" title="701. Insert into a Binary Search Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/description/">701. Insert into a Binary Search Tree (Medium)</a></h3><p>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.<br>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given the tree:</span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line">And the value to insert: 5</span><br><span class="line">You can return this binary search tree:</span><br><span class="line">         4</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     7</span><br><span class="line">     &#x2F; \   &#x2F;</span><br><span class="line">    1   3 5</span><br><span class="line">This tree is also valid:</span><br><span class="line">         5</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line">         \</span><br><span class="line">          4</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.insertIntoBST(root.right, val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.insertIntoBST(root.left, val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.left = TreeNode(val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        n = TreeNode(val)</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur != n:</span><br><span class="line">            <span class="keyword">if</span> n.val &gt; cur.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    cur.right = n</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                    cur.left = n</span><br><span class="line">                cur = cur.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>四刷：遍历：准备好数节点，遍历树直道cur和n相遇，如查到左或右该有此节点的地方不存在，即接上；有没有都往该方向走，</p>
<h3 id="173-Binary-Search-Tree-Iterator-Medium"><a href="#173-Binary-Search-Tree-Iterator-Medium" class="headerlink" title="173. Binary Search Tree Iterator (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator (Medium)</a></h3><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.<br>Calling next() will return the next smallest number in the BST.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="BST example"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; return 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; return false</span><br></pre></td></tr></table></figure>
<p>Note:<br>next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.<br>You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: TreeNode</span>):</span></span><br><span class="line">        self.s = []</span><br><span class="line">        self._inorderLeft(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        res = self.s.pop()</span><br><span class="line">        <span class="keyword">if</span> res.right:</span><br><span class="line">            self._inorderLeft(res.right)</span><br><span class="line">        <span class="keyword">return</span> res.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.s) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_inorderLeft</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            self.s.append(root)</span><br><span class="line">            root = root.left</span><br></pre></td></tr></table></figure>
<p>二刷：目前为O(h)空间，也可以O(n)的空间，还可以非常懒惰的init</p>
<h3 id="1120-Maximum-Average-Subtree-Medium-带锁"><a href="#1120-Maximum-Average-Subtree-Medium-带锁" class="headerlink" title="1120. Maximum Average Subtree (Medium) 带锁"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-average-subtree">1120. Maximum Average Subtree (Medium) 带锁</a></h3><p>Given a binary tree, find the subtree with maximum average. Return the root of the subtree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Example 1</span><br><span class="line">Input：</span><br><span class="line">&#123;1,-5,11,1,2,4,-2&#125;</span><br><span class="line">Output：11</span><br><span class="line">Explanation:</span><br><span class="line">The tree is look like this:</span><br><span class="line">     1</span><br><span class="line">   &#x2F;   \</span><br><span class="line"> -5     11</span><br><span class="line"> &#x2F; \   &#x2F;  \</span><br><span class="line">1   2 4    -2</span><br><span class="line">The average of subtree of 11 is 4.3333, is the maximun.</span><br><span class="line"></span><br><span class="line">Example 2</span><br><span class="line">Input：</span><br><span class="line">&#123;1,-5,11&#125;</span><br><span class="line">Output：11</span><br><span class="line">Explanation:</span><br><span class="line">     1</span><br><span class="line">   &#x2F;   \</span><br><span class="line"> -5     11</span><br><span class="line">The average of subtree of 1,-5,11 is 2.333,-5,11. So the subtree of 11 is the maximun.</span><br></pre></td></tr></table></figure>
<p>Notice<br>LintCode will print the subtree which root is your return node.<br>It’s guaranteed that there is only one subtree with maximum average.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubtree2</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.ans = (<span class="literal">None</span>, -sys.maxsize)</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        l, lCnt = self.helper(root.left)</span><br><span class="line">        r, rCnt = self.helper(root.right)</span><br><span class="line">        avg = (root.val + l * lCnt + r * rCnt) / (lCnt + rCnt + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ans[<span class="number">0</span>] <span class="keyword">or</span> avg &gt; self.ans[<span class="number">1</span>]:</span><br><span class="line">            self.ans = (root, avg)</span><br><span class="line">        <span class="keyword">return</span> avg, lCnt + rCnt + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="671-Second-Minimum-Node-In-a-Binary-Tree-Easy"><a href="#671-Second-Minimum-Node-In-a-Binary-Tree-Easy" class="headerlink" title="671. Second Minimum Node In a Binary Tree (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/">671. Second Minimum Node In a Binary Tree (Easy)</a></h3><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.<br>Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree.<br>If no such second minimum value exists, output -1 instead.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    5   7</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The smallest value is 2, but there isn&#39;t any second smallest value.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSecondMinimumValue</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.ans = sys.maxsize</span><br><span class="line">        self.smallest = root.val</span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans <span class="keyword">if</span> self.ans &lt; sys.maxsize <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.smallest &lt; root.val &lt; self.ans:</span><br><span class="line">            self.ans = root.val</span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        self.helper(root.right)</span><br></pre></td></tr></table></figure>
<p>一刷：O(n) time, O(1) space, O(h) callstack</p>
<h3 id="530-Minimum-Absolute-Difference-in-BST-Easy"><a href="#530-Minimum-Absolute-Difference-in-BST-Easy" class="headerlink" title="530. Minimum Absolute Difference in BST (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST (Easy)</a></h3><p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line">Output:</span><br><span class="line">1</span><br><span class="line">Explanation:</span><br><span class="line">The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</span><br></pre></td></tr></table></figure>
<p>Note: There are at least two nodes in this BST.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.ans = sys.maxsize</span><br><span class="line">        self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.pre:</span><br><span class="line">            self.ans = <span class="built_in">min</span>(self.ans, root.val - self.pre.val)</span><br><span class="line">        self.pre = root</span><br><span class="line">        self.inorder(root.right)</span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal-Medium"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal-Medium" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. Construct Binary Search Tree from Preorder Traversal (Medium)</a></h3><p>Return the root node of a binary search tree that matches the given preorder traversal.<br>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</p>
<p>Example 1:<br>Input: [8,5,1,7,10,12]<br>Output: [8,5,10,1,7,null,12]<br><img src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" alt="Construct Binary Search Tree from Preorder Traversal example"></p>
<p>Note:<br>1 &lt;= preorder.length &lt;= 100<br>The values of preorder are distinct.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &gt; <span class="number">1</span>:</span><br><span class="line">            rIdxs = [i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(preorder) <span class="keyword">if</span> v &gt; preorder[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rIdxs:</span><br><span class="line">                root.left = self.bstFromPreorder(preorder[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.left = self.bstFromPreorder(preorder[<span class="number">1</span>:rIdxs[<span class="number">0</span>]])</span><br><span class="line">                root.right = self.bstFromPreorder(preorder[rIdxs[<span class="number">0</span>]:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag</p>
<h3 id="987-Vertical-Order-Traversal-of-a-Binary-Tree-Medium"><a href="#987-Vertical-Order-Traversal-of-a-Binary-Tree-Medium" class="headerlink" title="987. Vertical Order Traversal of a Binary Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">987. Vertical Order Traversal of a Binary Tree (Medium)</a></h3><p>Given a binary tree, return the vertical order traversal of its nodes values.<br>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).<br>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).<br>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.<br>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG" alt="Vertical Order Traversal of a Binary Tree exmaple1"><br>Input: [3,9,20,null,null,15,7]<br>Output: [[9],[3,15],[20],[7]]<br>Explanation:<br>Without loss of generality, we can assume the root node is at position (0, 0):<br>Then, the node with value 9 occurs at position (-1, -1);<br>The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);<br>The node with value 20 occurs at position (1, -1);<br>The node with value 7 occurs at position (2, -2).</p>
<p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/01/31/tree2.png" alt="Vertical Order Traversal of a Binary Tree exmaple2"><br>Input: [1,2,3,4,5,6,7]<br>Output: [[4],[2],[1,5,6],[3],[7]]<br>Explanation:<br>The node with value 5 and the node with value 6 have the same position according to the given scheme.<br>However, in the report “[1,5,6]”, the node value of 5 comes first since 5 is smaller than 6.</p>
<p>Note:<br>The tree will have between 1 and 1000 nodes.<br>Each node’s value will be between 0 and 1000.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        mapping = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.helper(root, mapping, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        print(mapping)</span><br><span class="line">        res = <span class="built_in">sorted</span>(mapping.keys(), key = <span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line">        res = <span class="built_in">sorted</span>(res, key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        ans = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> res:</span><br><span class="line">            ans[k[<span class="number">0</span>]].extend(<span class="built_in">sorted</span>(mapping[k]))</span><br><span class="line">        <span class="keyword">return</span> [ans[k] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(ans.keys())]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, mapping, x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mapping[x, y].append(root.val)</span><br><span class="line">        self.helper(root.left, mapping, x - <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">        self.helper(root.right, mapping, x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag</p>
<h3 id="872-Leaf-Similar-Trees-Easy"><a href="#872-Leaf-Similar-Trees-Easy" class="headerlink" title="872. Leaf-Similar Trees (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/leaf-similar-trees/">872. Leaf-Similar Trees (Easy)</a></h3><p>Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="Leaf-Similar Trees example"><br>For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).<br>Two binary trees are considered leaf-similar if their leaf value sequence is the same.<br>Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</p>
<p>Note:<br>Both of the given trees will have between 1 and 100 nodes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leafSimilar</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        leafs1 = []</span><br><span class="line">        self.helper(root1, leafs1)</span><br><span class="line">        leafs2 = []</span><br><span class="line">        self.helper(root2, leafs2)</span><br><span class="line">        <span class="keyword">return</span> leafs1 == leafs2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            arr.append(root.val)</span><br><span class="line">        self.helper(root.left, arr)</span><br><span class="line">        self.helper(root.right, arr)</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag，其他submission里有酷炫的generator yield from写法</p>
<h3 id="863-All-Nodes-Distance-K-in-Binary-Tree-Medium"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree-Medium" class="headerlink" title="863. All Nodes Distance K in Binary Tree (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">863. All Nodes Distance K in Binary Tree (Medium)</a></h3><p>We are given a binary tree (with root node root), a target node, and an integer value K.<br>Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</p>
<p>Example 1:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br>Output: [7,4,1]<br>Explanation:<br>The nodes that are a distance 2 from the target node (with value 5)<br>have values 7, 4, and 1.<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="All Nodes Distance K in Binary Tree example"><br>Note that the inputs “root” and “target” are actually TreeNodes.<br>The descriptions of the inputs above are just serializations of these objects.</p>
<p>Note:<br>The given tree is non-empty.<br>Each node in the tree has unique values 0 &lt;= node.val &lt;= 500.<br>The target node is a node in the tree.<br>0 &lt;= K &lt;= 1000.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span>(<span class="params">self, root, target, K</span>):</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        neighbors = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.buildGraph(root, neighbors)</span><br><span class="line">        ans = []</span><br><span class="line">        self.visited = <span class="built_in">set</span>()</span><br><span class="line">        self.dfs(ans, target, neighbors, K)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span>(<span class="params">self, root, neighbors</span>):</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            root = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                neighbors[root].append(root.left)</span><br><span class="line">                neighbors[root.left].append(root)</span><br><span class="line">                q.append(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                neighbors[root].append(root.right)</span><br><span class="line">                neighbors[root.right].append(root)</span><br><span class="line">                q.append(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, ans, cur, neighbors, K</span>):</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">            ans.append(cur.val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.visited.add(cur)</span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors[cur]:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">                self.dfs(ans, neighbor, neighbors, K - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="442-Find-All-Duplicates-in-an-Array-Medium"><a href="#442-Find-All-Duplicates-in-an-Array-Medium" class="headerlink" title="442. Find All Duplicates in an Array (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-duplicates-in-an-array/">442. Find All Duplicates in an Array (Medium)</a></h3><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.<br>Find all the elements that appear twice in this array.<br>Could you do it without extra space and in O(n) runtime?</p>
<p>Example:<br>Input:<br>[4,3,2,7,8,2,3,1]<br>Output:<br>[2,3]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="built_in">abs</span>(v) - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="built_in">abs</span>(v))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[<span class="built_in">abs</span>(v) - <span class="number">1</span>]  = -nums[<span class="built_in">abs</span>(v) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：维萨。O(n) time O(1) space需要flip当前数-1所在的位置的符号，然后检查abs(每个当前数)-1位置是否已为负数</p>
<h3 id="240-Search-a-2D-Matrix-II-Medium"><a href="#240-Search-a-2D-Matrix-II-Medium" class="headerlink" title="240. Search a 2D Matrix II (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/">240. Search a 2D Matrix II (Medium)</a></h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">Given target &#x3D; 5, return true.</span><br><span class="line">Given target &#x3D; 20, return false.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        r, c = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt;= <span class="built_in">len</span>(matrix) - <span class="number">1</span> <span class="keyword">and</span> c &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> target == matrix[r][c]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#if target &gt; matrix[r][c] the anser cannot be in the row</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; matrix[r][c]:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="comment">#if target &lt; matrix[r][c] the answer cannot be in the column</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>总结：不好的题， 因为需要一个insight就能解</p>
<h3 id="986-Interval-List-Intersections-Medium"><a href="#986-Interval-List-Intersections-Medium" class="headerlink" title="986. Interval List Intersections (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/interval-list-intersections/">986. Interval List Intersections (Medium)</a></h3><p>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.<br>Return the intersection of these two interval lists.<br>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" alt="Interval List Intersections example"><br>Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]<br>Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]<br>Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</p>
<p>Note:<br>0 &lt;= A.length &lt; 1000<br>0 &lt;= B.length &lt; 1000<br>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9<br>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span>(<span class="params">self, A: List[List[<span class="built_in">int</span>]], B: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            lo = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>])</span><br><span class="line">            hi = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= hi:</span><br><span class="line">                ans.append([lo, hi])</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>一刷：Facebook tag</p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/description/">347. Top K Frequent Elements (Medium)</a></h3><p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>Example 1:<br>Input: nums = [1,1,1,2,2,3], k = 2<br>Output: [1,2]</p>
<p>Example 2:<br>Input: nums = [1], k = 1<br>Output: [1]</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        counter = Counter(nums)</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        pq = []</span><br><span class="line">        <span class="keyword">for</span> key, v <span class="keyword">in</span> counter.items():</span><br><span class="line">            heapq.heappush(pq, (v, key))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pq) &gt; k:</span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">        <span class="keyword">return</span> [key <span class="keyword">for</span> (v, key) <span class="keyword">in</span> pq]</span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="349-Intersection-of-Two-Arrays-Easy"><a href="#349-Intersection-of-Two-Arrays-Easy" class="headerlink" title="349. Intersection of Two Arrays (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays/description/">349. Intersection of Two Arrays (Easy)</a></h3><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2]</p>
<p>Example 2:<br>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [9,4]</p>
<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        nums1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        nums2 = <span class="built_in">set</span>(nums2)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums2) &lt; <span class="built_in">len</span>(nums1):</span><br><span class="line">            nums1, nums2 = nums2, nums1</span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">                ans.add(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>一刷</p>
<h3 id="350-Intersection-of-Two-Arrays-II-Easy"><a href="#350-Intersection-of-Two-Arrays-II-Easy" class="headerlink" title="350. Intersection of Two Arrays II (Easy)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/">350. Intersection of Two Arrays II (Easy)</a></h3><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2,2]</p>
<p>Example 2:<br>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [4,9]</p>
<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p>
<p>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        counter1 = Counter(nums1)</span><br><span class="line">        counter2 = Counter(nums2)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(counter2) &gt; <span class="built_in">len</span>(counter1):</span><br><span class="line">            counter1, counter2 = counter2, counter1</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> counter1:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> counter2:</span><br><span class="line">                ans.extend([k] * <span class="built_in">min</span>(counter1[k], counter2[k]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>二刷</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/05/03/201805-osaka-kyoto/" rel="prev" title="2018年五一假期日本大阪京都奈良6日游">
                  <i class="fa fa-chevron-left"></i> 2018年五一假期日本大阪京都奈良6日游
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
